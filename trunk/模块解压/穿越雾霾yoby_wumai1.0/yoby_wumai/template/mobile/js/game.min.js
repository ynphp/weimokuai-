var cc = cc || {};
var getScore;
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
_p = window;
_p = Object.prototype;
delete window._p;
cc.newElement = function(t) {
	return document.createElement(t)
};
cc._addEventListener = function(t, e, i, n) {
	t.addEventListener(e, i, n)
};
cc._isNodeJs = "undefined" !== typeof require && require("fs");
cc.each = function(t, e, i) {
	if (t) if (t instanceof Array) for (var n = 0, r = t.length; n < r && !1 !== e.call(i, t[n], n); n++);
	else for (n in t) if (!1 === e.call(i, t[n], n)) break
};
cc.extend = function(t) {
	var e = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
	cc.each(e, function(e) {
		for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
	});
	return t
};
cc.isFunction = function(t) {
	return "function" == typeof t
};
cc.isNumber = function(t) {
	return "number" == typeof t || "[object Number]" == Object.prototype.toString.call(t)
};
cc.isString = function(t) {
	return "string" == typeof t || "[object String]" == Object.prototype.toString.call(t)
};
cc.isArray = function(t) {
	return "[object Array]" == Object.prototype.toString.call(t)
};
cc.isUndefined = function(t) {
	return "undefined" == typeof t
};
cc.isObject = function(t) {
	var e = typeof t;
	return "function" == e || t && "object" == e
};
cc.isCrossOrigin = function(t) {
	if (!t) return cc.log("invalid URL"), !1;
	var e = t.indexOf("://");
	if (-1 == e) return !1;
	e = t.indexOf("/", e + 3);
	return (-1 == e ? t : t.substring(0, e)) != location.origin
};
cc.AsyncPool = function(t, e, i, n, r) {
	var c = this;
	c._srcObj = t;
	c._limit = e;
	c._pool = [];
	c._iterator = i;
	c._iteratorTarget = r;
	c._onEnd = n;
	c._onEndTarget = r;
	c._results = t instanceof Array ? [] : {};
	c._isErr = !1;
	cc.each(t, function(t, e) {
		c._pool.push({
			index: e,
			value: t
		})
	});
	c.size = c._pool.length;
	c.finishedSize = 0;
	c._workingSize = 0;
	c._limit = c._limit || c.size;
	c.onIterator = function(t, e) {
		c._iterator = t;
		c._iteratorTarget = e
	};
	c.onEnd = function(t, e) {
		c._onEnd = t;
		c._onEndTarget = e
	};
	c._handleItem = function() {
		var t = this;
		if (0 != t._pool.length && !(t._workingSize >= t._limit)) {
			var e = t._pool.shift(),
				i = e.value,
				n = e.index;
			t._workingSize++;
			t._iterator.call(t._iteratorTarget, i, n, function(e) {
				if (!t._isErr) if (t.finishedSize++, t._workingSize--, e) t._isErr = !0, t._onEnd && t._onEnd.call(t._onEndTarget, e);
				else {
					var i = Array.prototype.slice.call(arguments, 1);
					t._results[this.index] = i[0];
					t.finishedSize == t.size ? t._onEnd && t._onEnd.call(t._onEndTarget, null, t._results) : t._handleItem()
				}
			}.bind(e), t)
		}
	};
	c.flow = function() {
		if (0 == this._pool.length) this._onEnd && this._onEnd.call(this._onEndTarget, null, []);
		else for (var t = 0; t < this._limit; t++) this._handleItem()
	}
};
cc.async = {
	series: function(t, e, i) {
		t = new cc.AsyncPool(t, 1, function(t, e, n) {
			t.call(i, n)
		}, e, i);
		t.flow();
		return t
	},
	parallel: function(t, e, i) {
		t = new cc.AsyncPool(t, 0, function(t, e, n) {
			t.call(i, n)
		}, e, i);
		t.flow();
		return t
	},
	waterfall: function(t, e, i) {
		var n = [],
			r = [null],
			c = new cc.AsyncPool(t, 1, function(e, c, s) {
				n.push(function(e) {
					n = Array.prototype.slice.call(arguments, 1);
					t.length - 1 == c && (r = r.concat(n));
					s.apply(null, arguments)
				});
				e.apply(i, n)
			}, function(t) {
				if (e) {
					if (t) return e.call(i, t);
					e.apply(i, r)
				}
			});
		c.flow();
		return c
	},
	map: function(t, e, i, n) {
		var r = e;
		"object" == typeof e && (i = e.cb, n = e.iteratorTarget, r = e.iterator);
		t = new cc.AsyncPool(t, 0, r, i, n);
		t.flow();
		return t
	},
	mapLimit: function(t, e, i, n, r) {
		t = new cc.AsyncPool(t, e, i, n, r);
		t.flow();
		return t
	}
};
cc.path = {
	join: function() {
		for (var t = arguments.length, e = "", i = 0; i < t; i++) e = (e + ("" == e ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
		return e
	},
	extname: function(t) {
		return (t = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(t)) ? t[1] : null
	},
	mainFileName: function(t) {
		if (t) {
			var e = t.lastIndexOf(".");
			if (-1 !== e) return t.substring(0, e)
		}
		return t
	},
	basename: function(t, e) {
		var i = t.indexOf("?");
		0 < i && (t = t.substring(0, i));
		i = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(t.replace(/(\/|\\\\)$/, ""));
		if (!i) return null;
		i = i[2];
		return e && t.substring(t.length - e.length).toLowerCase() == e.toLowerCase() ? i.substring(0, i.length - e.length) : i
	},
	dirname: function(t) {
		return t.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
	},
	changeExtname: function(t, e) {
		e = e || "";
		var i = t.indexOf("?"),
			n = "";
		0 < i && (n = t.substring(i), t = t.substring(0, i));
		i = t.lastIndexOf(".");
		return 0 > i ? t + e + n : t.substring(0, i) + e + n
	},
	changeBasename: function(t, e, i) {
		if (0 == e.indexOf(".")) return this.changeExtname(t, e);
		var n = t.indexOf("?"),
			r = "";
		i = i ? this.extname(t) : "";
		0 < n && (r = t.substring(n), t = t.substring(0, n));
		n = t.lastIndexOf("/");
		return t.substring(0, 0 >= n ? 0 : n + 1) + e + i + r
	}
};
cc.loader = {
	_jsCache: {},
	_register: {},
	_langPathCache: {},
	_aliases: {},
	resPath: "",
	audioPath: "",
	cache: {},
	getXMLHttpRequest: function() {
		return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
	},
	_getArgs4Js: function(t) {
		var e = t[0],
			i = t[1],
			n = t[2],
			r = ["", null, null];
		if (1 === t.length) r[1] = e instanceof Array ? e : [e];
		else if (2 === t.length)"function" == typeof i ? (r[1] = e instanceof Array ? e : [e], r[2] = i) : (r[0] = e || "", r[1] = i instanceof Array ? i : [i]);
		else if (3 === t.length) r[0] = e || "", r[1] = i instanceof Array ? i : [i], r[2] = n;
		else throw "arguments error to load js!";
		return r
	},
	loadJs: function(t, e, i) {
		var n = this,
			r = n._jsCache,
			c = n._getArgs4Js(arguments),
			s = c[0],
			o = c[1],
			c = c[2]; - 1 < navigator.userAgent.indexOf("Trident/5") ? n._loadJs4Dependency(s, o, 0, c) : cc.async.map(o, function(t, e, i) {
			t = cc.path.join(s, t);
			if (r[t]) return i(null);
			n._createScript(t, !1, i)
		}, c)
	},
	loadJsWithImg: function(t, e, i) {
		var n = this._loadJsImg(),
			r = this._getArgs4Js(arguments);
		this.loadJs(r[0], r[1], function(t) {
			if (t) throw t;
			n.parentNode.removeChild(n);
			if (r[2]) r[2]()
		})
	},
	_createScript: function(t, e, i) {
		var n = document,
			r = cc.newElement("script");
		r.async = e;
		r.src = t;
		this._jsCache[t] = !0;
		cc._addEventListener(r, "load", function() {
			r.parentNode.removeChild(r);
			this.removeEventListener("load", arguments.callee, !1);
			i()
		}, !1);
		cc._addEventListener(r, "error", function() {
			r.parentNode.removeChild(r);
			i("Load " + t + " failed!")
		}, !1);
		n.body.appendChild(r)
	},
	_loadJs4Dependency: function(t, e, i, n) {
		if (i >= e.length) n && n();
		else {
			var r = this;
			r._createScript(cc.path.join(t, e[i]), !1, function(c) {
				if (c) return n(c);
				r._loadJs4Dependency(t, e, i + 1, n)
			})
		}
	},
	_loadJsImg: function() {
		var t = document,
			e = t.getElementById("cocos2d_loadJsImg");
		if (!e) {
			e = cc.newElement("img");
			cc._loadingImage && (e.src = cc._loadingImage);
			t = t.getElementById(cc.game.config.id);
			t.style.backgroundColor = "black";
			t.parentNode.appendChild(e);
			var i = getComputedStyle ? getComputedStyle(t) : t.currentStyle;
			i || (i = {
				width: t.width,
				height: t.height
			});
			e.style.left = t.offsetLeft + (parseFloat(i.width) - e.width) / 2 + "px";
			e.style.top = t.offsetTop + (parseFloat(i.height) - e.height) / 2 + "px";
			e.style.position = "absolute"
		}
		return e
	},
	loadTxt: function(t, e) {
		if (cc._isNodeJs) require("fs").readFile(t, function(t, i) {
			t ? e(t) : e(null, i.toString())
		});
		else {
			var i = this.getXMLHttpRequest(),
				n = "load " + t + " failed!";
			i.open("GET", t, !0);
			/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (i.setRequestHeader("Accept-Charset", "utf-8"), i.onreadystatechange = function() {
				4 == i.readyState && (200 == i.status ? e(null, i.responseText) : e(n))
			}) : (i.overrideMimeType && i.overrideMimeType("text/plain; charset=utf-8"), i.onload = function() {
				4 == i.readyState && (200 == i.status ? e(null, i.responseText) : e(n))
			});
			i.send(null)
		}
	},
	_loadTxtSync: function(t) {
		if (cc._isNodeJs) return require("fs").readFileSync(t).toString();
		var e = this.getXMLHttpRequest();
		e.open("GET", t, !1);
		/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? e.setRequestHeader("Accept-Charset", "utf-8") : e.overrideMimeType && e.overrideMimeType("text/plain; charset=utf-8");
		e.send(null);
		return 4 == !e.readyState || 200 != e.status ? null : e.responseText
	},
	loadCsb: function(t, e) {
		var i = new XMLHttpRequest;
		i.open("GET", t, !0);
		i.responseType = "arraybuffer";
		i.onload = function() {
			var n = i.response;
			n && (window.msg = n);
			4 == i.readyState && (200 == i.status ? e(null, i.response) : e("load " + t + " failed!"))
		};
		i.send(null)
	},
	loadJson: function(t, e) {
		this.loadTxt(t, function(i, n) {
			if (i) e(i);
			else {
				try {
					var r = JSON.parse(n)
				} catch (c) {
					throw "parse json [" + t + "] failed : " + c
				}
				e(null, r)
			}
		})
	},
	_checkIsImageURL: function(t) {
		return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(t)
	},
	loadImg: function(t, e, i) {
		var n = {
			isCrossOrigin: !0
		};
		void 0 !== i ? n.isCrossOrigin = null == e.isCrossOrigin ? n.isCrossOrigin : e.isCrossOrigin : void 0 !== e && (i = e);
		var r = this.getRes(t);
		if (r) return i && i(null, r), r;
		r = new Image;
		n.isCrossOrigin && "file://" != location.origin && (r.crossOrigin = "Anonymous");
		var c = function() {
				this.removeEventListener("load", c, !1);
				this.removeEventListener("error", s, !1);
				cc.loader.cache[t] = r;
				i && i(null, r)
			},
			s = function() {
				this.removeEventListener("error", s, !1);
				r.crossOrigin && "anonymous" == r.crossOrigin.toLowerCase() ? (n.isCrossOrigin = !1, cc.loader.loadImg(t, n, i)) : "function" == typeof i && i("load image failed")
			};
		cc._addEventListener(r, "load", c);
		cc._addEventListener(r, "error", s);
		r.src = t;
		return r
	},
	_loadResIterator: function(t, e, i) {
		var n = this,
			r = null,
			c = t.type;
		c ? (c = "." + c.toLowerCase(), r = t.src ? t.src : t.name + c) : (r = t, c = cc.path.extname(r));
		if (e = n.getRes(r)) return i(null, e);
		e = null;
		c && (e = n._register[c.toLowerCase()]);
		if (!e) return cc.error("loader for [" + c + "] not exists!"), i();
		c = e.getBasePath ? e.getBasePath() : n.resPath;
		c = n.getUrl(c, r);
		e.load(c, r, t, function(t, e) {
			t ? (cc.log(t), n.cache[r] = null, delete n.cache[r], i()) : (n.cache[r] = e, i(null, e))
		})
	},
	getUrl: function(t, e) {
		var i = this._langPathCache,
			n = cc.path;
		if (void 0 !== t && void 0 === e) {
			e = t;
			var r = n.extname(e),
				r = r ? r.toLowerCase() : "";
			t = (r = this._register[r]) ? r.getBasePath ? r.getBasePath() : this.resPath : this.resPath
		}
		e = cc.path.join(t || "", e);
		if (e.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
			if (i[e]) return i[e];
			n = n.extname(e) || "";
			e = i[e] = e.substring(0, e.length - n.length) + "_" + cc.sys.language + n
		}
		return e
	},
	load: function(t, e, i) {
		var n = this,
			r = arguments.length;
		if (0 == r) throw "arguments error!";
		3 == r ? "function" == typeof e && (e = "function" == typeof i ? {
			trigger: e,
			cb: i
		} : {
			cb: e,
			cbTarget: i
		}) : 2 == r ? "function" == typeof e && (e = {
			cb: e
		}) : 1 == r && (e = {});
		t instanceof Array || (t = [t]);
		r = new cc.AsyncPool(t, 0, function(t, i, r, c) {
			n._loadResIterator(t, i, function(t) {
				if (t) return r(t);
				var i = Array.prototype.slice.call(arguments, 1);
				e.trigger && e.trigger.call(e.triggerTarget, i[0], c.size, c.finishedSize);
				r(null, i[0])
			})
		}, e.cb, e.cbTarget);
		r.flow();
		return r
	},
	_handleAliases: function(t, e) {
		var i = this._aliases,
			n = [],
			r;
		for (r in t) {
			var c = t[r];
			i[r] = c;
			n.push(c)
		}
		this.load(n, e)
	},
	loadAliases: function(t, e) {
		var i = this,
			n = i.getRes(t);
		n ? i._handleAliases(n.filenames, e) : i.load(t, function(t, n) {
			i._handleAliases(n[0].filenames, e)
		})
	},
	register: function(t, e) {
		if (t && e) {
			if ("string" == typeof t) return this._register[t.trim().toLowerCase()] = e;
			for (var i = 0, n = t.length; i < n; i++) this._register["." + t[i].trim().toLowerCase()] = e
		}
	},
	getRes: function(t) {
		return this.cache[t] || this.cache[this._aliases[t]]
	},
	release: function(t) {
		var e = this.cache,
			i = this._aliases;
		delete e[t];
		delete e[i[t]];
		delete i[t]
	},
	releaseAll: function() {
		var t = this.cache,
			e = this._aliases,
			i;
		for (i in t) delete t[i];
		for (i in e) delete e[i]
	}
};
cc.formatStr = function() {
	var t = arguments,
		e = t.length;
	if (1 > e) return "";
	var i = t[0],
		n = !0;
	"object" == typeof i && (n = !1);
	for (var r = 1; r < e; ++r) {
		var c = t[r];
		if (n) for (;;) {
			var s = null;
			if ("number" == typeof c && (s = i.match(/(%d)|(%s)/))) {
				i = i.replace(/(%d)|(%s)/, c);
				break
			}
			i = (s = i.match(/%s/)) ? i.replace(/%s/, c) : i + ("    " + c);
			break
		} else i += "    " + c
	}
	return i
};
(function() {
	var t = window,
		e, i;
	cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (e = "webkitHidden", i = "webkitvisibilitychange") : (e = "msHidden", i = "msvisibilitychange") : (e = "mozHidden", i = "mozvisibilitychange") : (e = "hidden", i = "visibilitychange");
	var n = function() {
			cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
		},
		r = function() {
			cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow);
			cc.game._intervalId && (window.cancelAnimationFrame(cc.game._intervalId), cc.game._runMainLoop())
		};
	e ? cc._addEventListener(document, i, function() {
		document[e] ? n() : r()
	}, !1) : (cc._addEventListener(t, "blur", n, !1), cc._addEventListener(t, "focus", r, !1)); - 1 < navigator.userAgent.indexOf("MicroMessenger") && (t.onfocus = function() {
		r()
	});
	"onpageshow" in window && "onpagehide" in window && (cc._addEventListener(t, "pagehide", n, !1), cc._addEventListener(t, "pageshow", r, !1));
	i = t = null
})();
cc.log = cc.warn = cc.error = cc.assert = function() {};
cc.create3DContext = function(t, e) {
	for (var i = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], n = null, r = 0; r < i.length; ++r) {
		try {
			n = t.getContext(i[r], e)
		} catch (c) {}
		if (n) break
	}
	return n
};
cc._initSys = function(t, e) {
	cc._RENDER_TYPE_CANVAS = 0;
	cc._RENDER_TYPE_WEBGL = 1;
	cc.sys = {};
	var i = cc.sys;
	i.LANGUAGE_ENGLISH = "en";
	i.LANGUAGE_CHINESE = "zh";
	i.LANGUAGE_FRENCH = "fr";
	i.LANGUAGE_ITALIAN = "it";
	i.LANGUAGE_GERMAN = "de";
	i.LANGUAGE_SPANISH = "es";
	i.LANGUAGE_DUTCH = "du";
	i.LANGUAGE_RUSSIAN = "ru";
	i.LANGUAGE_KOREAN = "ko";
	i.LANGUAGE_JAPANESE = "ja";
	i.LANGUAGE_HUNGARIAN = "hu";
	i.LANGUAGE_PORTUGUESE = "pt";
	i.LANGUAGE_ARABIC = "ar";
	i.LANGUAGE_NORWEGIAN = "no";
	i.LANGUAGE_POLISH = "pl";
	i.OS_WINDOWS = "Windows";
	i.OS_IOS = "iOS";
	i.OS_OSX = "OS X";
	i.OS_UNIX = "UNIX";
	i.OS_LINUX = "Linux";
	i.OS_ANDROID = "Android";
	i.OS_UNKNOWN = "Unknown";
	i.WINDOWS = 0;
	i.LINUX = 1;
	i.MACOS = 2;
	i.ANDROID = 3;
	i.IPHONE = 4;
	i.IPAD = 5;
	i.BLACKBERRY = 6;
	i.NACL = 7;
	i.EMSCRIPTEN = 8;
	i.TIZEN = 9;
	i.WINRT = 10;
	i.WP8 = 11;
	i.MOBILE_BROWSER = 100;
	i.DESKTOP_BROWSER = 101;
	i.BROWSER_TYPE_WECHAT = "wechat";
	i.BROWSER_TYPE_ANDROID = "androidbrowser";
	i.BROWSER_TYPE_IE = "ie";
	i.BROWSER_TYPE_QQ = "qqbrowser";
	i.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
	i.BROWSER_TYPE_UC = "ucbrowser";
	i.BROWSER_TYPE_360 = "360browser";
	i.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
	i.BROWSER_TYPE_BAIDU = "baidubrowser";
	i.BROWSER_TYPE_MAXTHON = "maxthon";
	i.BROWSER_TYPE_OPERA = "opera";
	i.BROWSER_TYPE_OUPENG = "oupeng";
	i.BROWSER_TYPE_MIUI = "miuibrowser";
	i.BROWSER_TYPE_FIREFOX = "firefox";
	i.BROWSER_TYPE_SAFARI = "safari";
	i.BROWSER_TYPE_CHROME = "chrome";
	i.BROWSER_TYPE_UNKNOWN = "unknown";
	i.isNative = !1;
	var n = [i.BROWSER_TYPE_BAIDU, i.BROWSER_TYPE_OPERA, i.BROWSER_TYPE_FIREFOX, i.BROWSER_TYPE_CHROME, i.BROWSER_TYPE_SAFARI],
		r = [i.OS_IOS, i.OS_WINDOWS, i.OS_OSX, i.OS_LINUX],
		c = [i.BROWSER_TYPE_BAIDU, i.BROWSER_TYPE_OPERA, i.BROWSER_TYPE_FIREFOX, i.BROWSER_TYPE_CHROME, i.BROWSER_TYPE_BAIDU_APP, i.BROWSER_TYPE_SAFARI, i.BROWSER_TYPE_UC, i.BROWSER_TYPE_QQ, i.BROWSER_TYPE_MOBILE_QQ, i.BROWSER_TYPE_IE],
		s = window,
		o = s.navigator,
		a = document.documentElement,
		h = o.userAgent.toLowerCase();
	i.isMobile = -1 != h.indexOf("mobile") || -1 != h.indexOf("android");
	i.platform = i.isMobile ? i.MOBILE_BROWSER : i.DESKTOP_BROWSER;
	var l = o.language,
		l = (l = l ? l : o.browserLanguage) ? l.split("-")[0] : i.LANGUAGE_ENGLISH;
	i.language = l;
	var l = i.BROWSER_TYPE_UNKNOWN,
		u = h.match(/micromessenger|qqbrowser|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|trident|oupeng|opera|miuibrowser|firefox/i) || h.match(/chrome|safari/i);
	u && 0 < u.length && (l = u[0].toLowerCase(), "micromessenger" == l ? l = i.BROWSER_TYPE_WECHAT : "safari" === l && h.match(/android.*applewebkit/) ? l = i.BROWSER_TYPE_ANDROID : "trident" == l ? l = i.BROWSER_TYPE_IE : "360 aphone" == l && (l = i.BROWSER_TYPE_360));
	i.browserType = l;
	l = h.match(/(iPad|iPhone|iPod)/i) ? !0 : !1;
	h = h.match(/android/i) || o.platform.match(/android/i) ? !0 : !1;
	u = i.OS_UNKNOWN; - 1 != o.appVersion.indexOf("Win") ? u = i.OS_WINDOWS : l ? u = i.OS_IOS : -1 != o.appVersion.indexOf("Mac") ? u = i.OS_OSX : -1 != o.appVersion.indexOf("X11") ? u = i.OS_UNIX : h ? u = i.OS_ANDROID : -1 != o.appVersion.indexOf("Linux") && (u = i.OS_LINUX);
	i.os = u;
	i._supportMultipleAudio = -1 < c.indexOf(i.browserType);
	c = parseInt(t[e.renderMode]);
	h = cc._RENDER_TYPE_WEBGL;
	l = cc.newElement("Canvas");
	cc._supportRender = !0;
	n = !window.WebGLRenderingContext || -1 == n.indexOf(i.browserType) || -1 == r.indexOf(i.os);
	if (1 === c || 0 === c && n || "file://" == location.origin) h = cc._RENDER_TYPE_CANVAS;
	i._canUseCanvasNewBlendModes = function() {
		var t = document.createElement("canvas");
		t.width = 1;
		t.height = 1;
		t = t.getContext("2d");
		t.fillStyle = "#000";
		t.fillRect(0, 0, 1, 1);
		t.globalCompositeOperation = "multiply";
		var e = document.createElement("canvas");
		e.width = 1;
		e.height = 1;
		var i = e.getContext("2d");
		i.fillStyle = "#fff";
		i.fillRect(0, 0, 1, 1);
		t.drawImage(e, 0, 0, 1, 1);
		return 0 === t.getImageData(0, 0, 1, 1).data[0]
	};
	i._supportCanvasNewBlendModes = i._canUseCanvasNewBlendModes();
	if (h == cc._RENDER_TYPE_WEBGL && (!s.WebGLRenderingContext || !cc.create3DContext(l, {
		stencil: !0,
		preserveDrawingBuffer: !0
	}))) 0 == c ? h = cc._RENDER_TYPE_CANVAS : cc._supportRender = !1;
	if (h == cc._RENDER_TYPE_CANVAS) try {
		l.getContext("2d")
	} catch (d) {
		cc._supportRender = !1
	}
	cc._renderType = h;
	try {
		i._supportWebAudio = !(!s.AudioContext && !s.webkitAudioContext && !s.mozAudioContext)
	} catch (_) {
		i._supportWebAudio = !1
	}
	try {
		var f = i.localStorage = s.localStorage;
		f.setItem("storage", "");
		f.removeItem("storage");
		f = null
	} catch (p) {
		("SECURITY_ERR" === p.name || "QuotaExceededError" === p.name) && cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option"), i.localStorage = function() {}
	}
	f = i.capabilities = {
		canvas: !0
	};
	cc._renderType == cc._RENDER_TYPE_WEBGL && (f.opengl = !0);
	if (void 0 !== a.ontouchstart || o.msPointerEnabled) f.touches = !0;
	void 0 !== a.onmouseup && (f.mouse = !0);
	void 0 !== a.onkeyup && (f.keyboard = !0);
	if (s.DeviceMotionEvent || s.DeviceOrientationEvent) f.accelerometer = !0;
	i.garbageCollect = function() {};
	i.dumpRoot = function() {};
	i.restartVM = function() {};
	i.cleanScript = function(t) {};
	i.dump = function() {
		var t;
		t = "" + ("isMobile : " + this.isMobile + "\r\n");
		t += "language : " + this.language + "\r\n";
		t += "browserType : " + this.browserType + "\r\n";
		t += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
		t += "os : " + this.os + "\r\n";
		t += "platform : " + this.platform + "\r\n";
		cc.log(t)
	}
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = !1;
cc._setupCalled = !1;
cc._setup = function(t, e, i) {
	if (!cc._setupCalled) {
		cc._setupCalled = !0;
		var n = window,
			r = new Date,
			c = 1e3 / cc.game.config[cc.game.CONFIG_KEY.frameRate],
			s = function(t) {
				var e = (new Date).getTime(),
					i = Math.max(0, c - (e - r)),
					n = window.setTimeout(function() {
						t()
					}, i);
				r = e + i;
				return n
			},
			o = function(t) {
				clearTimeout(t)
			};
		cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT ? (n.requestAnimFrame = s, n.cancelAnimationFrame = o) : 60 != cc.game.config[cc.game.CONFIG_KEY.frameRate] ? (n.requestAnimFrame = s, n.cancelAnimationFrame = o) : (n.requestAnimFrame = n.requestAnimationFrame || n.webkitRequestAnimationFrame || n.mozRequestAnimationFrame || n.oRequestAnimationFrame || n.msRequestAnimationFrame || s, n.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || o);
		o = cc.$(t) || cc.$("#" + t);
		"CANVAS" == o.tagName ? (e = e || o.width, i = i || o.height, s = cc.container = cc.newElement("DIV"), t = cc._canvas = o, t.parentNode.insertBefore(s, t), t.appendTo(s), s.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" != o.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), e = e || o.clientWidth, i = i || o.clientHeight, s = cc.container = o, t = cc._canvas = cc.$(cc.newElement("CANVAS")), o.appendChild(t));
		t.addClass("gameCanvas");
		t.setAttribute("width", e || 480);
		t.setAttribute("height", i || 320);
		t.setAttribute("tabindex", 99);
		t.style.outline = "none";
		o = s.style;
		o.width = (e || 480) + "px";
		o.height = (i || 320) + "px";
		o.margin = "0 auto";
		o.position = "relative";
		o.overflow = "hidden";
		s.top = "100%";
		cc._renderType == cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(t, {
			stencil: !0,
			preserveDrawingBuffer: !0,
			antialias: !cc.sys.isMobile,
			alpha: !1
		}));
		cc._renderContext ? (n.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = t.getContext("2d"), cc._mainRenderContextBackup = cc._renderContext, cc._renderContext.translate(0, t.height), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null);
		cc._gameDiv = s;
		cc.log(cc.ENGINE_VERSION);
		cc._setContextMenuEnable(!1);
		cc.sys.isMobile && (e = cc.newElement("style"), e.type = "text/css", document.body.appendChild(e), e.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
		cc.view = cc.EGLView._getInstance();
		cc.inputManager.registerSystemEvent(cc._canvas);
		cc.director = cc.Director._getInstance();
		cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
		cc.winSize = cc.director.getWinSize();
		cc.saxParser = new cc.SAXParser;
		cc.plistParser = new cc.PlistParser
	}
};
cc._checkWebGLRenderMode = function() {
	if (cc._renderType !== cc._RENDER_TYPE_WEBGL) throw "This feature supports WebGL render mode only."
};
cc._isContextMenuEnable = !1;
cc._setContextMenuEnable = function(t) {
	cc._isContextMenuEnable = t;
	cc._canvas.oncontextmenu = function() {
		if (!cc._isContextMenuEnable) return !1
	}
};
cc.game = {
	DEBUG_MODE_NONE: 0,
	DEBUG_MODE_INFO: 1,
	DEBUG_MODE_WARN: 2,
	DEBUG_MODE_ERROR: 3,
	DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
	DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
	DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
	EVENT_HIDE: "game_on_hide",
	EVENT_SHOW: "game_on_show",
	_eventHide: null,
	_eventShow: null,
	_onBeforeStartArr: [],
	CONFIG_KEY: {
		engineDir: "engineDir",
		dependencies: "dependencies",
		debugMode: "debugMode",
		showFPS: "showFPS",
		frameRate: "frameRate",
		id: "id",
		renderMode: "renderMode",
		jsList: "jsList",
		classReleaseMode: "classReleaseMode"
	},
	_prepareCalled: !1,
	_prepared: !1,
	_paused: !0,
	_intervalId: null,
	config: null,
	onStart: null,
	onStop: null,
	setFrameRate: function(t) {
		this.config[this.CONFIG_KEY.frameRate] = t;
		this._intervalId && window.cancelAnimationFrame(this._intervalId);
		this._paused = !0;
		this._runMainLoop()
	},
	_runMainLoop: function() {
		var t = this,
			e, i = cc.director;
		i.setDisplayStats(t.config[t.CONFIG_KEY.showFPS]);
		e = function() {
			t._paused || (i.mainLoop(), t._intervalId && window.cancelAnimationFrame(t._intervalId), t._intervalId = window.requestAnimFrame(e))
		};
		window.requestAnimFrame(e);
		t._paused = !1
	},
	restart: function() {
		cc.director.popToSceneStackLevel(0);
		cc.audioEngine && cc.audioEngine.end();
		cc.game.onStart()
	},
	run: function(t) {
		var e = this,
			i = function() {
				t && (e.config[e.CONFIG_KEY.id] = t);
				e._prepareCalled || e.prepare(function() {
					e._prepared = !0
				});
				cc._supportRender && (e._checkPrepare = setInterval(function() {
					e._prepared && (cc._setup(e.config[e.CONFIG_KEY.id]), e._runMainLoop(), e._eventHide = e._eventHide || new cc.EventCustom(e.EVENT_HIDE), e._eventHide.setUserData(e), e._eventShow = e._eventShow || new cc.EventCustom(e.EVENT_SHOW), e._eventShow.setUserData(e), e.onStart(), clearInterval(e._checkPrepare))
				}, 10))
			};
		document.body ? i() : cc._addEventListener(window, "load", function() {
			this.removeEventListener("load", arguments.callee, !1);
			i()
		}, !1)
	},
	_initConfig: function() {
		var t = this.CONFIG_KEY,
			e = function(e) {
				e[t.engineDir] = e[t.engineDir] || "frameworks/cocos2d-html5";
				null == e[t.debugMode] && (e[t.debugMode] = 0);
				e[t.frameRate] = e[t.frameRate] || 60;
				null == e[t.renderMode] && (e[t.renderMode] = 1);
				return e
			};
		if (document.ccConfig) this.config = e(document.ccConfig);
		else try {
			for (var i = document.getElementsByTagName("script"), n = 0; n < i.length; n++) {
				var r = i[n].getAttribute("cocos");
				if ("" == r || r) break
			}
			var c, s, o;
			if (n < i.length) {
				if (c = i[n].src) o = /(.*)\//.exec(c)[0], cc.loader.resPath = o, c = cc.path.join(o, "js/project.json");
				s = cc.loader._loadTxtSync(c)
			}
			s || (s = cc.loader._loadTxtSync("js/project.json"));
			var a = JSON.parse(s);
			this.config = e(a || {})
		} catch (h) {
			cc.log("Failed to read or parse project.json"), this.config = e({})
		}
		cc._initSys(this.config, t)
	},
	_jsAddedCache: {},
	_getJsListOfModule: function(t, e, i) {
		var n = this._jsAddedCache;
		if (n[e]) return null;
		i = i || "";
		var r = [],
			c = t[e];
		if (!c) throw "can not find module [" + e + "]";
		e = cc.path;
		for (var s = 0, o = c.length; s < o; s++) {
			var a = c[s];
			if (!n[a]) {
				var h = e.extname(a);
				h ? ".js" == h.toLowerCase() && r.push(e.join(i, a)) : (h = this._getJsListOfModule(t, a, i)) && (r = r.concat(h));
				n[a] = 1
			}
		}
		return r
	},
	prepare: function(t) {
		var e = this,
			i = e.config,
			n = e.CONFIG_KEY,
			r = i[n.engineDir],
			c = cc.loader;
		if (!cc._supportRender) throw "The renderer doesn't support the renderMode " + i[n.renderMode];
		e._prepareCalled = !0;
		var s = i[n.jsList] || [];
		cc.Class ? c.loadJsWithImg("", s, function(i) {
			if (i) throw i;
			e._prepared = !0;
			t && t()
		}) : (n = cc.path.join(r, "moduleConfig.json"), c.loadJson(n, function(n, c) {
			if (n) throw n;
			var o = i.modules || [],
				a = c.module,
				h = [];
			cc._renderType == cc._RENDER_TYPE_WEBGL ? o.splice(0, 0, "shaders") : 0 > o.indexOf("core") && o.splice(0, 0, "core");
			for (var l = 0, u = o.length; l < u; l++) {
				var d = e._getJsListOfModule(a, o[l], r);
				d && (h = h.concat(d))
			}
			h = h.concat(s);
			cc.loader.loadJsWithImg(h, function(i) {
				if (i) throw i;
				e._prepared = !0;
				t && t()
			})
		}))
	}
};
cc.game._initConfig();
Function.prototype.bind = Function.prototype.bind ||
function(t) {
	if (!cc.isFunction(this)) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	var e = Array.prototype.slice.call(arguments, 1),
		i = this,
		n = function() {},
		r = function() {
			return i.apply(this instanceof n && t ? this : t, e.concat(Array.prototype.slice.call(arguments)))
		};
	n.prototype = this.prototype;
	r.prototype = new n;
	return r
};
cc._LogInfos = {
	ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
	ActionManager_removeAction: "cocos2d: removeAction: Target not found",
	ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
	ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
	ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
	ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag = %s): Action not found",
	configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
	configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
	configuration_loadConfigFile_2: "Please load the resource first : %s",
	Director_resume: "cocos2d: Director: Error in gettimeofday",
	Director_setProjection: "cocos2d: Director: unrecognized projection",
	Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
	Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
	Director_popScene: "running scene should not null",
	Director_pushScene: "the scene should not null",
	arrayVerifyType: "element type is wrong!",
	Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
	Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
	Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
	Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
	Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
	Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
	Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
	Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
	Node_getRotation: "RotationX != RotationY. Don't know which one to return",
	Node_getScale: "ScaleX != ScaleY. Don't know which one to return",
	Node_addChild: "An Node can't be added as a child of itself.",
	Node_addChild_2: "child already added. It can't be added again",
	Node_addChild_3: "child must be non-null",
	Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
	Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
	Node_removeChildByTag: "argument tag is an invalid tag",
	Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag = %s): child not found!",
	Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
	Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
	Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
	Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
	Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
	Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
	Node_reorderChild: "child must be non-null",
	Node_runAction: "cc.Node.runAction(): action must be non-null",
	Node_schedule: "callback function must be non-null",
	Node_schedule_2: "interval must be positive",
	Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
	AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
	AtlasNode_initWithTileFile: "",
	AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
	_EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
	_EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
	_EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
	_EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
	EventListener_create: "Invalid parameter.",
	__getListenerID: "Don't call this method if the event is for touch.",
	eventManager__forceAddEventListener: "Invalid scene graph priority!",
	eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
	eventManager_removeListeners: "Invalid listener type!",
	eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
	eventManager_addListener_2: "Invalid parameters.",
	eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
	eventManager_addListener_4: "The listener has been registered, please don't register it again.",
	LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
	LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
	LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
	LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
	EGLView_setDesignResolutionSize: "Resolution not valid",
	EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
	inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
	swap: "cc.swap is being modified from original macro, please check usage",
	checkGLErrorDebug: "WebGL error %s",
	animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
	animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
	animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
	animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
	animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
	animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
	animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
	animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
	animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
	animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
	Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
	Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
	Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
	Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
	Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
	Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
	Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
	Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
	Sprite_initWithSpriteFrameName1: " is null, please check.",
	Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
	Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
	Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
	Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
	Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
	Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
	Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
	Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
	Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
	Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
	Sprite_setSpriteFrame: "Invalid spriteFrameName",
	Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
	Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
	Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
	SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
	SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
	SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
	SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
	SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
	SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
	SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
	spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
	spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
	spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
	spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
	spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
	spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
	spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
	CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
	CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
	CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
	CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
	CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
	CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
	CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
	CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
	TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
	TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
	TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
	TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
	TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
	TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
	TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
	TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
	TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
	TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
	TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
	TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
	TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
	TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
	textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
	textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
	textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
	textureCache_addPVRImage: "addPVRImage does not support on HTML5",
	textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
	textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id=%s %s x %s",
	textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
	textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
	textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
	Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
	Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
	Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
	Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
	Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
	Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
	Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
	Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
	Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
	Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
	Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
	Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
	Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
	Texture2D_initWithData: "NSInternalInconsistencyException",
	MissingFile: "Missing file: %s",
	radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
	RectWidth: "Rect width exceeds maximum margin: %s",
	RectHeight: "Rect height exceeds maximum margin: %s",
	EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
	EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function(t) {
	if (cc._canvas) {
		var e = cc._logList,
			i = document;
		if (!e) {
			var n = i.createElement("Div"),
				e = n.style;
			n.setAttribute("id", "logInfoDiv");
			cc._canvas.parentNode.appendChild(n);
			n.setAttribute("width", "200");
			n.setAttribute("height", cc._canvas.height);
			e.zIndex = "99999";
			e.position = "absolute";
			e.top = "0";
			e.left = "0";
			e = cc._logList = i.createElement("textarea");
			i = e.style;
			e.setAttribute("rows", "20");
			e.setAttribute("cols", "30");
			e.setAttribute("disabled", !0);
			n.appendChild(e);
			i.backgroundColor = "transparent";
			i.borderBottom = "1px solid #cccccc";
			i.borderRightWidth = "0px";
			i.borderLeftWidth = "0px";
			i.borderTopWidth = "0px";
			i.borderTopStyle = "none";
			i.borderRightStyle = "none";
			i.borderLeftStyle = "none";
			i.padding = "0px";
			i.margin = 0
		}
		e.value = e.value + t + "\r\n";
		e.scrollTop = e.scrollHeight
	}
};
cc._formatString = function(t) {
	if (cc.isObject(t)) try {
		return JSON.stringify(t)
	} catch (e) {
		return ""
	} else return t
};
cc._initDebugSetting = function(t) {
	var e = cc.game;
	if (t != e.DEBUG_MODE_NONE) {
		var i;
		t > e.DEBUG_MODE_ERROR ? (i = cc._logToWebPage.bind(cc), cc.error = function() {
			i("ERROR :  " + cc.formatStr.apply(cc, arguments))
		}, cc.assert = function(t, e) {
			if (!t && e) {
				for (var n = 2; n < arguments.length; n++) e = e.replace(/(%s)|(%d)/, cc._formatString(arguments[n]));
				i("Assert: " + e)
			}
		}, t != e.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
			i("WARN :  " + cc.formatStr.apply(cc, arguments))
		}), t == e.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
			i(cc.formatStr.apply(cc, arguments))
		})) : console && console.log.apply && (cc.error = function() {
			return console.error.apply(console, arguments)
		}, cc.assert = function(t, e) {
			if (!t && e) {
				for (var i = 2; i < arguments.length; i++) e = e.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
				throw e
			}
		}, t != e.DEBUG_MODE_ERROR && (cc.warn = function() {
			return console.warn.apply(console, arguments)
		}), t == e.DEBUG_MODE_INFO && (cc.log = function() {
			return console.log.apply(console, arguments)
		}))
	}
};
cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]);
cc.loader.loadBinary = function(t, e) {
	var i = this,
		n = this.getXMLHttpRequest(),
		r = "load " + t + " failed!";
	n.open("GET", t, !0);
	/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (n.setRequestHeader("Accept-Charset", "x-user-defined"), n.onreadystatechange = function() {
		if (4 == n.readyState && 200 == n.status) {
			var t = cc._convertResponseBodyToText(n.responseBody);
			e(null, i._str2Uint8Array(t))
		} else e(r)
	}) : (n.overrideMimeType && n.overrideMimeType("text/plain; charset=x-user-defined"), n.onload = function() {
		4 == n.readyState && 200 == n.status ? e(null, i._str2Uint8Array(n.responseText)) : e(r)
	});
	n.send(null)
};
cc.loader._str2Uint8Array = function(t) {
	if (!t) return null;
	for (var e = new Uint8Array(t.length), i = 0; i < t.length; i++) e[i] = t.charCodeAt(i) & 255;
	return e
};
cc.loader.loadBinarySync = function(t) {
	var e = this.getXMLHttpRequest(),
		i = "load " + t + " failed!";
	e.open("GET", t, !1);
	t = null;
	if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
		e.setRequestHeader("Accept-Charset", "x-user-defined");
		e.send(null);
		if (200 != e.status) return cc.log(i), null;
		(e = cc._convertResponseBodyToText(e.responseBody)) && (t = this._str2Uint8Array(e))
	} else {
		e.overrideMimeType && e.overrideMimeType("text/plain; charset=x-user-defined");
		e.send(null);
		if (200 != e.status) return cc.log(i), null;
		t = this._str2Uint8Array(e.responseText)
	}
	return t
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
	var IEBinaryToArray_ByteStr_Script = '<!-- IEBinaryToArray_ByteStr -->\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr = CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex = LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last = ""\r\n   End If\r\nEnd Function\r\n',
		myVBScript = cc.newElement("script");
	myVBScript.type = "text/vbscript";
	myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
	document.body.appendChild(myVBScript);
	cc._convertResponseBodyToText = function(t) {
		for (var e = {}, i = 0; 256 > i; i++) for (var n = 0; 256 > n; n++) e[String.fromCharCode(i + 256 * n)] = String.fromCharCode(i) + String.fromCharCode(n);
		i = IEBinaryToArray_ByteStr(t);
		t = IEBinaryToArray_ByteStr_Last(t);
		return i.replace(/[\s\S]/g, function(t) {
			return e[t]
		}) + t
	}
}
cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII=";
cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k=";
var cc = cc || {},
	ClassManager = {
		id: 0 | 998 * Math.random(),
		instanceId: 0 | 998 * Math.random(),
		compileSuper: function(t, e, i) {
			t = t.toString();
			var n = t.indexOf("("),
				r = t.indexOf(")"),
				n = t.substring(n + 1, r),
				n = n.trim(),
				r = t.indexOf("{"),
				c = t.lastIndexOf("}");
			for (t = t.substring(r + 1, c); - 1 != t.indexOf("this._super");) {
				var r = t.indexOf("this._super"),
					c = t.indexOf("(", r),
					s = t.indexOf(")", c),
					s = t.substring(c + 1, s),
					s = (s = s.trim()) ? "," : "";
				t = t.substring(0, r) + "ClassManager[" + i + "]." + e + ".call(this" + s + t.substring(c + 1)
			}
			return Function(n, t)
		},
		getNewID: function() {
			return this.id++
		},
		getNewInstanceId: function() {
			return this.instanceId++
		}
	};
ClassManager.compileSuper.ClassManager = ClassManager;
(function() {
	var t = /\b_super\b/,
		e = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
	e && console.log("release Mode");
	cc.Class = function() {};
	cc.Class.extend = function(i) {
		function n() {
			this.__instanceId = ClassManager.getNewInstanceId();
			this.ctor && this.ctor.apply(this, arguments)
		}
		var r = this.prototype,
			c = Object.create(r),
			s = ClassManager.getNewID();
		ClassManager[s] = r;
		var o = {
			writable: !0,
			enumerable: !1,
			configurable: !0
		};
		c.__instanceId = null;
		n.id = s;
		o.value = s;
		Object.defineProperty(c, "__pid", o);
		n.prototype = c;
		o.value = n;
		Object.defineProperty(n.prototype, "constructor", o);
		this.__getters__ && (n.__getters__ = cc.clone(this.__getters__));
		this.__setters__ && (n.__setters__ = cc.clone(this.__setters__));
		for (var a = 0, h = arguments.length; a < h; ++a) {
			var l = arguments[a],
				u;
			for (u in l) {
				var d = "function" === typeof l[u],
					_ = "function" === typeof r[u],
					f = t.test(l[u]);
				e && d && _ && f ? (o.value = ClassManager.compileSuper(l[u], u, s), Object.defineProperty(c, u, o)) : d && _ && f ? (o.value = function(t, e) {
					return function() {
						var i = this._super;
						this._super = r[t];
						var n = e.apply(this, arguments);
						this._super = i;
						return n
					}
				}(u, l[u]), Object.defineProperty(c, u, o)) : d ? (o.value = l[u], Object.defineProperty(c, u, o)) : c[u] = l[u];
				if (d) {
					var p, g;
					if (this.__getters__ && this.__getters__[u]) {
						var d = this.__getters__[u],
							m;
						for (m in this.__setters__) if (this.__setters__[m] == d) {
							g = m;
							break
						}
						cc.defineGetterSetter(c, d, l[u], l[g] ? l[g] : c[g], u, g)
					}
					if (this.__setters__ && this.__setters__[u]) {
						d = this.__setters__[u];
						for (m in this.__getters__) if (this.__getters__[m] == d) {
							p = m;
							break
						}
						cc.defineGetterSetter(c, d, l[p] ? l[p] : c[p], l[u], p, u)
					}
				}
			}
		}
		n.extend = cc.Class.extend;
		n.implement = function(t) {
			for (var e in t) c[e] = t[e]
		};
		return n
	}
})();
cc.defineGetterSetter = function(t, e, i, n, r, c) {
	if (t.__defineGetter__) i && t.__defineGetter__(e, i), n && t.__defineSetter__(e, n);
	else if (Object.defineProperty) {
		var s = {
			enumerable: !1,
			configurable: !0
		};
		i && (s.get = i);
		n && (s.set = n);
		Object.defineProperty(t, e, s)
	} else throw Error("browser does not support getters");
	if (!r && !c) for (var s = null != i, o = void 0 != n, a = Object.getOwnPropertyNames(t), h = 0; h < a.length; h++) {
		var l = a[h];
		if (!((t.__lookupGetter__ ? t.__lookupGetter__(l) : Object.getOwnPropertyDescriptor(t, l)) || "function" !== typeof t[l])) {
			var u = t[l];
			if (s && u === i && (r = l, !o || c)) break;
			if (o && u === n && (c = l, !s || r)) break
		}
	}
	t = t.constructor;
	r && (t.__getters__ || (t.__getters__ = {}), t.__getters__[r] = e);
	c && (t.__setters__ || (t.__setters__ = {}), t.__setters__[c] = e)
};
cc.clone = function(t) {
	var e = t.constructor ? new t.constructor : {},
		i;
	for (i in t) {
		var n = t[i];
		e[i] = "object" == typeof n && n && !(n instanceof cc.Node) && !(n instanceof HTMLElement) ? cc.clone(n) : n
	}
	return e
};
cc.inject = function(t, e) {
	for (var i in t) e[i] = t[i]
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function(t, e) {};
cc.KEY = {
	backspace: 8,
	tab: 9,
	enter: 13,
	shift: 16,
	ctrl: 17,
	alt: 18,
	pause: 19,
	capslock: 20,
	escape: 27,
	pageup: 33,
	pagedown: 34,
	end: 35,
	home: 36,
	left: 37,
	up: 38,
	right: 39,
	down: 40,
	insert: 45,
	Delete: 46,
	0: 48,
	1: 49,
	2: 50,
	3: 51,
	4: 52,
	5: 53,
	6: 54,
	7: 55,
	8: 56,
	9: 57,
	a: 65,
	b: 66,
	c: 67,
	d: 68,
	e: 69,
	f: 70,
	g: 71,
	h: 72,
	i: 73,
	j: 74,
	k: 75,
	l: 76,
	m: 77,
	n: 78,
	o: 79,
	p: 80,
	q: 81,
	r: 82,
	s: 83,
	t: 84,
	u: 85,
	v: 86,
	w: 87,
	x: 88,
	y: 89,
	z: 90,
	num0: 96,
	num1: 97,
	num2: 98,
	num3: 99,
	num4: 100,
	num5: 101,
	num6: 102,
	num7: 103,
	num8: 104,
	num9: 105,
	"*": 106,
	"+": 107,
	"-": 109,
	numdel: 110,
	"/": 111,
	f1: 112,
	f2: 113,
	f3: 114,
	f4: 115,
	f5: 116,
	f6: 117,
	f7: 118,
	f8: 119,
	f9: 120,
	f10: 121,
	f11: 122,
	f12: 123,
	numlock: 144,
	scrolllock: 145,
	semicolon: 186,
	",": 186,
	equal: 187,
	"=": 187,
	";": 188,
	comma: 188,
	dash: 189,
	".": 190,
	period: 190,
	forwardslash: 191,
	grave: 192,
	"[": 219,
	openbracket: 219,
	"]": 221,
	closebracket: 221,
	backslash: 220,
	quote: 222,
	space: 32
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function(t) {
	return 8 < t.length && 137 == t[0] && 80 == t[1] && 78 == t[2] && 71 == t[3] && 13 == t[4] && 10 == t[5] && 26 == t[6] && 10 == t[7] ? cc.FMT_PNG : 2 < t.length && (73 == t[0] && 73 == t[1] || 77 == t[0] && 77 == t[1] || 255 == t[0] && 216 == t[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.inherits = function(t, e) {
	function i() {}
	i.prototype = e.prototype;
	t.superClass_ = e.prototype;
	t.prototype = new i;
	t.prototype.constructor = t
};
cc.base = function(t, e, i) {
	var n = arguments.callee.caller;
	if (n.superClass_) return ret = n.superClass_.constructor.apply(t, Array.prototype.slice.call(arguments, 1));
	for (var r = Array.prototype.slice.call(arguments, 2), c = !1, s = t.constructor; s; s = s.superClass_ && s.superClass_.constructor) if (s.prototype[e] === n) c = !0;
	else if (c) return s.prototype[e].apply(t, r);
	if (t[e] === n) return t.constructor.prototype[e].apply(t, r);
	throw Error("cc.base called from a method of one name to a method of a different name")
};
cc.Point = function(t, e) {
	this.x = t || 0;
	this.y = e || 0
};
cc.p = function(t, e) {
	return void 0 == t ? {
		x: 0,
		y: 0
	} : void 0 == e ? {
		x: t.x,
		y: t.y
	} : {
		x: t,
		y: e
	}
};
cc.pointEqualToPoint = function(t, e) {
	return t && e && t.x === e.x && t.y === e.y
};
cc.Size = function(t, e) {
	this.width = t || 0;
	this.height = e || 0
};
cc.size = function(t, e) {
	return void 0 === t ? {
		width: 0,
		height: 0
	} : void 0 === e ? {
		width: t.width,
		height: t.height
	} : {
		width: t,
		height: e
	}
};
cc.sizeEqualToSize = function(t, e) {
	return t && e && t.width == e.width && t.height == e.height
};
cc.Rect = function(t, e, i, n) {
	this.x = t || 0;
	this.y = e || 0;
	this.width = i || 0;
	this.height = n || 0
};
cc.rect = function(t, e, i, n) {
	return void 0 === t ? {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	} : void 0 === e ? {
		x: t.x,
		y: t.y,
		width: t.width,
		height: t.height
	} : {
		x: t,
		y: e,
		width: i,
		height: n
	}
};
cc.rectEqualToRect = function(t, e) {
	return t && e && t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
};
cc._rectEqualToZero = function(t) {
	return t && 0 === t.x && 0 === t.y && 0 === t.width && 0 === t.height
};
cc.rectContainsRect = function(t, e) {
	return !t || !e ? !1 : !(t.x >= e.x || t.y >= e.y || t.x + t.width <= e.x + e.width || t.y + t.height <= e.y + e.height)
};
cc.rectGetMaxX = function(t) {
	return t.x + t.width
};
cc.rectGetMidX = function(t) {
	return t.x + t.width / 2
};
cc.rectGetMinX = function(t) {
	return t.x
};
cc.rectGetMaxY = function(t) {
	return t.y + t.height
};
cc.rectGetMidY = function(t) {
	return t.y + t.height / 2
};
cc.rectGetMinY = function(t) {
	return t.y
};
cc.rectContainsPoint = function(t, e) {
	return e.x >= cc.rectGetMinX(t) && e.x <= cc.rectGetMaxX(t) && e.y >= cc.rectGetMinY(t) && e.y <= cc.rectGetMaxY(t)
};
cc.rectIntersectsRect = function(t, e) {
	var i = t.y + t.height,
		n = e.x + e.width,
		r = e.y + e.height;
	return !(t.x + t.width < e.x || n < t.x || i < e.y || r < t.y)
};
cc.rectOverlapsRect = function(t, e) {
	return !(t.x + t.width < e.x || e.x + e.width < t.x || t.y + t.height < e.y || e.y + e.height < t.y)
};
cc.rectUnion = function(t, e) {
	var i = cc.rect(0, 0, 0, 0);
	i.x = Math.min(t.x, e.x);
	i.y = Math.min(t.y, e.y);
	i.width = Math.max(t.x + t.width, e.x + e.width) - i.x;
	i.height = Math.max(t.y + t.height, e.y + e.height) - i.y;
	return i
};
cc.rectIntersection = function(t, e) {
	var i = cc.rect(Math.max(cc.rectGetMinX(t), cc.rectGetMinX(e)), Math.max(cc.rectGetMinY(t), cc.rectGetMinY(e)), 0, 0);
	i.width = Math.min(cc.rectGetMaxX(t), cc.rectGetMaxX(e)) - cc.rectGetMinX(i);
	i.height = Math.min(cc.rectGetMaxY(t), cc.rectGetMaxY(e)) - cc.rectGetMinY(i);
	return i
};
cc.SAXParser = cc.Class.extend({
	_parser: null,
	_isSupportDOMParser: null,
	ctor: function() {
		window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
	},
	parse: function(t) {
		return this._parseXML(t)
	},
	_parseXML: function(t) {
		var e;
		this._isSupportDOMParser ? e = this._parser.parseFromString(t, "text/xml") : (e = new ActiveXObject("Microsoft.XMLDOM"), e.async = "false", e.loadXML(t));
		return e
	}
});
cc.PlistParser = cc.SAXParser.extend({
	parse: function(t) {
		t = this._parseXML(t).documentElement;
		if ("plist" != t.tagName) throw "Not a plist file!";
		for (var e = null, i = 0, n = t.childNodes.length; i < n && !(e = t.childNodes[i], 1 == e.nodeType); i++);
		return this._parseNode(e)
	},
	_parseNode: function(t) {
		var e = null,
			i = t.tagName;
		if ("dict" == i) e = this._parseDict(t);
		else if ("array" == i) e = this._parseArray(t);
		else if ("string" == i) if (1 == t.childNodes.length) e = t.firstChild.nodeValue;
		else {
			e = "";
			for (i = 0; i < t.childNodes.length; i++) e += t.childNodes[i].nodeValue
		} else "false" == i ? e = !1 : "true" == i ? e = !0 : "real" == i ? e = parseFloat(t.firstChild.nodeValue) : "integer" == i && (e = parseInt(t.firstChild.nodeValue, 10));
		return e
	},
	_parseArray: function(t) {
		for (var e = [], i = 0, n = t.childNodes.length; i < n; i++) {
			var r = t.childNodes[i];
			1 == r.nodeType && e.push(this._parseNode(r))
		}
		return e
	},
	_parseDict: function(t) {
		for (var e = {}, i = null, n = 0, r = t.childNodes.length; n < r; n++) {
			var c = t.childNodes[n];
			1 == c.nodeType && ("key" == c.tagName ? i = c.firstChild.nodeValue : e[i] = this._parseNode(c))
		}
		return e
	}
});
cc._txtLoader = {
	load: function(t, e, i, n) {
		cc.loader.loadTxt(t, n)
	}
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
	load: function(t, e, i, n) {
		cc.loader.loadJson(t, n)
	}
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._imgLoader = {
	load: function(t, e, i, n) {
		cc.loader.cache[e] = cc.loader.loadImg(t, function(t, i) {
			if (t) return n(t);
			cc.textureCache.handleLoadedTexture(e);
			n(null, i)
		})
	}
};
cc.loader.register("png jpg bmp jpeg gif ico".split(" "), cc._imgLoader);
cc._serverImgLoader = {
	load: function(t, e, i, n) {
		cc.loader.cache[e] = cc.loader.loadImg(i.src, function(t, i) {
			if (t) return n(t);
			cc.textureCache.handleLoadedTexture(e);
			n(null, i)
		})
	}
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
	load: function(t, e, i, n) {
		cc.loader.loadTxt(t, function(t, e) {
			if (t) return n(t);
			n(null, cc.plistParser.parse(e))
		})
	}
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
	TYPE: {
		".eot": "embedded-opentype",
		".ttf": "truetype",
		".woff": "woff",
		".svg": "svg"
	},
	_loadFont: function(t, e, i) {
		var n = document,
			r = cc.path,
			c = this.TYPE,
			s = cc.newElement("style");
		s.type = "text/css";
		n.body.appendChild(s);
		var o = "@font-face { font-family:" + t + "; src:";
		if (e instanceof Array) for (var a = 0, h = e.length; a < h; a++) i = r.extname(e[a]).toLowerCase(), o += "url('" + e[a] + "') format('" + c[i] + "')", o += a == h - 1 ? ";" : ",";
		else o += "url('" + e + "') format('" + c[i] + "');";
		s.textContent += o + "};";
		e = cc.newElement("div");
		i = e.style;
		i.fontFamily = t;
		e.innerHTML = ".";
		i.position = "absolute";
		i.left = "-100px";
		i.top = "-100px";
		n.body.appendChild(e)
	},
	load: function(t, e, i, n) {
		e = i.type;
		t = i.name;
		e = i.srcs;
		cc.isString(i) ? (e = cc.path.extname(i), t = cc.path.basename(i, e), this._loadFont(t, i, e)) : this._loadFont(t, e);
		n(null, !0)
	}
};
cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader);
cc._binaryLoader = {
	load: function(t, e, i, n) {
		cc.loader.loadBinary(t, n)
	}
};
cc._csbLoader = {
	load: function(t, e, i, n) {
		cc.loader.loadCsb(t, n)
	}
};
cc.loader.register(["csb"], cc._csbLoader);
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.2 RC0";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = .5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function(t) {
	var e = this == cc ? document : this;
	if (t = t instanceof HTMLElement ? t : e.querySelector(t)) t.find = t.find || cc.$, t.hasClass = t.hasClass ||
	function(t) {
		return this.className.match(RegExp("(\\s|^)" + t + "(\\s|$)"))
	}, t.addClass = t.addClass ||
	function(t) {
		this.hasClass(t) || (this.className && (this.className += " "), this.className += t);
		return this
	}, t.removeClass = t.removeClass ||
	function(t) {
		this.hasClass(t) && (this.className = this.className.replace(t, ""));
		return this
	}, t.remove = t.remove ||
	function() {
		this.parentNode && this.parentNode.removeChild(this);
		return this
	}, t.appendTo = t.appendTo ||
	function(t) {
		t.appendChild(this);
		return this
	}, t.prependTo = t.prependTo ||
	function(t) {
		t.childNodes[0] ? t.insertBefore(this, t.childNodes[0]) : t.appendChild(this);
		return this
	}, t.transforms = t.transforms ||
	function() {
		this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
		return this
	}, t.position = t.position || {
		x: 0,
		y: 0
	}, t.rotation = t.rotation || 0, t.scale = t.scale || {
		x: 1,
		y: 1
	}, t.skew = t.skew || {
		x: 0,
		y: 0
	}, t.translates = function(t, e) {
		this.position.x = t;
		this.position.y = e;
		this.transforms();
		return this
	}, t.rotate = function(t) {
		this.rotation = t;
		this.transforms();
		return this
	}, t.resize = function(t, e) {
		this.scale.x = t;
		this.scale.y = e;
		this.transforms();
		return this
	}, t.setSkew = function(t, e) {
		this.skew.x = t;
		this.skew.y = e;
		this.transforms();
		return this
	};
	return t
};
switch (cc.sys.browserType) {
case cc.sys.BROWSER_TYPE_FIREFOX:
	cc.$.pfx = "Moz";
	cc.$.hd = !0;
	break;
case cc.sys.BROWSER_TYPE_CHROME:
case cc.sys.BROWSER_TYPE_SAFARI:
	cc.$.pfx = "webkit";
	cc.$.hd = !0;
	break;
case cc.sys.BROWSER_TYPE_OPERA:
	cc.$.pfx = "O";
	cc.$.hd = !1;
	break;
case cc.sys.BROWSER_TYPE_IE:
	cc.$.pfx = "ms";
	cc.$.hd = !1;
	break;
default:
	cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ?
function(t) {
	return "translate3d(" + t.x + "px, " + t.y + "px, 0) "
} : function(t) {
	return "translate(" + t.x + "px, " + t.y + "px) "
};
cc.$.rotate = cc.$.hd ?
function(t) {
	return "rotateZ(" + t + "deg) "
} : function(t) {
	return "rotate(" + t + "deg) "
};
cc.$.scale = function(t) {
	return "scale(" + t.x + ", " + t.y + ") "
};
cc.$.skew = function(t) {
	return "skewX(" + -t.x + "deg) skewY(" + t.y + "deg)"
};
cc.$new = function(t) {
	return cc.$(document.createElement(t))
};
cc.$.findpos = function(t) {
	var e = 0,
		i = 0;
	do e += t.offsetLeft, i += t.offsetTop;
	while (t = t.offsetParent);
	return {
		x: e,
		y: i
	}
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function(t, e, i) {
	if (cc.isObject(i) && !cc.isUndefined(i.x) && !cc.isUndefined(i.y)) {
		var n = i[t];
		i[t] = i[e];
		i[e] = n
	} else cc.log(cc._LogInfos.swap)
};
cc.lerp = function(t, e, i) {
	return t + (e - t) * i
};
cc.rand = function() {
	return 16777215 * Math.random()
};
cc.randomMinus1To1 = function() {
	return 2 * (Math.random() - .5)
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function(t) {
	return t * cc.RAD
};
cc.radiansToDegrees = function(t) {
	return t * cc.DEG
};
cc.radiansToDegress = function(t) {
	cc.log(cc._LogInfos.radiansToDegress);
	return t * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 770;
cc.BLEND_DST = 771;
cc.nodeDrawSetup = function(t) {
	t._shaderProgram && (t._shaderProgram.use(), t._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.enableDefaultGLStates = function() {};
cc.disableDefaultGLStates = function() {};
cc.incrementGLDraws = function(t) {
	cc.g_NumberOfDraws += t
};
cc.FLT_EPSILON = 1.192092896e-7;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ?
function() {
	return cc.director.getContentScaleFactor()
} : function() {
	return 1
};
cc.pointPointsToPixels = function(t) {
	var e = cc.contentScaleFactor();
	return cc.p(t.x * e, t.y * e)
};
cc.pointPixelsToPoints = function(t) {
	var e = cc.contentScaleFactor();
	return cc.p(t.x / e, t.y / e)
};
cc._pointPixelsToPointsOut = function(t, e) {
	var i = cc.contentScaleFactor();
	e.x = t.x / i;
	e.y = t.y / i
};
cc.sizePointsToPixels = function(t) {
	var e = cc.contentScaleFactor();
	return cc.size(t.width * e, t.height * e)
};
cc.sizePixelsToPoints = function(t) {
	var e = cc.contentScaleFactor();
	return cc.size(t.width / e, t.height / e)
};
cc._sizePixelsToPointsOut = function(t, e) {
	var i = cc.contentScaleFactor();
	e.width = t.width / i;
	e.height = t.height / i
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ?
function(t) {
	var e = cc.contentScaleFactor();
	return cc.rect(t.x / e, t.y / e, t.width / e, t.height / e)
} : function(t) {
	return t
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ?
function(t) {
	var e = cc.contentScaleFactor();
	return cc.rect(t.x * e, t.y * e, t.width * e, t.height * e)
} : function(t) {
	return t
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.LINEAR = 9729;
cc.REPEAT = 10497;
cc.CLAMP_TO_EDGE = 33071;
cc.MIRRORED_REPEAT = 33648;
cc.checkGLErrorDebug = function() {
	if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
		var t = cc._renderContext.getError();
		t && cc.log(cc._LogInfos.checkGLErrorDebug, t)
	}
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function(t, e) {
	if (t && 0 < t.length) for (var i = 0; i < t.length; i++) if (!(t[i] instanceof e)) return cc.log("element type is wrong!"), !1;
	return !0
};
cc.arrayRemoveObject = function(t, e) {
	for (var i = 0, n = t.length; i < n; i++) if (t[i] == e) {
		t.splice(i, 1);
		break
	}
};
cc.arrayRemoveArray = function(t, e) {
	for (var i = 0, n = e.length; i < n; i++) cc.arrayRemoveObject(t, e[i])
};
cc.arrayAppendObjectsToIndex = function(t, e, i) {
	t.splice.apply(t, [i, 0].concat(e));
	return t
};
cc.copyArray = function(t) {
	var e, i = t.length,
		n = Array(i);
	for (e = 0; e < i; e += 1) n[e] = t[e];
	return n
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc._tmp.WebGLColor = function() {
	cc.color = function(t, e, i, n, r, c) {
		return void 0 === t ? new cc.Color(0, 0, 0, 255, r, c) : cc.isString(t) ? (t = cc.hexToColor(t), new cc.Color(t.r, t.g, t.b, t.a)) : cc.isObject(t) ? new cc.Color(t.r, t.g, t.b, t.a, t.arrayBuffer, t.offset) : new cc.Color(t, e, i, n, r, c)
	};
	cc.Color = function(t, e, i, n, r, c) {
		this._arrayBuffer = r || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
		this._offset = c || 0;
		r = this._arrayBuffer;
		c = this._offset;
		var s = Uint8Array.BYTES_PER_ELEMENT;
		this._rU8 = new Uint8Array(r, c, 1);
		this._gU8 = new Uint8Array(r, c + s, 1);
		this._bU8 = new Uint8Array(r, c + 2 * s, 1);
		this._aU8 = new Uint8Array(r, c + 3 * s, 1);
		this._rU8[0] = t || 0;
		this._gU8[0] = e || 0;
		this._bU8[0] = i || 0;
		this._aU8[0] = null == n ? 255 : n;
		void 0 === n && (this.a_undefined = !0)
	};
	cc.Color.BYTES_PER_ELEMENT = 4;
	var t = cc.Color.prototype;
	t._getR = function() {
		return this._rU8[0]
	};
	t._setR = function(t) {
		this._rU8[0] = 0 > t ? 0 : t
	};
	t._getG = function() {
		return this._gU8[0]
	};
	t._setG = function(t) {
		this._gU8[0] = 0 > t ? 0 : t
	};
	t._getB = function() {
		return this._bU8[0]
	};
	t._setB = function(t) {
		this._bU8[0] = 0 > t ? 0 : t
	};
	t._getA = function() {
		return this._aU8[0]
	};
	t._setA = function(t) {
		this._aU8[0] = 0 > t ? 0 : t
	};
	cc.defineGetterSetter(t, "r", t._getR, t._setR);
	cc.defineGetterSetter(t, "g", t._getG, t._setG);
	cc.defineGetterSetter(t, "b", t._getB, t._setB);
	cc.defineGetterSetter(t, "a", t._getA, t._setA);
	cc.Vertex2F = function(t, e, i, n) {
		this._arrayBuffer = i || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
		this._offset = n || 0;
		this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
		this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
		this._xF32[0] = t || 0;
		this._yF32[0] = e || 0
	};
	cc.Vertex2F.BYTES_PER_ELEMENT = 8;
	Object.defineProperties(cc.Vertex2F.prototype, {
		x: {
			get: function() {
				return this._xF32[0]
			},
			set: function(t) {
				this._xF32[0] = t
			},
			enumerable: !0
		},
		y: {
			get: function() {
				return this._yF32[0]
			},
			set: function(t) {
				this._yF32[0] = t
			},
			enumerable: !0
		}
	});
	cc.Vertex3F = function(t, e, i, n, r) {
		this._arrayBuffer = n || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
		this._offset = r || 0;
		n = this._arrayBuffer;
		r = this._offset;
		this._xF32 = new Float32Array(n, r, 1);
		this._xF32[0] = t || 0;
		this._yF32 = new Float32Array(n, r + Float32Array.BYTES_PER_ELEMENT, 1);
		this._yF32[0] = e || 0;
		this._zF32 = new Float32Array(n, r + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
		this._zF32[0] = i || 0
	};
	cc.Vertex3F.BYTES_PER_ELEMENT = 12;
	Object.defineProperties(cc.Vertex3F.prototype, {
		x: {
			get: function() {
				return this._xF32[0]
			},
			set: function(t) {
				this._xF32[0] = t
			},
			enumerable: !0
		},
		y: {
			get: function() {
				return this._yF32[0]
			},
			set: function(t) {
				this._yF32[0] = t
			},
			enumerable: !0
		},
		z: {
			get: function() {
				return this._zF32[0]
			},
			set: function(t) {
				this._zF32[0] = t
			},
			enumerable: !0
		}
	});
	cc.Tex2F = function(t, e, i, n) {
		this._arrayBuffer = i || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
		this._offset = n || 0;
		this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
		this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
		this._uF32[0] = t || 0;
		this._vF32[0] = e || 0
	};
	cc.Tex2F.BYTES_PER_ELEMENT = 8;
	Object.defineProperties(cc.Tex2F.prototype, {
		u: {
			get: function() {
				return this._uF32[0]
			},
			set: function(t) {
				this._uF32[0] = t
			},
			enumerable: !0
		},
		v: {
			get: function() {
				return this._vF32[0]
			},
			set: function(t) {
				this._vF32[0] = t
			},
			enumerable: !0
		}
	});
	cc.Quad2 = function(t, e, i, n, r, c) {
		this._arrayBuffer = r || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
		this._offset = c || 0;
		r = this._arrayBuffer;
		c = cc.Vertex2F.BYTES_PER_ELEMENT;
		this._tl = t ? new cc.Vertex2F(t.x, t.y, r, 0) : new cc.Vertex2F(0, 0, r, 0);
		this._tr = e ? new cc.Vertex2F(e.x, e.y, r, c) : new cc.Vertex2F(0, 0, r, c);
		this._bl = i ? new cc.Vertex2F(i.x, i.y, r, 2 * c) : new cc.Vertex2F(0, 0, r, 2 * c);
		this._br = n ? new cc.Vertex2F(n.x, n.y, r, 3 * c) : new cc.Vertex2F(0, 0, r, 3 * c)
	};
	cc.Quad2.BYTES_PER_ELEMENT = 32;
	cc.Quad3 = function(t, e, i, n) {
		this.bl = t || new cc.Vertex3F(0, 0, 0);
		this.br = e || new cc.Vertex3F(0, 0, 0);
		this.tl = i || new cc.Vertex3F(0, 0, 0);
		this.tr = n || new cc.Vertex3F(0, 0, 0)
	};
	Object.defineProperties(cc.Quad2.prototype, {
		tl: {
			get: function() {
				return this._tl
			},
			set: function(t) {
				this._tl.x = t.x;
				this._tl.y = t.y
			},
			enumerable: !0
		},
		tr: {
			get: function() {
				return this._tr
			},
			set: function(t) {
				this._tr.x = t.x;
				this._tr.y = t.y
			},
			enumerable: !0
		},
		bl: {
			get: function() {
				return this._bl
			},
			set: function(t) {
				this._bl.x = t.x;
				this._bl.y = t.y
			},
			enumerable: !0
		},
		br: {
			get: function() {
				return this._br
			},
			set: function(t) {
				this._br.x = t.x;
				this._br.y = t.y
			},
			enumerable: !0
		}
	});
	cc.V3F_C4B_T2F = function(t, e, i, n, r) {
		this._arrayBuffer = n || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
		this._offset = r || 0;
		n = this._arrayBuffer;
		r = this._offset;
		var c = cc.Vertex3F.BYTES_PER_ELEMENT;
		this._vertices = t ? new cc.Vertex3F(t.x, t.y, t.z, n, r) : new cc.Vertex3F(0, 0, 0, n, r);
		this._colors = e ? cc.color(e.r, e.g, e.b, e.a, n, r + c) : cc.color(0, 0, 0, 0, n, r + c);
		this._texCoords = i ? new cc.Tex2F(i.u, i.v, n, r + c + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, n, r + c + cc.Color.BYTES_PER_ELEMENT)
	};
	cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
	Object.defineProperties(cc.V3F_C4B_T2F.prototype, {
		vertices: {
			get: function() {
				return this._vertices
			},
			set: function(t) {
				var e = this._vertices;
				e.x = t.x;
				e.y = t.y;
				e.z = t.z
			},
			enumerable: !0
		},
		colors: {
			get: function() {
				return this._colors
			},
			set: function(t) {
				var e = this._colors;
				e.r = t.r;
				e.g = t.g;
				e.b = t.b;
				e.a = t.a
			},
			enumerable: !0
		},
		texCoords: {
			get: function() {
				return this._texCoords
			},
			set: function(t) {
				this._texCoords.u = t.u;
				this._texCoords.v = t.v
			},
			enumerable: !0
		}
	});
	cc.V3F_C4B_T2F_Quad = function(t, e, i, n, r, c) {
		this._arrayBuffer = r || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
		this._offset = c || 0;
		r = this._arrayBuffer;
		c = this._offset;
		var s = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
		this._tl = t ? new cc.V3F_C4B_T2F(t.vertices, t.colors, t.texCoords, r, c) : new cc.V3F_C4B_T2F(null, null, null, r, c);
		this._bl = e ? new cc.V3F_C4B_T2F(e.vertices, e.colors, e.texCoords, r, c + s) : new cc.V3F_C4B_T2F(null, null, null, r, c + s);
		this._tr = i ? new cc.V3F_C4B_T2F(i.vertices, i.colors, i.texCoords, r, c + 2 * s) : new cc.V3F_C4B_T2F(null, null, null, r, c + 2 * s);
		this._br = n ? new cc.V3F_C4B_T2F(n.vertices, n.colors, n.texCoords, r, c + 3 * s) : new cc.V3F_C4B_T2F(null, null, null, r, c + 3 * s)
	};
	cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
	Object.defineProperties(cc.V3F_C4B_T2F_Quad.prototype, {
		tl: {
			get: function() {
				return this._tl
			},
			set: function(t) {
				var e = this._tl;
				e.vertices = t.vertices;
				e.colors = t.colors;
				e.texCoords = t.texCoords
			},
			enumerable: !0
		},
		bl: {
			get: function() {
				return this._bl
			},
			set: function(t) {
				var e = this._bl;
				e.vertices = t.vertices;
				e.colors = t.colors;
				e.texCoords = t.texCoords
			},
			enumerable: !0
		},
		tr: {
			get: function() {
				return this._tr
			},
			set: function(t) {
				var e = this._tr;
				e.vertices = t.vertices;
				e.colors = t.colors;
				e.texCoords = t.texCoords
			},
			enumerable: !0
		},
		br: {
			get: function() {
				return this._br
			},
			set: function(t) {
				var e = this._br;
				e.vertices = t.vertices;
				e.colors = t.colors;
				e.texCoords = t.texCoords
			},
			enumerable: !0
		},
		arrayBuffer: {
			get: function() {
				return this._arrayBuffer
			},
			enumerable: !0
		}
	});
	cc.V3F_C4B_T2F_QuadZero = function() {
		return new cc.V3F_C4B_T2F_Quad
	};
	cc.V3F_C4B_T2F_QuadCopy = function(t) {
		if (!t) return cc.V3F_C4B_T2F_QuadZero();
		var e = t.tl,
			i = t.bl,
			n = t.tr;
		t = t.br;
		return {
			tl: {
				vertices: {
					x: e.vertices.x,
					y: e.vertices.y,
					z: e.vertices.z
				},
				colors: {
					r: e.colors.r,
					g: e.colors.g,
					b: e.colors.b,
					a: e.colors.a
				},
				texCoords: {
					u: e.texCoords.u,
					v: e.texCoords.v
				}
			},
			bl: {
				vertices: {
					x: i.vertices.x,
					y: i.vertices.y,
					z: i.vertices.z
				},
				colors: {
					r: i.colors.r,
					g: i.colors.g,
					b: i.colors.b,
					a: i.colors.a
				},
				texCoords: {
					u: i.texCoords.u,
					v: i.texCoords.v
				}
			},
			tr: {
				vertices: {
					x: n.vertices.x,
					y: n.vertices.y,
					z: n.vertices.z
				},
				colors: {
					r: n.colors.r,
					g: n.colors.g,
					b: n.colors.b,
					a: n.colors.a
				},
				texCoords: {
					u: n.texCoords.u,
					v: n.texCoords.v
				}
			},
			br: {
				vertices: {
					x: t.vertices.x,
					y: t.vertices.y,
					z: t.vertices.z
				},
				colors: {
					r: t.colors.r,
					g: t.colors.g,
					b: t.colors.b,
					a: t.colors.a
				},
				texCoords: {
					u: t.texCoords.u,
					v: t.texCoords.v
				}
			}
		}
	};
	cc.V3F_C4B_T2F_QuadsCopy = function(t) {
		if (!t) return [];
		for (var e = [], i = 0; i < t.length; i++) e.push(cc.V3F_C4B_T2F_QuadCopy(t[i]));
		return e
	};
	cc.V2F_C4B_T2F = function(t, e, i, n, r) {
		this._arrayBuffer = n || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
		this._offset = r || 0;
		n = this._arrayBuffer;
		r = this._offset;
		var c = cc.Vertex2F.BYTES_PER_ELEMENT;
		this._vertices = t ? new cc.Vertex2F(t.x, t.y, n, r) : new cc.Vertex2F(0, 0, n, r);
		this._colors = e ? cc.color(e.r, e.g, e.b, e.a, n, r + c) : cc.color(0, 0, 0, 0, n, r + c);
		this._texCoords = i ? new cc.Tex2F(i.u, i.v, n, r + c + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, n, r + c + cc.Color.BYTES_PER_ELEMENT)
	};
	cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
	Object.defineProperties(cc.V2F_C4B_T2F.prototype, {
		vertices: {
			get: function() {
				return this._vertices
			},
			set: function(t) {
				this._vertices.x = t.x;
				this._vertices.y = t.y
			},
			enumerable: !0
		},
		colors: {
			get: function() {
				return this._colors
			},
			set: function(t) {
				var e = this._colors;
				e.r = t.r;
				e.g = t.g;
				e.b = t.b;
				e.a = t.a
			},
			enumerable: !0
		},
		texCoords: {
			get: function() {
				return this._texCoords
			},
			set: function(t) {
				this._texCoords.u = t.u;
				this._texCoords.v = t.v
			},
			enumerable: !0
		}
	});
	cc.V2F_C4B_T2F_Triangle = function(t, e, i, n, r) {
		this._arrayBuffer = n || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
		this._offset = r || 0;
		n = this._arrayBuffer;
		r = this._offset;
		var c = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
		this._a = t ? new cc.V2F_C4B_T2F(t.vertices, t.colors, t.texCoords, n, r) : new cc.V2F_C4B_T2F(null, null, null, n, r);
		this._b = e ? new cc.V2F_C4B_T2F(e.vertices, e.colors, e.texCoords, n, r + c) : new cc.V2F_C4B_T2F(null, null, null, n, r + c);
		this._c = i ? new cc.V2F_C4B_T2F(i.vertices, i.colors, i.texCoords, n, r + 2 * c) : new cc.V2F_C4B_T2F(null, null, null, n, r + 2 * c)
	};
	cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
	Object.defineProperties(cc.V2F_C4B_T2F_Triangle.prototype, {
		a: {
			get: function() {
				return this._a
			},
			set: function(t) {
				var e = this._a;
				e.vertices = t.vertices;
				e.colors = t.colors;
				e.texCoords = t.texCoords
			},
			enumerable: !0
		},
		b: {
			get: function() {
				return this._b
			},
			set: function(t) {
				var e = this._b;
				e.vertices = t.vertices;
				e.colors = t.colors;
				e.texCoords = t.texCoords
			},
			enumerable: !0
		},
		c: {
			get: function() {
				return this._c
			},
			set: function(t) {
				var e = this._c;
				e.vertices = t.vertices;
				e.colors = t.colors;
				e.texCoords = t.texCoords
			},
			enumerable: !0
		}
	})
};
cc._tmp.PrototypeColor = function() {
	var t = cc.color;
	t._getWhite = function() {
		return t(255, 255, 255)
	};
	t._getYellow = function() {
		return t(255, 255, 0)
	};
	t._getBlue = function() {
		return t(0, 0, 255)
	};
	t._getGreen = function() {
		return t(0, 255, 0)
	};
	t._getRed = function() {
		return t(255, 0, 0)
	};
	t._getMagenta = function() {
		return t(255, 0, 255)
	};
	t._getBlack = function() {
		return t(0, 0, 0)
	};
	t._getOrange = function() {
		return t(255, 127, 0)
	};
	t._getGray = function() {
		return t(166, 166, 166)
	};
	cc.defineGetterSetter(t, "WHITE", t._getWhite);
	cc.defineGetterSetter(t, "YELLOW", t._getYellow);
	cc.defineGetterSetter(t, "BLUE", t._getBlue);
	cc.defineGetterSetter(t, "GREEN", t._getGreen);
	cc.defineGetterSetter(t, "RED", t._getRed);
	cc.defineGetterSetter(t, "MAGENTA", t._getMagenta);
	cc.defineGetterSetter(t, "BLACK", t._getBlack);
	cc.defineGetterSetter(t, "ORANGE", t._getOrange);
	cc.defineGetterSetter(t, "GRAY", t._getGray);
	cc.BlendFunc._disable = function() {
		return new cc.BlendFunc(cc.ONE, cc.ZERO)
	};
	cc.BlendFunc._alphaPremultiplied = function() {
		return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
	};
	cc.BlendFunc._alphaNonPremultiplied = function() {
		return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
	};
	cc.BlendFunc._additive = function() {
		return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
	};
	cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
	cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
	cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
	cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
};
cc.Color = function(t, e, i, n) {
	this.r = t || 0;
	this.g = e || 0;
	this.b = i || 0;
	this.a = null == n ? 255 : n
};
cc.color = function(t, e, i, n) {
	return void 0 === t ? {
		r: 0,
		g: 0,
		b: 0,
		a: 255
	} : cc.isString(t) ? cc.hexToColor(t) : cc.isObject(t) ? {
		r: t.r,
		g: t.g,
		b: t.b,
		a: null == t.a ? 255 : t.a
	} : {
		r: t,
		g: e,
		b: i,
		a: null == n ? 255 : n
	}
};
cc.colorEqual = function(t, e) {
	return t.r === e.r && t.g === e.g && t.b === e.b
};
cc.Acceleration = function(t, e, i, n) {
	this.x = t || 0;
	this.y = e || 0;
	this.z = i || 0;
	this.timestamp = n || 0
};
cc.Vertex2F = function(t, e) {
	this.x = t || 0;
	this.y = e || 0
};
cc.vertex2 = function(t, e) {
	return new cc.Vertex2F(t, e)
};
cc.Vertex3F = function(t, e, i) {
	this.x = t || 0;
	this.y = e || 0;
	this.z = i || 0
};
cc.vertex3 = function(t, e, i) {
	return new cc.Vertex3F(t, e, i)
};
cc.Tex2F = function(t, e) {
	this.u = t || 0;
	this.v = e || 0
};
cc.tex2 = function(t, e) {
	return new cc.Tex2F(t, e)
};
cc.BlendFunc = function(t, e) {
	this.src = t;
	this.dst = e
};
cc.blendFuncDisable = function() {
	return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.hexToColor = function(t) {
	t = t.replace(/^#?/, "0x");
	t = parseInt(t);
	return cc.color(t >> 16, (t >> 8) % 256, t % 256)
};
cc.colorToHex = function(t) {
	var e = t.r.toString(16),
		i = t.g.toString(16),
		n = t.b.toString(16);
	return "#" + (16 > t.r ? "0" + e : e) + (16 > t.g ? "0" + i : i) + (16 > t.b ? "0" + n : n)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
	_keyMapTb: null,
	_valueMapTb: null,
	__currId: 0,
	ctor: function() {
		this._keyMapTb = {};
		this._valueMapTb = {};
		this.__currId = 2 << (0 | 10 * Math.random())
	},
	__getKey: function() {
		this.__currId++;
		return "key_" + this.__currId
	},
	setObject: function(t, e) {
		if (null != e) {
			var i = this.__getKey();
			this._keyMapTb[i] = e;
			this._valueMapTb[i] = t
		}
	},
	objectForKey: function(t) {
		if (null == t) return null;
		var e = this._keyMapTb,
			i;
		for (i in e) if (e[i] === t) return this._valueMapTb[i];
		return null
	},
	valueForKey: function(t) {
		return this.objectForKey(t)
	},
	removeObjectForKey: function(t) {
		if (null != t) {
			var e = this._keyMapTb,
				i;
			for (i in e) if (e[i] === t) {
				delete this._valueMapTb[i];
				delete e[i];
				break
			}
		}
	},
	removeObjectsForKeys: function(t) {
		if (null != t) for (var e = 0; e < t.length; e++) this.removeObjectForKey(t[e])
	},
	allKeys: function() {
		var t = [],
			e = this._keyMapTb,
			i;
		for (i in e) t.push(e[i]);
		return t
	},
	removeAllObjects: function() {
		this._keyMapTb = {};
		this._valueMapTb = {}
	},
	count: function() {
		return this.allKeys().length
	}
});
cc.FontDefinition = function() {
	this.fontName = "Arial";
	this.fontSize = 12;
	this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
	this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
	this.fillStyle = cc.color(255, 255, 255, 255);
	this.boundingHeight = this.boundingWidth = 0;
	this.strokeEnabled = !1;
	this.strokeStyle = cc.color(255, 255, 255, 255);
	this.lineWidth = 1;
	this.shadowEnabled = !1;
	this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
	this.shadowOpacity = 1
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLColor), cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor);
cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
cc._tmp.PrototypeColor();
delete cc._tmp.PrototypeColor;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
cc.__BrowserGetter = {
	init: function() {
		this.html = document.getElementsByTagName("html")[0]
	},
	availWidth: function(t) {
		return !t || t === this.html ? window.innerWidth : t.clientWidth
	},
	availHeight: function(t) {
		return !t || t === this.html ? window.innerHeight : t.clientHeight
	},
	meta: {
		width: "device-width",
		"user-scalable": "no"
	}
};
switch (cc.sys.browserType) {
case cc.sys.BROWSER_TYPE_SAFARI:
	cc.__BrowserGetter.meta["minimal-ui"] = "true";
	break;
case cc.sys.BROWSER_TYPE_CHROME:
	cc.__BrowserGetter.__defineGetter__("target-densitydpi", function() {
		return cc.view._targetDensityDPI
	});
case cc.sys.BROWSER_TYPE_UC:
	cc.__BrowserGetter.availWidth = function(t) {
		return t.clientWidth
	};
	cc.__BrowserGetter.availHeight = function(t) {
		return t.clientHeight
	};
	break;
case cc.sys.BROWSER_TYPE_MIUI:
	cc.__BrowserGetter.init = function(t) {
		if (!t.__resizeWithBrowserSize) {
			var e = function() {
					t.setDesignResolutionSize(t._designResolutionSize.width, t._designResolutionSize.height, t._resolutionPolicy);
					window.removeEventListener("resize", e, !1)
				};
			window.addEventListener("resize", e, !1)
		}
	}
}
cc.EGLView = cc.Class.extend({
	_delegate: null,
	_frameSize: null,
	_designResolutionSize: null,
	_originalDesignResolutionSize: null,
	_viewPortRect: null,
	_visibleRect: null,
	_retinaEnabled: !1,
	_autoFullScreen: !0,
	_devicePixelRatio: 1,
	_viewName: "",
	_resizeCallback: null,
	_scaleX: 1,
	_originalScaleX: 1,
	_scaleY: 1,
	_originalScaleY: 1,
	_indexBitsUsed: 0,
	_maxTouches: 5,
	_resolutionPolicy: null,
	_rpExactFit: null,
	_rpShowAll: null,
	_rpNoBorder: null,
	_rpFixedHeight: null,
	_rpFixedWidth: null,
	_initialized: !1,
	_captured: !1,
	_wnd: null,
	_hDC: null,
	_hRC: null,
	_supportTouch: !1,
	_contentTranslateLeftTop: null,
	_frame: null,
	_frameZoomFactor: 1,
	__resizeWithBrowserSize: !1,
	_isAdjustViewPort: !0,
	_targetDensityDPI: null,
	ctor: function() {
		var t = document,
			e = cc.ContainerStrategy,
			i = cc.ContentStrategy;
		cc.__BrowserGetter.init(this);
		this._frame = cc.container.parentNode === t.body ? t.documentElement : cc.container.parentNode;
		this._frameSize = cc.size(0, 0);
		this._initFrameSize();
		var t = cc._canvas.width,
			n = cc._canvas.height;
		this._designResolutionSize = cc.size(t, n);
		this._originalDesignResolutionSize = cc.size(t, n);
		this._viewPortRect = cc.rect(0, 0, t, n);
		this._visibleRect = cc.rect(0, 0, t, n);
		this._contentTranslateLeftTop = {
			left: 0,
			top: 0
		};
		this._viewName = "Cocos2dHTML5";
		t = cc.sys;
		this.enableRetina(t.os == t.OS_IOS || t.os == t.OS_OSX);
		cc.visibleRect && cc.visibleRect.init(this._visibleRect);
		this._rpExactFit = new cc.ResolutionPolicy(e.EQUAL_TO_FRAME, i.EXACT_FIT);
		this._rpShowAll = new cc.ResolutionPolicy(e.PROPORTION_TO_FRAME, i.SHOW_ALL);
		this._rpNoBorder = new cc.ResolutionPolicy(e.EQUAL_TO_FRAME, i.NO_BORDER);
		this._rpFixedHeight = new cc.ResolutionPolicy(e.EQUAL_TO_FRAME, i.FIXED_HEIGHT);
		this._rpFixedWidth = new cc.ResolutionPolicy(e.EQUAL_TO_FRAME, i.FIXED_WIDTH);
		this._hDC = cc._canvas;
		this._hRC = cc._renderContext;
		this._targetDensityDPI = cc.DENSITYDPI_HIGH
	},
	_resizeEvent: function() {
		var t = this._originalDesignResolutionSize.width,
			e = this._originalDesignResolutionSize.height;
		this._resizeCallback && (this._initFrameSize(), this._resizeCallback.call());
		0 < t && this.setDesignResolutionSize(t, e, this._resolutionPolicy)
	},
	setTargetDensityDPI: function(t) {
		this._targetDensityDPI = t;
		this._setViewPortMeta()
	},
	getTargetDensityDPI: function() {
		return this._targetDensityDPI
	},
	resizeWithBrowserSize: function(t) {
		t ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, t = this._resizeEvent.bind(this), cc._addEventListener(window, "resize", t, !1)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !0, t = this._resizeEvent.bind(this), window.removeEventListener("resize", t, !1))
	},
	setResizeCallback: function(t) {
		if (cc.isFunction(t) || null == t) this._resizeCallback = t
	},
	_initFrameSize: function() {
		var t = this._frameSize;
		t.width = cc.__BrowserGetter.availWidth(this._frame);
		t.height = cc.__BrowserGetter.availHeight(this._frame)
	},
	_adjustSizeKeepCanvasSize: function() {
		var t = this._originalDesignResolutionSize.width,
			e = this._originalDesignResolutionSize.height;
		0 < t && this.setDesignResolutionSize(t, e, this._resolutionPolicy)
	},
	_setViewPortMeta: function() {
		if (this._isAdjustViewPort) {
			var t = document.getElementById("cocosMetaElement");
			t && document.head.removeChild(t);
			var e, i = (t = document.getElementsByName("viewport")) ? t[0] : null,
				n, t = cc.newElement("meta");
			t.id = "cocosMetaElement";
			t.name = "viewport";
			t.content = "";
			e = cc.__BrowserGetter.meta;
			n = i ? i.content : "";
			for (var r in e) RegExp(r).test(n) || (n += "," + r + "=" + e[r]);
			/^,/.test(n) && (n = n.substr(1));
			t.content = n;
			i && (i.content = n);
			document.head.appendChild(t)
		}
	},
	_setScaleXYForRenderTexture: function() {
		var t = cc.contentScaleFactor();
		this._scaleY = this._scaleX = t
	},
	_resetScale: function() {
		this._scaleX = this._originalScaleX;
		this._scaleY = this._originalScaleY
	},
	_adjustSizeToBrowser: function() {},
	initialize: function() {
		this._initialized = !0
	},
	adjustViewPort: function(t) {
		this._isAdjustViewPort = t
	},
	enableRetina: function(t) {
		this._retinaEnabled = t ? !0 : !1
	},
	isRetinaEnabled: function() {
		return this._retinaEnabled
	},
	enableAutoFullScreen: function(t) {
		this._autoFullScreen = t ? !0 : !1
	},
	isAutoFullScreenEnabled: function() {
		return this._autoFullScreen
	},
	end: function() {},
	isOpenGLReady: function() {
		return null != this._hDC && null != this._hRC
	},
	setFrameZoomFactor: function(t) {
		this._frameZoomFactor = t;
		this.centerWindow();
		cc.director.setProjection(cc.director.getProjection())
	},
	swapBuffers: function() {},
	setIMEKeyboardState: function(t) {},
	setContentTranslateLeftTop: function(t, e) {
		this._contentTranslateLeftTop = {
			left: t,
			top: e
		}
	},
	getContentTranslateLeftTop: function() {
		return this._contentTranslateLeftTop
	},
	getFrameSize: function() {
		return cc.size(this._frameSize.width, this._frameSize.height)
	},
	setFrameSize: function(t, e) {
		this._frameSize.width = t;
		this._frameSize.height = e;
		this._frame.style.width = t + "px";
		this._frame.style.height = e + "px";
		this._resizeEvent();
		cc.director.setProjection(cc.director.getProjection())
	},
	centerWindow: function() {},
	getVisibleSize: function() {
		return cc.size(this._visibleRect.width, this._visibleRect.height)
	},
	getVisibleOrigin: function() {
		return cc.p(this._visibleRect.x, this._visibleRect.y)
	},
	canSetContentScaleFactor: function() {
		return !0
	},
	getResolutionPolicy: function() {
		return this._resolutionPolicy
	},
	setResolutionPolicy: function(t) {
		if (t instanceof cc.ResolutionPolicy) this._resolutionPolicy = t;
		else {
			var e = cc.ResolutionPolicy;
			t === e.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit);
			t === e.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll);
			t === e.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder);
			t === e.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight);
			t === e.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
		}
	},
	setDesignResolutionSize: function(t, e, i) {
		if (0 < t || 0 < e) if (this.setResolutionPolicy(i), i = this._resolutionPolicy) {
			i.preApply(this);
			cc.sys.isMobile && this._setViewPortMeta();
			this._initFrameSize();
			this._originalDesignResolutionSize.width = this._designResolutionSize.width = t;
			this._originalDesignResolutionSize.height = this._designResolutionSize.height = e;
			var n = i.apply(this, this._designResolutionSize);
			n.scale && 2 == n.scale.length && (this._scaleX = n.scale[0], this._scaleY = n.scale[1]);
			n.viewport && (t = this._viewPortRect, e = this._visibleRect, n = n.viewport, t.x = n.x, t.y = n.y, t.width = n.width, t.height = n.height, e.x = -t.x / this._scaleX, e.y = -t.y / this._scaleY, e.width = cc._canvas.width / this._scaleX, e.height = cc._canvas.height / this._scaleY);
			t = cc.director;
			t._winSizeInPoints.width = this._designResolutionSize.width;
			t._winSizeInPoints.height = this._designResolutionSize.height;
			i.postApply(this);
			cc.winSize.width = t._winSizeInPoints.width;
			cc.winSize.height = t._winSizeInPoints.height;
			cc._renderType == cc._RENDER_TYPE_WEBGL && (t._createStatsLabel(), t.setGLDefaultValues());
			this._originalScaleX = this._scaleX;
			this._originalScaleY = this._scaleY;
			cc.DOM && cc.DOM._resetEGLViewDiv();
			cc.visibleRect && cc.visibleRect.init(this._visibleRect)
		} else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
		else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize)
	},
	getDesignResolutionSize: function() {
		return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
	},
	setViewPortInPoints: function(t, e, i, n) {
		var r = this._frameZoomFactor,
			c = this._scaleX,
			s = this._scaleY;
		cc._renderContext.viewport(t * c * r + this._viewPortRect.x * r, e * s * r + this._viewPortRect.y * r, i * c * r, n * s * r)
	},
	setScissorInPoints: function(t, e, i, n) {
		var r = this._frameZoomFactor,
			c = this._scaleX,
			s = this._scaleY;
		cc._renderContext.scissor(t * c * r + this._viewPortRect.x * r, e * s * r + this._viewPortRect.y * r, i * c * r, n * s * r)
	},
	isScissorEnabled: function() {
		var t = cc._renderContext;
		return t.isEnabled(t.SCISSOR_TEST)
	},
	getScissorRect: function() {
		var t = cc._renderContext,
			e = this._scaleX,
			i = this._scaleY,
			t = t.getParameter(t.SCISSOR_BOX);
		return cc.rect((t[0] - this._viewPortRect.x) / e, (t[1] - this._viewPortRect.y) / i, t[2] / e, t[3] / i)
	},
	setViewName: function(t) {
		null != t && 0 < t.length && (this._viewName = t)
	},
	getViewName: function() {
		return this._viewName
	},
	getViewPortRect: function() {
		return this._viewPortRect
	},
	getScaleX: function() {
		return this._scaleX
	},
	getScaleY: function() {
		return this._scaleY
	},
	getDevicePixelRatio: function() {
		return this._devicePixelRatio
	},
	convertToLocationInView: function(t, e, i) {
		return {
			x: this._devicePixelRatio * (t - i.left),
			y: this._devicePixelRatio * (i.top + i.height - e)
		}
	},
	_convertMouseToLocationInView: function(t, e) {
		var i = this._viewPortRect;
		t.x = (this._devicePixelRatio * (t.x - e.left) - i.x) / this._scaleX;
		t.y = (this._devicePixelRatio * (e.top + e.height - t.y) - i.y) / this._scaleY
	},
	_convertTouchesWithScale: function(t) {
		for (var e = this._viewPortRect, i = this._scaleX, n = this._scaleY, r, c, s, o = 0; o < t.length; o++) r = t[o], c = r._point, s = r._prevPoint, r._setPoint((c.x - e.x) / i, (c.y - e.y) / n), r._setPrevPoint((s.x - e.x) / i, (s.y - e.y) / n)
	}
});
cc.EGLView._getInstance = function() {
	this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
	return this._instance
};
cc.ContainerStrategy = cc.Class.extend({
	preApply: function(t) {},
	apply: function(t, e) {},
	postApply: function(t) {},
	_setupContainer: function(t, e, i) {
		var n = t._frame;
		cc.view._autoFullScreen && (cc.sys.isMobile && n == document.documentElement) && cc.screen.autoFullScreen(n);
		var n = cc._canvas,
			r = cc.container;
		r.style.width = n.style.width = e + "px";
		r.style.height = n.style.height = i + "px";
		r = t._devicePixelRatio = 1;
		t.isRetinaEnabled() && (r = t._devicePixelRatio = window.devicePixelRatio || 1);
		n.width = e * r;
		n.height = i * r;
		t = document.body;
		var c;
		if (t && (c = t.style)) c.paddingTop = c.paddingTop || "0px", c.paddingRight = c.paddingRight || "0px", c.paddingBottom = c.paddingBottom || "0px", c.paddingLeft = c.paddingLeft || "0px", c.borderTop = c.borderTop || "0px", c.borderRight = c.borderRight || "0px", c.borderBottom = c.borderBottom || "0px", c.borderLeft = c.borderLeft || "0px", c.marginTop = c.marginTop || "0px", c.marginRight = c.marginRight || "0px", c.marginBottom = c.marginBottom || "0px", c.marginLeft = c.marginLeft || "0px"
	},
	_fixContainer: function() {
		document.body.insertBefore(cc.container, document.body.firstChild);
		var t = document.body.style;
		t.width = window.innerWidth + "px";
		t.height = window.innerHeight + "px";
		t.overflow = "hidden";
		t = cc.container.style;
		t.position = "fixed";
		t.left = t.top = "0px";
		document.body.scrollTop = 0
	}
});
cc.ContentStrategy = cc.Class.extend({
	_result: {
		scale: [1, 1],
		viewport: null
	},
	_buildResult: function(t, e, i, n, r, c) {
		2 > Math.abs(t - i) && (i = t);
		2 > Math.abs(e - n) && (n = e);
		t = cc.rect(Math.round((t - i) / 2), Math.round((e - n) / 2), i, n);
		cc._renderType == cc._RENDER_TYPE_CANVAS && cc._renderContext.translate(t.x, t.y + n);
		this._result.scale = [r, c];
		this._result.viewport = t;
		return this._result
	},
	preApply: function(t) {},
	apply: function(t, e) {
		return {
			scale: [1, 1]
		}
	},
	postApply: function(t) {}
});
(function() {
	var t = cc.ContainerStrategy.extend({
		apply: function(t) {
			this._setupContainer(t, t._frameSize.width, t._frameSize.height)
		}
	}),
		e = cc.ContainerStrategy.extend({
			apply: function(t, e) {
				var i = t._frameSize.width,
					n = t._frameSize.height,
					r = cc.container.style,
					c = e.width,
					s = e.height,
					o = i / c,
					a = n / s,
					h, l;
				o < a ? (h = i, l = s * o) : (h = c * a, l = n);
				c = Math.round((i - h) / 2);
				l = Math.round((n - l) / 2);
				this._setupContainer(t, i - 2 * c, n - 2 * l);
				r.marginLeft = c + "px";
				r.marginRight = c + "px";
				r.marginTop = l + "px";
				r.marginBottom = l + "px"
			}
		});
	t.extend({
		preApply: function(t) {
			this._super(t);
			t._frame = document.documentElement
		},
		apply: function(t) {
			this._super(t);
			this._fixContainer()
		}
	});
	e.extend({
		preApply: function(t) {
			this._super(t);
			t._frame = document.documentElement
		},
		apply: function(t, e) {
			this._super(t, e);
			this._fixContainer()
		}
	});
	var i = cc.ContainerStrategy.extend({
		apply: function(t) {
			this._setupContainer(t, cc._canvas.width, cc._canvas.height)
		}
	});
	cc.ContainerStrategy.EQUAL_TO_FRAME = new t;
	cc.ContainerStrategy.PROPORTION_TO_FRAME = new e;
	cc.ContainerStrategy.ORIGINAL_CONTAINER = new i;
	var t = cc.ContentStrategy.extend({
		apply: function(t, e) {
			var i = cc._canvas.width,
				n = cc._canvas.height;
			return this._buildResult(i, n, i, n, i / e.width, n / e.height)
		}
	}),
		e = cc.ContentStrategy.extend({
			apply: function(t, e) {
				var i = cc._canvas.width,
					n = cc._canvas.height,
					r = e.width,
					c = e.height,
					s = i / r,
					o = n / c,
					a = 0,
					h, l;
				s < o ? (a = s, h = i, l = c * a) : (a = o, h = r * a, l = n);
				return this._buildResult(i, n, h, l, a, a)
			}
		}),
		i = cc.ContentStrategy.extend({
			apply: function(t, e) {
				var i = cc._canvas.width,
					n = cc._canvas.height,
					r = e.width,
					c = e.height,
					s = i / r,
					o = n / c,
					a, h, l;
				s < o ? (a = o, h = r * a, l = n) : (a = s, h = i, l = c * a);
				return this._buildResult(i, n, h, l, a, a)
			}
		}),
		n = cc.ContentStrategy.extend({
			apply: function(t, e) {
				var i = cc._canvas.width,
					n = cc._canvas.height,
					r = n / e.height;
				return this._buildResult(i, n, i, n, r, r)
			},
			postApply: function(t) {
				cc.director._winSizeInPoints = t.getVisibleSize()
			}
		}),
		r = cc.ContentStrategy.extend({
			apply: function(t, e) {
				var i = cc._canvas.width,
					n = cc._canvas.height,
					r = i / e.width;
				return this._buildResult(i, n, i, n, r, r)
			},
			postApply: function(t) {
				cc.director._winSizeInPoints = t.getVisibleSize()
			}
		});
	cc.ContentStrategy.EXACT_FIT = new t;
	cc.ContentStrategy.SHOW_ALL = new e;
	cc.ContentStrategy.NO_BORDER = new i;
	cc.ContentStrategy.FIXED_HEIGHT = new n;
	cc.ContentStrategy.FIXED_WIDTH = new r
})();
cc.ResolutionPolicy = cc.Class.extend({
	_containerStrategy: null,
	_contentStrategy: null,
	ctor: function(t, e) {
		this.setContainerStrategy(t);
		this.setContentStrategy(e)
	},
	preApply: function(t) {
		this._containerStrategy.preApply(t);
		this._contentStrategy.preApply(t)
	},
	apply: function(t, e) {
		this._containerStrategy.apply(t, e);
		return this._contentStrategy.apply(t, e)
	},
	postApply: function(t) {
		this._containerStrategy.postApply(t);
		this._contentStrategy.postApply(t)
	},
	setContainerStrategy: function(t) {
		t instanceof cc.ContainerStrategy && (this._containerStrategy = t)
	},
	setContentStrategy: function(t) {
		t instanceof cc.ContentStrategy && (this._contentStrategy = t)
	}
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
	_supportsFullScreen: !1,
	_preOnFullScreenChange: null,
	_touchEvent: "",
	_fn: null,
	_fnMap: [
		["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
		["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
		["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
		["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement"],
		["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
	],
	init: function() {
		this._fn = {};
		var t, e, i = this._fnMap,
			n;
		t = 0;
		for (l = i.length; t < l; t++) if ((e = i[t]) && e[1] in document) {
			t = 0;
			for (n = e.length; t < n; t++) this._fn[i[0][t]] = e[t];
			break
		}
		this._supportsFullScreen = void 0 != this._fn.requestFullscreen;
		this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
	},
	fullScreen: function() {
		return this._supportsFullScreen && document[this._fn.fullscreenEnabled]
	},
	requestFullScreen: function(t, e) {
		if (this._supportsFullScreen) {
			t = t || document.documentElement;
			t[this._fn.requestFullscreen]();
			if (e) {
				var i = this._fn.fullscreenchange;
				this._preOnFullScreenChange && document.removeEventListener(i, this._preOnFullScreenChange);
				this._preOnFullScreenChange = e;
				cc._addEventListener(document, i, e, !1)
			}
			return t[this._fn.requestFullscreen]()
		}
	},
	exitFullScreen: function() {
		return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
	},
	autoFullScreen: function(t, e) {
		function i() {
			r.requestFullScreen(t, e);
			n.removeEventListener(r._touchEvent, i)
		}
		t = t || document.body;
		var n = cc._canvas || t,
			r = this;
		this.requestFullScreen(t, e);
		cc._addEventListener(n, this._touchEvent, i)
	}
};
cc.screen.init();
cc.visibleRect = {
	topLeft: cc.p(0, 0),
	topRight: cc.p(0, 0),
	top: cc.p(0, 0),
	bottomLeft: cc.p(0, 0),
	bottomRight: cc.p(0, 0),
	bottom: cc.p(0, 0),
	center: cc.p(0, 0),
	left: cc.p(0, 0),
	right: cc.p(0, 0),
	width: 0,
	height: 0,
	init: function(t) {
		var e = this.width = t.width,
			i = this.height = t.height,
			n = t.x;
		t = t.y;
		var r = t + i,
			c = n + e;
		this.topLeft.x = n;
		this.topLeft.y = r;
		this.topRight.x = c;
		this.topRight.y = r;
		this.top.x = n + e / 2;
		this.top.y = r;
		this.bottomLeft.x = n;
		this.bottomLeft.y = t;
		this.bottomRight.x = c;
		this.bottomRight.y = t;
		this.bottom.x = n + e / 2;
		this.bottom.y = t;
		this.center.x = n + e / 2;
		this.center.y = t + i / 2;
		this.left.x = n;
		this.left.y = t + i / 2;
		this.right.x = c;
		this.right.y = t + i / 2
	}
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
	_mousePressed: !1,
	_isRegisterEvent: !1,
	_preTouchPoint: cc.p(0, 0),
	_prevMousePoint: cc.p(0, 0),
	_preTouchPool: [],
	_preTouchPoolPointer: 0,
	_touches: [],
	_touchesIntegerDict: {},
	_indexBitsUsed: 0,
	_maxTouches: 5,
	_accelEnabled: !1,
	_accelInterval: 1 / 30,
	_accelMinus: 1,
	_accelCurTime: 0,
	_acceleration: null,
	_accelDeviceEvent: null,
	_getUnUsedIndex: function() {
		for (var t = this._indexBitsUsed, e = 0; e < this._maxTouches; e++) {
			if (!(t & 1)) return this._indexBitsUsed |= 1 << e, e;
			t >>= 1
		}
		return -1
	},
	_removeUsedIndexBit: function(t) {
		0 > t || t >= this._maxTouches || (t = ~ (1 << t), this._indexBitsUsed &= t)
	},
	_glView: null,
	handleTouchesBegin: function(t) {
		for (var e, i, n, r = [], c = this._touchesIntegerDict, s = 0, o = t.length; s < o; s++) if (e = t[s], n = e.getID(), i = c[n], null == i) {
			var a = this._getUnUsedIndex(); - 1 == a ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, a) : (i = this._touches[a] = new cc.Touch(e._point.x, e._point.y, e.getID()), i._setPrevPoint(e._prevPoint), c[n] = a, r.push(i))
		}
		0 < r.length && (this._glView._convertTouchesWithScale(r), t = new cc.EventTouch(r), t._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(t))
	},
	handleTouchesMove: function(t) {
		for (var e, i, n = [], r = this._touches, c = 0, s = t.length; c < s; c++) e = t[c], i = e.getID(), i = this._touchesIntegerDict[i], null != i && r[i] && (r[i]._setPoint(e._point), r[i]._setPrevPoint(e._prevPoint), n.push(r[i]));
		0 < n.length && (this._glView._convertTouchesWithScale(n), t = new cc.EventTouch(n), t._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(t))
	},
	handleTouchesEnd: function(t) {
		t = this.getSetOfTouchesEndOrCancel(t);
		0 < t.length && (this._glView._convertTouchesWithScale(t), t = new cc.EventTouch(t), t._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(t))
	},
	handleTouchesCancel: function(t) {
		t = this.getSetOfTouchesEndOrCancel(t);
		0 < t.length && (this._glView._convertTouchesWithScale(t), t = new cc.EventTouch(t), t._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(t))
	},
	getSetOfTouchesEndOrCancel: function(t) {
		for (var e, i, n, r = [], c = this._touches, s = this._touchesIntegerDict, o = 0, a = t.length; o < a; o++) e = t[o], n = e.getID(), i = s[n], null != i && c[i] && (c[i]._setPoint(e._point), c[i]._setPrevPoint(e._prevPoint), r.push(c[i]), this._removeUsedIndexBit(i), delete s[n]);
		return r
	},
	getHTMLElementPosition: function(t) {
		var e = document.documentElement,
			i = window,
			n = null,
			n = cc.isFunction(t.getBoundingClientRect) ? t.getBoundingClientRect() : t instanceof HTMLCanvasElement ? {
				left: 0,
				top: 0,
				width: t.width,
				height: t.height
			} : {
				left: 0,
				top: 0,
				width: parseInt(t.style.width),
				height: parseInt(t.style.height)
			};
		return {
			left: n.left + i.pageXOffset - e.clientLeft,
			top: n.top + i.pageYOffset - e.clientTop,
			width: n.width,
			height: n.height
		}
	},
	getPreTouch: function(t) {
		for (var e = null, i = this._preTouchPool, n = t.getID(), r = i.length - 1; 0 <= r; r--) if (i[r].getID() == n) {
			e = i[r];
			break
		}
		e || (e = t);
		return e
	},
	setPreTouch: function(t) {
		for (var e = !1, i = this._preTouchPool, n = t.getID(), r = i.length - 1; 0 <= r; r--) if (i[r].getID() == n) {
			i[r] = t;
			e = !0;
			break
		}
		e || (50 >= i.length ? i.push(t) : (i[this._preTouchPoolPointer] = t, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
	},
	getTouchByXY: function(t, e, i) {
		var n = this._preTouchPoint;
		t = this._glView.convertToLocationInView(t, e, i);
		e = new cc.Touch(t.x, t.y);
		e._setPrevPoint(n.x, n.y);
		n.x = t.x;
		n.y = t.y;
		return e
	},
	getMouseEvent: function(t, e, i) {
		var n = this._prevMousePoint;
		this._glView._convertMouseToLocationInView(t, e);
		e = new cc.EventMouse(i);
		e.setLocation(t.x, t.y);
		e._setPrevCursor(n.x, n.y);
		n.x = t.x;
		n.y = t.y;
		return e
	},
	getPointByEvent: function(t, e) {
		if (null != t.pageX) return {
			x: t.pageX,
			y: t.pageY
		};
		e.left -= document.body.scrollLeft;
		e.top -= document.body.scrollTop;
		return {
			x: t.clientX,
			y: t.clientY
		}
	},
	getTouchesByEvent: function(t, e) {
		for (var i = [], n = this._glView, r, c, s = this._preTouchPoint, o = t.changedTouches.length, a = 0; a < o; a++) if (r = t.changedTouches[a]) {
			var h;
			h = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? n.convertToLocationInView(r.pageX, r.pageY, e) : n.convertToLocationInView(r.clientX, r.clientY, e);
			null != r.identifier ? (r = new cc.Touch(h.x, h.y, r.identifier), c = this.getPreTouch(r).getLocation(), r._setPrevPoint(c.x, c.y), this.setPreTouch(r)) : (r = new cc.Touch(h.x, h.y), r._setPrevPoint(s.x, s.y));
			s.x = h.x;
			s.y = h.y;
			i.push(r)
		}
		return i
	},
	registerSystemEvent: function(t) {
		if (!this._isRegisterEvent) {
			this._glView = cc.view;
			var e = this,
				i = "touches" in cc.sys.capabilities;
			"mouse" in cc.sys.capabilities && (cc._addEventListener(window, "mousedown", function() {
				e._mousePressed = !0
			}, !1), cc._addEventListener(window, "mouseup", function(n) {
				var r = e._mousePressed;
				e._mousePressed = !1;
				if (r) {
					var r = e.getHTMLElementPosition(t),
						c = e.getPointByEvent(n, r);
					cc.rectContainsPoint(new cc.Rect(r.left, r.top, r.width, r.height), c) || (i || e.handleTouchesEnd([e.getTouchByXY(c.x, c.y, r)]), r = e.getMouseEvent(c, r, cc.EventMouse.UP), r.setButton(n.button), cc.eventManager.dispatchEvent(r))
				}
			}, !1), cc._addEventListener(t, "mousedown", function(n) {
				e._mousePressed = !0;
				var r = e.getHTMLElementPosition(t),
					c = e.getPointByEvent(n, r);
				i || e.handleTouchesBegin([e.getTouchByXY(c.x, c.y, r)]);
				r = e.getMouseEvent(c, r, cc.EventMouse.DOWN);
				r.setButton(n.button);
				cc.eventManager.dispatchEvent(r);
				n.stopPropagation();
				n.preventDefault();
				t.focus()
			}, !1), cc._addEventListener(t, "mouseup", function(n) {
				e._mousePressed = !1;
				var r = e.getHTMLElementPosition(t),
					c = e.getPointByEvent(n, r);
				i || e.handleTouchesEnd([e.getTouchByXY(c.x, c.y, r)]);
				r = e.getMouseEvent(c, r, cc.EventMouse.UP);
				r.setButton(n.button);
				cc.eventManager.dispatchEvent(r);
				n.stopPropagation();
				n.preventDefault()
			}, !1), cc._addEventListener(t, "mousemove", function(n) {
				var r = e.getHTMLElementPosition(t),
					c = e.getPointByEvent(n, r);
				i || e.handleTouchesMove([e.getTouchByXY(c.x, c.y, r)]);
				r = e.getMouseEvent(c, r, cc.EventMouse.MOVE);
				e._mousePressed ? r.setButton(n.button) : r.setButton(null);
				cc.eventManager.dispatchEvent(r);
				n.stopPropagation();
				n.preventDefault()
			}, !1), cc._addEventListener(t, "mousewheel", function(i) {
				var n = e.getHTMLElementPosition(t),
					r = e.getPointByEvent(i, n),
					n = e.getMouseEvent(r, n, cc.EventMouse.SCROLL);
				n.setButton(i.button);
				n.setScrollData(0, i.wheelDelta);
				cc.eventManager.dispatchEvent(n);
				i.stopPropagation();
				i.preventDefault()
			}, !1), cc._addEventListener(t, "DOMMouseScroll", function(i) {
				var n = e.getHTMLElementPosition(t),
					r = e.getPointByEvent(i, n),
					n = e.getMouseEvent(r, n, cc.EventMouse.SCROLL);
				n.setButton(i.button);
				n.setScrollData(0, -120 * i.detail);
				cc.eventManager.dispatchEvent(n);
				i.stopPropagation();
				i.preventDefault()
			}, !1));
			if (window.navigator.msPointerEnabled) {
				var n = {
					MSPointerDown: e.handleTouchesBegin,
					MSPointerMove: e.handleTouchesMove,
					MSPointerUp: e.handleTouchesEnd,
					MSPointerCancel: e.handleTouchesCancel
				},
					r;
				for (r in n)(function(i, n) {
					cc._addEventListener(t, i, function(i) {
						var r = e.getHTMLElementPosition(t);
						r.left -= document.documentElement.scrollLeft;
						r.top -= document.documentElement.scrollTop;
						n.call(e, [e.getTouchByXY(i.clientX, i.clientY, r)]);
						i.stopPropagation()
					}, !1)
				})(r, n[r])
			}
			i && (cc._addEventListener(t, "touchstart", function(i) {
				if (i.changedTouches) {
					var n = e.getHTMLElementPosition(t);
					n.left -= document.body.scrollLeft;
					n.top -= document.body.scrollTop;
					e.handleTouchesBegin(e.getTouchesByEvent(i, n));
					i.stopPropagation();
					i.preventDefault();
					t.focus()
				}
			}, !1), cc._addEventListener(t, "touchmove", function(i) {
				if (i.changedTouches) {
					var n = e.getHTMLElementPosition(t);
					n.left -= document.body.scrollLeft;
					n.top -= document.body.scrollTop;
					e.handleTouchesMove(e.getTouchesByEvent(i, n));
					i.stopPropagation();
					i.preventDefault()
				}
			}, !1), cc._addEventListener(t, "touchend", function(i) {
				if (i.changedTouches) {
					var n = e.getHTMLElementPosition(t);
					n.left -= document.body.scrollLeft;
					n.top -= document.body.scrollTop;
					e.handleTouchesEnd(e.getTouchesByEvent(i, n));
					i.stopPropagation();
					i.preventDefault()
				}
			}, !1), cc._addEventListener(t, "touchcancel", function(i) {
				if (i.changedTouches) {
					var n = e.getHTMLElementPosition(t);
					n.left -= document.body.scrollLeft;
					n.top -= document.body.scrollTop;
					e.handleTouchesCancel(e.getTouchesByEvent(i, n));
					i.stopPropagation();
					i.preventDefault()
				}
			}, !1));
			this._registerKeyboardEvent();
			this._registerAccelerometerEvent();
			this._isRegisterEvent = !0
		}
	},
	_registerKeyboardEvent: function() {},
	_registerAccelerometerEvent: function() {},
	update: function(t) {
		this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
		this._accelCurTime += t
	}
};
var _p = cc.inputManager;
_p.setAccelerometerEnabled = function(t) {
	this._accelEnabled !== t && (this._accelEnabled = t, t = cc.director.getScheduler(), this._accelEnabled ? (this._accelCurTime = 0, t.scheduleUpdateForTarget(this)) : (this._accelCurTime = 0, t.unscheduleUpdateForTarget(this)))
};
_p.setAccelerometerInterval = function(t) {
	this._accelInterval !== t && (this._accelInterval = t)
};
_p._registerKeyboardEvent = function() {
	cc._addEventListener(cc._canvas, "keydown", function(t) {
		cc.eventManager.dispatchEvent(new cc.EventKeyboard(t.keyCode, !0));
		t.stopPropagation();
		t.preventDefault()
	}, !1);
	cc._addEventListener(cc._canvas, "keyup", function(t) {
		cc.eventManager.dispatchEvent(new cc.EventKeyboard(t.keyCode, !1));
		t.stopPropagation();
		t.preventDefault()
	}, !1)
};
_p._registerAccelerometerEvent = function() {
	var t = window;
	this._acceleration = new cc.Acceleration;
	this._accelDeviceEvent = t.DeviceMotionEvent || t.DeviceOrientationEvent;
	cc.sys.browserType == cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
	var e = this._accelDeviceEvent == t.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
		i = navigator.userAgent;
	if (/Android/.test(i) || /Adr/.test(i) && cc.sys.browserType == cc.BROWSER_TYPE_UC) this._minus = -1;
	cc._addEventListener(t, e, this.didAccelerate.bind(this), !1)
};
_p.didAccelerate = function(t) {
	var e = window;
	if (this._accelEnabled) {
		var i = this._acceleration,
			n, r, c;
		this._accelDeviceEvent == window.DeviceMotionEvent ? (c = t.accelerationIncludingGravity, n = .1 * this._accelMinus * c.x, r = .1 * this._accelMinus * c.y, c = .1 * c.z) : (n = .981 * (t.gamma / 90), r = .981 * -(t.beta / 90), c = .981 * (t.alpha / 90));
		cc.sys.os === cc.sys.OS_ANDROID ? (i.x = -n, i.y = -r) : (i.x = n, i.y = r);
		i.z = c;
		i.timestamp = t.timeStamp || Date.now();
		t = i.x;
		e.orientation === cc.UIInterfaceOrientationLandscapeRight ? (i.x = -i.y, i.y = t) : e.orientation === cc.UIInterfaceOrientationLandscapeLeft ? (i.x = i.y, i.y = -t) : e.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (i.x = -i.x, i.y = -i.y)
	}
};
delete _p;
cc.AffineTransform = function(t, e, i, n, r, c) {
	this.a = t;
	this.b = e;
	this.c = i;
	this.d = n;
	this.tx = r;
	this.ty = c
};
cc.affineTransformMake = function(t, e, i, n, r, c) {
	return {
		a: t,
		b: e,
		c: i,
		d: n,
		tx: r,
		ty: c
	}
};
cc.pointApplyAffineTransform = function(t, e) {
	return {
		x: e.a * t.x + e.c * t.y + e.tx,
		y: e.b * t.x + e.d * t.y + e.ty
	}
};
cc._pointApplyAffineTransform = function(t, e, i) {
	return {
		x: i.a * t + i.c * e + i.tx,
		y: i.b * t + i.d * e + i.ty
	}
};
cc.sizeApplyAffineTransform = function(t, e) {
	return {
		width: e.a * t.width + e.c * t.height,
		height: e.b * t.width + e.d * t.height
	}
};
cc.affineTransformMakeIdentity = function() {
	return {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	}
};
cc.affineTransformIdentity = function() {
	return {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	}
};
cc.rectApplyAffineTransform = function(t, e) {
	var i = cc.rectGetMinY(t),
		n = cc.rectGetMinX(t),
		r = cc.rectGetMaxX(t),
		c = cc.rectGetMaxY(t),
		s = cc._pointApplyAffineTransform(n, i, e),
		i = cc._pointApplyAffineTransform(r, i, e),
		n = cc._pointApplyAffineTransform(n, c, e),
		o = cc._pointApplyAffineTransform(r, c, e),
		r = Math.min(s.x, i.x, n.x, o.x),
		c = Math.max(s.x, i.x, n.x, o.x),
		a = Math.min(s.y, i.y, n.y, o.y),
		s = Math.max(s.y, i.y, n.y, o.y);
	return cc.rect(r, a, c - r, s - a)
};
cc._rectApplyAffineTransformIn = function(t, e) {
	var i = cc.rectGetMinY(t),
		n = cc.rectGetMinX(t),
		r = cc.rectGetMaxX(t),
		c = cc.rectGetMaxY(t),
		s = cc._pointApplyAffineTransform(n, i, e),
		i = cc._pointApplyAffineTransform(r, i, e),
		n = cc._pointApplyAffineTransform(n, c, e),
		o = cc._pointApplyAffineTransform(r, c, e),
		r = Math.min(s.x, i.x, n.x, o.x),
		c = Math.max(s.x, i.x, n.x, o.x),
		a = Math.min(s.y, i.y, n.y, o.y),
		s = Math.max(s.y, i.y, n.y, o.y);
	t.x = r;
	t.y = a;
	t.width = c - r;
	t.height = s - a;
	return t
};
cc.affineTransformTranslate = function(t, e, i) {
	return {
		a: t.a,
		b: t.b,
		c: t.c,
		d: t.d,
		tx: t.tx + t.a * e + t.c * i,
		ty: t.ty + t.b * e + t.d * i
	}
};
cc.affineTransformScale = function(t, e, i) {
	return {
		a: t.a * e,
		b: t.b * e,
		c: t.c * i,
		d: t.d * i,
		tx: t.tx,
		ty: t.ty
	}
};
cc.affineTransformRotate = function(t, e) {
	var i = Math.sin(e),
		n = Math.cos(e);
	return {
		a: t.a * n + t.c * i,
		b: t.b * n + t.d * i,
		c: t.c * n - t.a * i,
		d: t.d * n - t.b * i,
		tx: t.tx,
		ty: t.ty
	}
};
cc.affineTransformConcat = function(t, e) {
	return {
		a: t.a * e.a + t.b * e.c,
		b: t.a * e.b + t.b * e.d,
		c: t.c * e.a + t.d * e.c,
		d: t.c * e.b + t.d * e.d,
		tx: t.tx * e.a + t.ty * e.c + e.tx,
		ty: t.tx * e.b + t.ty * e.d + e.ty
	}
};
cc.affineTransformEqualToTransform = function(t, e) {
	return t.a === e.a && t.b === e.b && t.c === e.c && t.d === e.d && t.tx === e.tx && t.ty === e.ty
};
cc.affineTransformInvert = function(t) {
	var e = 1 / (t.a * t.d - t.b * t.c);
	return {
		a: e * t.d,
		b: -e * t.b,
		c: -e * t.c,
		d: e * t.a,
		tx: e * (t.c * t.ty - t.d * t.tx),
		ty: e * (t.b * t.tx - t.a * t.ty)
	}
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function(t) {
	return cc.p(-t.x, -t.y)
};
cc.pAdd = function(t, e) {
	return cc.p(t.x + e.x, t.y + e.y)
};
cc.pSub = function(t, e) {
	return cc.p(t.x - e.x, t.y - e.y)
};
cc.pMult = function(t, e) {
	return cc.p(t.x * e, t.y * e)
};
cc.pMidpoint = function(t, e) {
	return cc.pMult(cc.pAdd(t, e), .5)
};
cc.pDot = function(t, e) {
	return t.x * e.x + t.y * e.y
};
cc.pCross = function(t, e) {
	return t.x * e.y - t.y * e.x
};
cc.pPerp = function(t) {
	return cc.p(-t.y, t.x)
};
cc.pRPerp = function(t) {
	return cc.p(t.y, -t.x)
};
cc.pProject = function(t, e) {
	return cc.pMult(e, cc.pDot(t, e) / cc.pDot(e, e))
};
cc.pRotate = function(t, e) {
	return cc.p(t.x * e.x - t.y * e.y, t.x * e.y + t.y * e.x)
};
cc.pUnrotate = function(t, e) {
	return cc.p(t.x * e.x + t.y * e.y, t.y * e.x - t.x * e.y)
};
cc.pLengthSQ = function(t) {
	return cc.pDot(t, t)
};
cc.pDistanceSQ = function(t, e) {
	return cc.pLengthSQ(cc.pSub(t, e))
};
cc.pLength = function(t) {
	return Math.sqrt(cc.pLengthSQ(t))
};
cc.pDistance = function(t, e) {
	return cc.pLength(cc.pSub(t, e))
};
cc.pNormalize = function(t) {
	return cc.pMult(t, 1 / cc.pLength(t))
};
cc.pForAngle = function(t) {
	return cc.p(Math.cos(t), Math.sin(t))
};
cc.pToAngle = function(t) {
	return Math.atan2(t.y, t.x)
};
cc.clampf = function(t, e, i) {
	if (e > i) {
		var n = e;
		e = i;
		i = n
	}
	return t < e ? e : t < i ? t : i
};
cc.pClamp = function(t, e, i) {
	return cc.p(cc.clampf(t.x, e.x, i.x), cc.clampf(t.y, e.y, i.y))
};
cc.pFromSize = function(t) {
	return cc.p(t.width, t.height)
};
cc.pCompOp = function(t, e) {
	return cc.p(e(t.x), e(t.y))
};
cc.pLerp = function(t, e, i) {
	return cc.pAdd(cc.pMult(t, 1 - i), cc.pMult(e, i))
};
cc.pFuzzyEqual = function(t, e, i) {
	return t.x - i <= e.x && e.x <= t.x + i && t.y - i <= e.y && e.y <= t.y + i ? !0 : !1
};
cc.pCompMult = function(t, e) {
	return cc.p(t.x * e.x, t.y * e.y)
};
cc.pAngleSigned = function(t, e) {
	var i = cc.pNormalize(t),
		n = cc.pNormalize(e),
		i = Math.atan2(i.x * n.y - i.y * n.x, cc.pDot(i, n));
	return Math.abs(i) < cc.POINT_EPSILON ? 0 : i
};
cc.pAngle = function(t, e) {
	var i = Math.acos(cc.pDot(cc.pNormalize(t), cc.pNormalize(e)));
	return Math.abs(i) < cc.POINT_EPSILON ? 0 : i
};
cc.pRotateByAngle = function(t, e, i) {
	t = cc.pSub(t, e);
	var n = Math.cos(i);
	i = Math.sin(i);
	var r = t.x;
	t.x = r * n - t.y * i + e.x;
	t.y = r * i + t.y * n + e.y;
	return t
};
cc.pLineIntersect = function(t, e, i, n, r) {
	if (t.x == e.x && t.y == e.y || i.x == n.x && i.y == n.y) return !1;
	var c = e.x - t.x;
	e = e.y - t.y;
	var s = n.x - i.x;
	n = n.y - i.y;
	var o = t.x - i.x;
	t = t.y - i.y;
	i = n * c - s * e;
	r.x = s * t - n * o;
	r.y = c * t - e * o;
	if (0 == i) return 0 == r.x || 0 == r.y ? !0 : !1;
	r.x /= i;
	r.y /= i;
	return !0
};
cc.pSegmentIntersect = function(t, e, i, n) {
	var r = cc.p(0, 0);
	return cc.pLineIntersect(t, e, i, n, r) && 0 <= r.x && 1 >= r.x && 0 <= r.y && 1 >= r.y ? !0 : !1
};
cc.pIntersectPoint = function(t, e, i, n) {
	var r = cc.p(0, 0);
	return cc.pLineIntersect(t, e, i, n, r) ? (i = cc.p(0, 0), i.x = t.x + r.x * (e.x - t.x), i.y = t.y + r.x * (e.y - t.y), i) : cc.p(0, 0)
};
cc.pSameAs = function(t, e) {
	return null != t && null != e ? t.x == e.x && t.y == e.y : !1
};
cc.pZeroIn = function(t) {
	t.x = 0;
	t.y = 0
};
cc.pIn = function(t, e) {
	t.x = e.x;
	t.y = e.y
};
cc.pMultIn = function(t, e) {
	t.x *= e;
	t.y *= e
};
cc.pSubIn = function(t, e) {
	t.x -= e.x;
	t.y -= e.y
};
cc.pAddIn = function(t, e) {
	t.x += e.x;
	t.y += e.y
};
cc.pNormalizeIn = function(t) {
	cc.pMultIn(t, 1 / Math.sqrt(t.x * t.x + t.y * t.y))
};
cc.vertexLineToPolygon = function(t, e, i, n, r) {
	r += n;
	if (!(1 >= r)) {
		e *= .5;
		for (var c, s = r - 1, o = n; o < r; o++) {
			c = 2 * o;
			var a = cc.p(t[2 * o], t[2 * o + 1]),
				h;
			if (0 === o) h = cc.pPerp(cc.pNormalize(cc.pSub(a, cc.p(t[2 * (o + 1)], t[2 * (o + 1) + 1]))));
			else if (o === s) h = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(t[2 * (o - 1)], t[2 * (o - 1) + 1]), a)));
			else {
				h = cc.p(t[2 * (o - 1)], t[2 * (o - 1) + 1]);
				var l = cc.p(t[2 * (o + 1)], t[2 * (o + 1) + 1]),
					u = cc.pNormalize(cc.pSub(l, a)),
					d = cc.pNormalize(cc.pSub(h, a)),
					_ = Math.acos(cc.pDot(u, d));
				h = _ < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(u, d))) : _ < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(u, d)) : cc.pPerp(cc.pNormalize(cc.pSub(l, h)))
			}
			h = cc.pMult(h, e);
			i[2 * c] = a.x + h.x;
			i[2 * c + 1] = a.y + h.y;
			i[2 * (c + 1)] = a.x - h.x;
			i[2 * (c + 1) + 1] = a.y - h.y
		}
		for (o = 0 == n ? 0 : n - 1; o < s; o++) {
			c = 2 * o;
			t = c + 2;
			e = cc.vertex2(i[2 * c], i[2 * c + 1]);
			r = cc.vertex2(i[2 * (c + 1)], i[2 * (c + 1) + 1]);
			c = cc.vertex2(i[2 * t], i[2 * t]);
			n = cc.vertex2(i[2 * (t + 1)], i[2 * (t + 1) + 1]);
			e = !cc.vertexLineIntersect(e.x, e.y, n.x, n.y, r.x, r.y, c.x, c.y);
			if (!e.isSuccess && (0 > e.value || 1 < e.value)) e.isSuccess = !0;
			e.isSuccess && (i[2 * t] = n.x, i[2 * t + 1] = n.y, i[2 * (t + 1)] = c.x, i[2 * (t + 1) + 1] = c.y)
		}
	}
};
cc.vertexLineIntersect = function(t, e, i, n, r, c, s, o) {
	if (t == i && e == n || r == s && c == o) return {
		isSuccess: !1,
		value: 0
	};
	i -= t;
	n -= e;
	r -= t;
	c -= e;
	s -= t;
	o -= e;
	t = Math.sqrt(i * i + n * n);
	i /= t;
	n /= t;
	e = r * i + c * n;
	c = c * i - r * n;
	r = e;
	e = s * i + o * n;
	o = o * i - s * n;
	s = e;
	return c == o ? {
		isSuccess: !1,
		value: 0
	} : {
		isSuccess: !0,
		value: (s + (r - s) * o / (o - c)) / t
	}
};
cc.vertexListIsClockwise = function(t) {
	for (var e = 0, i = t.length; e < i; e++) {
		var n = t[(e + 1) % i],
			r = t[(e + 2) % i];
		if (0 < cc.pCross(cc.pSub(n, t[e]), cc.pSub(r, n))) return !1
	}
	return !0
};
cc.CGAffineToGL = function(t, e) {
	e[2] = e[3] = e[6] = e[7] = e[8] = e[9] = e[11] = e[14] = 0;
	e[10] = e[15] = 1;
	e[0] = t.a;
	e[4] = t.c;
	e[12] = t.tx;
	e[1] = t.b;
	e[5] = t.d;
	e[13] = t.ty
};
cc.GLToCGAffine = function(t, e) {
	e.a = t[0];
	e.c = t[4];
	e.tx = t[12];
	e.b = t[1];
	e.d = t[5];
	e.ty = t[13]
};
cc.Touch = cc.Class.extend({
	_point: null,
	_prevPoint: null,
	_id: 0,
	_startPointCaptured: !1,
	_startPoint: null,
	ctor: function(t, e, i) {
		this._point = cc.p(t || 0, e || 0);
		this._id = i || 0
	},
	getLocation: function() {
		return {
			x: this._point.x,
			y: this._point.y
		}
	},
	getLocationX: function() {
		return this._point.x
	},
	getLocationY: function() {
		return this._point.y
	},
	getPreviousLocation: function() {
		return {
			x: this._prevPoint.x,
			y: this._prevPoint.y
		}
	},
	getStartLocation: function() {
		return {
			x: this._startPoint.x,
			y: this._startPoint.y
		}
	},
	getDelta: function() {
		return cc.pSub(this._point, this._prevPoint)
	},
	getLocationInView: function() {
		return {
			x: this._point.x,
			y: this._point.y
		}
	},
	getPreviousLocationInView: function() {
		return {
			x: this._prevPoint.x,
			y: this._prevPoint.y
		}
	},
	getStartLocationInView: function() {
		return {
			x: this._startPoint.x,
			y: this._startPoint.y
		}
	},
	getID: function() {
		return this._id
	},
	getId: function() {
		cc.log("getId is deprecated. Please use getID instead.");
		return this._id
	},
	setTouchInfo: function(t, e, i) {
		this._prevPoint = this._point;
		this._point = cc.p(e || 0, i || 0);
		this._id = t;
		this._startPointCaptured || (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
	},
	_setPoint: function(t, e) {
		void 0 === e ? (this._point.x = t.x, this._point.y = t.y) : (this._point.x = t, this._point.y = e)
	},
	_setPrevPoint: function(t, e) {
		this._prevPoint = void 0 === e ? cc.p(t.x, t.y) : cc.p(t || 0, e || 0)
	}
});
cc.Event = cc.Class.extend({
	_type: 0,
	_isStopped: !1,
	_currentTarget: null,
	_setCurrentTarget: function(t) {
		this._currentTarget = t
	},
	ctor: function(t) {
		this._type = t
	},
	getType: function() {
		return this._type
	},
	stopPropagation: function() {
		this._isStopped = !0
	},
	isStopped: function() {
		return this._isStopped
	},
	getCurrentTarget: function() {
		return this._currentTarget
	}
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.CUSTOM = 4;
cc.EventCustom = cc.Event.extend({
	_eventName: null,
	_userData: null,
	ctor: function(t) {
		cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
		this._eventName = t
	},
	setUserData: function(t) {
		this._userData = t
	},
	getUserData: function() {
		return this._userData
	},
	getEventName: function() {
		return this._eventName
	}
});
cc.EventMouse = cc.Event.extend({
	_eventType: 0,
	_button: 0,
	_x: 0,
	_y: 0,
	_prevX: 0,
	_prevY: 0,
	_scrollX: 0,
	_scrollY: 0,
	ctor: function(t) {
		cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
		this._eventType = t
	},
	setScrollData: function(t, e) {
		this._scrollX = t;
		this._scrollY = e
	},
	getScrollX: function() {
		return this._scrollX
	},
	getScrollY: function() {
		return this._scrollY
	},
	setLocation: function(t, e) {
		this._x = t;
		this._y = e
	},
	getLocation: function() {
		return {
			x: this._x,
			y: this._y
		}
	},
	getLocationInView: function() {
		return {
			x: this._x,
			y: cc.view._designResolutionSize.height - this._y
		}
	},
	_setPrevCursor: function(t, e) {
		this._prevX = t;
		this._prevY = e
	},
	getDelta: function() {
		return {
			x: this._x - this._prevX,
			y: this._y - this._prevY
		}
	},
	getDeltaX: function() {
		return this._x - this._prevX
	},
	getDeltaY: function() {
		return this._y - this._prevY
	},
	setButton: function(t) {
		this._button = t
	},
	getButton: function() {
		return this._button
	},
	getLocationX: function() {
		return this._x
	},
	getLocationY: function() {
		return this._y
	}
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
	_eventCode: 0,
	_touches: null,
	ctor: function(t) {
		cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
		this._touches = t || []
	},
	getEventCode: function() {
		return this._eventCode
	},
	getTouches: function() {
		return this._touches
	},
	_setEventCode: function(t) {
		this._eventCode = t
	},
	_setTouches: function(t) {
		this._touches = t
	}
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {
	BEGAN: 0,
	MOVED: 1,
	ENDED: 2,
	CANCELLED: 3
};
cc.EventListener = cc.Class.extend({
	_onEvent: null,
	_type: 0,
	_listenerID: null,
	_registered: !1,
	_fixedPriority: 0,
	_node: null,
	_paused: !0,
	_isEnabled: !0,
	ctor: function(t, e, i) {
		this._onEvent = i;
		this._type = t || 0;
		this._listenerID = e || ""
	},
	_setPaused: function(t) {
		this._paused = t
	},
	_isPaused: function() {
		return this._paused
	},
	_setRegistered: function(t) {
		this._registered = t
	},
	_isRegistered: function() {
		return this._registered
	},
	_getType: function() {
		return this._type
	},
	_getListenerID: function() {
		return this._listenerID
	},
	_setFixedPriority: function(t) {
		this._fixedPriority = t
	},
	_getFixedPriority: function() {
		return this._fixedPriority
	},
	_setSceneGraphPriority: function(t) {
		this._node = t
	},
	_getSceneGraphPriority: function() {
		return this._node
	},
	checkAvailable: function() {
		return null != this._onEvent
	},
	clone: function() {
		return null
	},
	setEnabled: function(t) {
		this._isEnabled = t
	},
	isEnabled: function() {
		return this._isEnabled
	},
	retain: function() {},
	release: function() {}
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.CUSTOM = 6;
cc._EventListenerCustom = cc.EventListener.extend({
	_onCustomEvent: null,
	ctor: function(t, e) {
		this._onCustomEvent = e;
		var i = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, t, function(t) {
			null != i._onCustomEvent && i._onCustomEvent(t)
		})
	},
	checkAvailable: function() {
		return cc.EventListener.prototype.checkAvailable.call(this) && null != this._onCustomEvent
	},
	clone: function() {
		return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
	}
});
cc._EventListenerCustom.create = function(t, e) {
	return new cc._EventListenerCustom(t, e)
};
cc._EventListenerMouse = cc.EventListener.extend({
	onMouseDown: null,
	onMouseUp: null,
	onMouseMove: null,
	onMouseScroll: null,
	ctor: function() {
		var t = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(e) {
			var i = cc.EventMouse;
			switch (e._eventType) {
			case i.DOWN:
				if (t.onMouseDown) t.onMouseDown(e);
				break;
			case i.UP:
				if (t.onMouseUp) t.onMouseUp(e);
				break;
			case i.MOVE:
				if (t.onMouseMove) t.onMouseMove(e);
				break;
			case i.SCROLL:
				if (t.onMouseScroll) t.onMouseScroll(e)
			}
		})
	},
	clone: function() {
		var t = new cc._EventListenerMouse;
		t.onMouseDown = this.onMouseDown;
		t.onMouseUp = this.onMouseUp;
		t.onMouseMove = this.onMouseMove;
		t.onMouseScroll = this.onMouseScroll;
		return t
	},
	checkAvailable: function() {
		return !0
	}
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function() {
	return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
	_claimedTouches: null,
	swallowTouches: !1,
	onTouchBegan: null,
	onTouchMoved: null,
	onTouchEnded: null,
	onTouchCancelled: null,
	ctor: function() {
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
		this._claimedTouches = []
	},
	setSwallowTouches: function(t) {
		this.swallowTouches = t
	},
	clone: function() {
		var t = new cc._EventListenerTouchOneByOne;
		t.onTouchBegan = this.onTouchBegan;
		t.onTouchMoved = this.onTouchMoved;
		t.onTouchEnded = this.onTouchEnded;
		t.onTouchCancelled = this.onTouchCancelled;
		t.swallowTouches = this.swallowTouches;
		return t
	},
	checkAvailable: function() {
		return !this.onTouchBegan ? (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1) : !0
	}
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function() {
	return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
	onTouchesBegan: null,
	onTouchesMoved: null,
	onTouchesEnded: null,
	onTouchesCancelled: null,
	ctor: function() {
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
	},
	clone: function() {
		var t = new cc._EventListenerTouchAllAtOnce;
		t.onTouchesBegan = this.onTouchesBegan;
		t.onTouchesMoved = this.onTouchesMoved;
		t.onTouchesEnded = this.onTouchesEnded;
		t.onTouchesCancelled = this.onTouchesCancelled;
		return t
	},
	checkAvailable: function() {
		return null == this.onTouchesBegan && null == this.onTouchesMoved && null == this.onTouchesEnded && null == this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
	}
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function() {
	return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function(t) {
	cc.assert(t && t.event, cc._LogInfos.EventListener_create);
	var e = t.event;
	delete t.event;
	var i = null;
	e === cc.EventListener.TOUCH_ONE_BY_ONE ? i = new cc._EventListenerTouchOneByOne : e === cc.EventListener.TOUCH_ALL_AT_ONCE ? i = new cc._EventListenerTouchAllAtOnce : e === cc.EventListener.MOUSE ? i = new cc._EventListenerMouse : e === cc.EventListener.CUSTOM ? (i = new cc._EventListenerCustom(t.eventName, t.callback), delete t.eventName, delete t.callback) : e === cc.EventListener.KEYBOARD ? i = new cc._EventListenerKeyboard : e === cc.EventListener.ACCELERATION && (i = new cc._EventListenerAcceleration(t.callback), delete t.callback);
	for (var n in t) i[n] = t[n];
	return i
};
cc._EventListenerVector = cc.Class.extend({
	_fixedListeners: null,
	_sceneGraphListeners: null,
	gt0Index: 0,
	ctor: function() {
		this._fixedListeners = [];
		this._sceneGraphListeners = []
	},
	size: function() {
		return this._fixedListeners.length + this._sceneGraphListeners.length
	},
	empty: function() {
		return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
	},
	push: function(t) {
		0 == t._getFixedPriority() ? this._sceneGraphListeners.push(t) : this._fixedListeners.push(t)
	},
	clearSceneGraphListeners: function() {
		this._sceneGraphListeners.length = 0
	},
	clearFixedListeners: function() {
		this._fixedListeners.length = 0
	},
	clear: function() {
		this._sceneGraphListeners.length = 0;
		this._fixedListeners.length = 0
	},
	getFixedPriorityListeners: function() {
		return this._fixedListeners
	},
	getSceneGraphPriorityListeners: function() {
		return this._sceneGraphListeners
	}
});
cc.__getListenerID = function(t) {
	var e = cc.Event,
		i = t.getType();
	if (i === e.ACCELERATION) return cc._EventListenerAcceleration.LISTENER_ID;
	if (i === e.CUSTOM) return t.getEventName();
	if (i === e.KEYBOARD) return cc._EventListenerKeyboard.LISTENER_ID;
	if (i === e.MOUSE) return cc._EventListenerMouse.LISTENER_ID;
	i === e.TOUCH && cc.log(cc._LogInfos.__getListenerID);
	return ""
};
cc.eventManager = {
	DIRTY_NONE: 0,
	DIRTY_FIXED_PRIORITY: 1,
	DIRTY_SCENE_GRAPH_PRIORITY: 2,
	DIRTY_ALL: 3,
	_listenersMap: {},
	_priorityDirtyFlagMap: {},
	_nodeListenersMap: {},
	_nodePriorityMap: {},
	_globalZOrderNodeMap: {},
	_toAddedListeners: [],
	_dirtyNodes: [],
	_inDispatch: 0,
	_isEnabled: !1,
	_nodePriorityIndex: 0,
	_internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
	_setDirtyForNode: function(t) {
		null != this._nodeListenersMap[t.__instanceId] && this._dirtyNodes.push(t);
		t = t.getChildren();
		for (var e = 0, i = t.length; e < i; e++) this._setDirtyForNode(t[e])
	},
	pauseTarget: function(t, e) {
		var i = this._nodeListenersMap[t.__instanceId],
			n, r;
		if (i) {
			n = 0;
			for (r = i.length; n < r; n++) i[n]._setPaused(!0)
		}
		if (!0 === e) {
			i = t.getChildren();
			n = 0;
			for (r = i.length; n < r; n++) this.pauseTarget(i[n], !0)
		}
	},
	resumeTarget: function(t, e) {
		var i = this._nodeListenersMap[t.__instanceId],
			n, r;
		if (i) {
			n = 0;
			for (r = i.length; n < r; n++) i[n]._setPaused(!1)
		}
		this._setDirtyForNode(t);
		if (!0 === e) {
			i = t.getChildren();
			n = 0;
			for (r = i.length; n < r; n++) this.resumeTarget(i[n], !0)
		}
	},
	_addListener: function(t) {
		0 === this._inDispatch ? this._forceAddEventListener(t) : this._toAddedListeners.push(t)
	},
	_forceAddEventListener: function(t) {
		var e = t._getListenerID(),
			i = this._listenersMap[e];
		i || (i = new cc._EventListenerVector, this._listenersMap[e] = i);
		i.push(t);
		0 == t._getFixedPriority() ? (this._setDirty(e, this.DIRTY_SCENE_GRAPH_PRIORITY), e = t._getSceneGraphPriority(), null == e && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(e, t), e.isRunning() && this.resumeTarget(e)) : this._setDirty(e, this.DIRTY_FIXED_PRIORITY)
	},
	_getListeners: function(t) {
		return this._listenersMap[t]
	},
	_updateDirtyFlagForSceneGraph: function() {
		if (0 != this._dirtyNodes.length) {
			for (var t = this._dirtyNodes, e, i, n = this._nodeListenersMap, r = 0, c = t.length; r < c; r++) if (e = n[t[r].__instanceId]) for (var s = 0, o = e.length; s < o; s++)(i = e[s]) && this._setDirty(i._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
			this._dirtyNodes.length = 0
		}
	},
	_removeAllListenersInVector: function(t) {
		if (t) for (var e, i = 0; i < t.length;) e = t[i], e._setRegistered(!1), null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(t, e) : ++i
	},
	_removeListenersForListenerID: function(t) {
		var e = this._listenersMap[t];
		if (e) {
			var i = e.getFixedPriorityListeners(),
				n = e.getSceneGraphPriorityListeners();
			this._removeAllListenersInVector(n);
			this._removeAllListenersInVector(i);
			delete this._priorityDirtyFlagMap[t];
			this._inDispatch || (e.clear(), delete this._listenersMap[t])
		}
		i = this._toAddedListeners;
		for (e = 0; e < i.length;)(n = i[e]) && n._getListenerID() == t ? cc.arrayRemoveObject(i, n) : ++e
	},
	_sortEventListeners: function(t) {
		var e = this.DIRTY_NONE,
			i = this._priorityDirtyFlagMap;
		i[t] && (e = i[t]);
		e != this.DIRTY_NONE && (i[t] = this.DIRTY_NONE, e & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(t), e & this.DIRTY_SCENE_GRAPH_PRIORITY && ((e = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(t, e) : i[t] = this.DIRTY_SCENE_GRAPH_PRIORITY))
	},
	_sortListenersOfSceneGraphPriority: function(t, e) {
		var i = this._getListeners(t);
		if (i) {
			var n = i.getSceneGraphPriorityListeners();
			n && 0 !== n.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(e, !0), i.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
		}
	},
	_sortEventListenersOfSceneGraphPriorityDes: function(t, e) {
		var i = cc.eventManager._nodePriorityMap;
		return !t || !e || !t._getSceneGraphPriority() || !e._getSceneGraphPriority() ? -1 : i[e._getSceneGraphPriority().__instanceId] - i[t._getSceneGraphPriority().__instanceId]
	},
	_sortListenersOfFixedPriority: function(t) {
		if (t = this._listenersMap[t]) {
			var e = t.getFixedPriorityListeners();
			if (e && 0 !== e.length) {
				e.sort(this._sortListenersOfFixedPriorityAsc);
				for (var i = 0, n = e.length; i < n && !(0 <= e[i]._getFixedPriority());)++i;
				t.gt0Index = i
			}
		}
	},
	_sortListenersOfFixedPriorityAsc: function(t, e) {
		return t._getFixedPriority() - e._getFixedPriority()
	},
	_onUpdateListeners: function(t) {
		if (t = this._listenersMap[t]) {
			var e = t.getFixedPriorityListeners(),
				i = t.getSceneGraphPriorityListeners(),
				n, r;
			if (i) for (n = 0; n < i.length;) r = i[n], r._isRegistered() ? ++n : cc.arrayRemoveObject(i, r);
			if (e) for (n = 0; n < e.length;) r = e[n], r._isRegistered() ? ++n : cc.arrayRemoveObject(e, r);
			i && 0 === i.length && t.clearSceneGraphListeners();
			e && 0 === e.length && t.clearFixedListeners()
		}
	},
	_updateListeners: function(t) {
		var e = this._inDispatch;
		cc.assert(0 < e, cc._LogInfos.EventManager__updateListeners);
		t.getType() == cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(t));
		if (!(1 < e)) {
			cc.assert(1 == e, cc._LogInfos.EventManager__updateListeners_2);
			t = this._listenersMap;
			var e = this._priorityDirtyFlagMap,
				i;
			for (i in t) t[i].empty() && (delete e[i], delete t[i]);
			i = this._toAddedListeners;
			if (0 !== i.length) {
				t = 0;
				for (e = i.length; t < e; t++) this._forceAddEventListener(i[t]);
				this._toAddedListeners.length = 0
			}
		}
	},
	_onTouchEventCallback: function(t, e) {
		if (!t._isRegistered) return !1;
		var i = e.event,
			n = e.selTouch;
		i._setCurrentTarget(t._node);
		var r = !1,
			c, s = i.getEventCode(),
			o = cc.EventTouch.EventCode;
		if (s == o.BEGAN) t.onTouchBegan && (r = t.onTouchBegan(n, i)) && t._registered && t._claimedTouches.push(n);
		else if (0 < t._claimedTouches.length && -1 != (c = t._claimedTouches.indexOf(n))) if (r = !0, s === o.MOVED && t.onTouchMoved) t.onTouchMoved(n, i);
		else if (s === o.ENDED) {
			if (t.onTouchEnded) t.onTouchEnded(n, i);
			t._registered && t._claimedTouches.splice(c, 1)
		} else if (s === o.CANCELLED) {
			if (t.onTouchCancelled) t.onTouchCancelled(n, i);
			t._registered && t._claimedTouches.splice(c, 1)
		}
		return i.isStopped() ? (cc.eventManager._updateListeners(i), !0) : r && t._registered && t.swallowTouches ? (e.needsMutableSet && e.touches.splice(n, 1), !0) : !1
	},
	_dispatchTouchEvent: function(t) {
		this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
		this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
		var e = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
			i = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
		if (!(null == e && null == i)) {
			var n = t.getTouches(),
				r = cc.copyArray(n),
				c = {
					event: t,
					needsMutableSet: e && i,
					touches: r,
					selTouch: null
				};
			if (e) for (var s = 0; s < n.length; s++) if (c.selTouch = n[s], this._dispatchEventToListeners(e, this._onTouchEventCallback, c), t.isStopped()) return;
			if (i && 0 < r.length && (this._dispatchEventToListeners(i, this._onTouchesEventCallback, {
				event: t,
				touches: r
			}), t.isStopped())) return;
			this._updateListeners(t)
		}
	},
	_onTouchesEventCallback: function(t, e) {
		if (!t._registered) return !1;
		var i = cc.EventTouch.EventCode,
			n = e.event,
			r = e.touches,
			c = n.getEventCode();
		n._setCurrentTarget(t._node);
		if (c == i.BEGAN && t.onTouchesBegan) t.onTouchesBegan(r, n);
		else if (c == i.MOVED && t.onTouchesMoved) t.onTouchesMoved(r, n);
		else if (c == i.ENDED && t.onTouchesEnded) t.onTouchesEnded(r, n);
		else if (c == i.CANCELLED && t.onTouchesCancelled) t.onTouchesCancelled(r, n);
		return n.isStopped() ? (cc.eventManager._updateListeners(n), !0) : !1
	},
	_associateNodeAndEventListener: function(t, e) {
		var i = this._nodeListenersMap[t.__instanceId];
		i || (i = [], this._nodeListenersMap[t.__instanceId] = i);
		i.push(e)
	},
	_dissociateNodeAndEventListener: function(t, e) {
		var i = this._nodeListenersMap[t.__instanceId];
		i && (cc.arrayRemoveObject(i, e), 0 === i.length && delete this._nodeListenersMap[t.__instanceId])
	},
	_dispatchEventToListeners: function(t, e, i) {
		var n = !1,
			r = t.getFixedPriorityListeners(),
			c = t.getSceneGraphPriorityListeners(),
			s = 0,
			o;
		if (r && 0 !== r.length) for (; s < t.gt0Index; ++s) if (o = r[s], o.isEnabled() && !o._isPaused() && o._isRegistered() && e(o, i)) {
			n = !0;
			break
		}
		if (c && !n) for (t = 0; t < c.length; t++) if (o = c[t], o.isEnabled() && !o._isPaused() && o._isRegistered() && e(o, i)) {
			n = !0;
			break
		}
		if (r && !n) for (; s < r.length && !(o = r[s], o.isEnabled() && !o._isPaused() && o._isRegistered() && e(o, i)); ++s);
	},
	_setDirty: function(t, e) {
		var i = this._priorityDirtyFlagMap;
		i[t] = null == i[t] ? e : e | i[t]
	},
	_visitTarget: function(t, e) {
		var i = t.getChildren(),
			n = 0,
			r = i.length,
			c = this._globalZOrderNodeMap,
			s = this._nodeListenersMap;
		if (0 < r) {
			for (var o; n < r; n++) if ((o = i[n]) && 0 > o.getLocalZOrder()) this._visitTarget(o, !1);
			else break;
			null != s[t.__instanceId] && (c[t.getGlobalZOrder()] || (c[t.getGlobalZOrder()] = []), c[t.getGlobalZOrder()].push(t.__instanceId));
			for (; n < r; n++)(o = i[n]) && this._visitTarget(o, !1)
		} else null != s[t.__instanceId] && (c[t.getGlobalZOrder()] || (c[t.getGlobalZOrder()] = []), c[t.getGlobalZOrder()].push(t.__instanceId));
		if (e) {
			var i = [],
				a;
			for (a in c) i.push(a);
			i.sort(this._sortNumberAsc);
			a = i.length;
			o = this._nodePriorityMap;
			for (n = 0; n < a; n++) {
				r = c[i[n]];
				for (s = 0; s < r.length; s++) o[r[s]] = ++this._nodePriorityIndex
			}
			this._globalZOrderNodeMap = {}
		}
	},
	_sortNumberAsc: function(t, e) {
		return t - e
	},
	addListener: function(t, e) {
		cc.assert(t && e, cc._LogInfos.eventManager_addListener_2);
		if (t instanceof cc.EventListener) {
			if (t._isRegistered()) {
				cc.log(cc._LogInfos.eventManager_addListener_4);
				return
			}
		} else cc.assert(!cc.isNumber(e), cc._LogInfos.eventManager_addListener_3), t = cc.EventListener.create(t);
		if (t.checkAvailable()) {
			if (cc.isNumber(e)) {
				if (0 == e) {
					cc.log(cc._LogInfos.eventManager_addListener);
					return
				}
				t._setSceneGraphPriority(null);
				t._setFixedPriority(e);
				t._setRegistered(!0);
				t._setPaused(!1)
			} else t._setSceneGraphPriority(e), t._setFixedPriority(0), t._setRegistered(!0);
			this._addListener(t);
			return t
		}
	},
	addCustomListener: function(t, e) {
		var i = new cc._EventListenerCustom(t, e);
		this.addListener(i, 1);
		return i
	},
	removeListener: function(t) {
		if (null != t) {
			var e, i = this._listenersMap,
				n;
			for (n in i) {
				var r = i[n],
					c = r.getFixedPriorityListeners();
				e = r.getSceneGraphPriorityListeners();
				(e = this._removeListenerInVector(e, t)) ? this._setDirty(t._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (e = this._removeListenerInVector(c, t)) && this._setDirty(t._getListenerID(), this.DIRTY_FIXED_PRIORITY);
				r.empty() && (delete this._priorityDirtyFlagMap[t._getListenerID()], delete i[n]);
				if (e) break
			}
			if (!e) {
				i = this._toAddedListeners;
				n = 0;
				for (r = i.length; n < r; n++) if (c = i[n], c == t) {
					cc.arrayRemoveObject(i, c);
					break
				}
			}
		}
	},
	_removeListenerInVector: function(t, e) {
		if (null == t) return !1;
		for (var i = 0, n = t.length; i < n; i++) {
			var r = t[i];
			if (r == e) return r._setRegistered(!1), null != r._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(r._getSceneGraphPriority(), r), r._setSceneGraphPriority(null)), 0 == this._inDispatch && cc.arrayRemoveObject(t, r), !0
		}
		return !1
	},
	removeListeners: function(t, e) {
		if (t instanceof cc.Node) {
			delete this._nodePriorityMap[t.__instanceId];
			cc.arrayRemoveObject(this._dirtyNodes, t);
			var i = this._nodeListenersMap[t.__instanceId];
			if (i) {
				for (var n = cc.copyArray(i), i = 0; i < n.length; i++) this.removeListener(n[i]);
				n.length = 0
			}
			n = this._toAddedListeners;
			for (i = 0; i < n.length;) {
				var r = n[i];
				r._getSceneGraphPriority() == t ? (r._setSceneGraphPriority(null), r._setRegistered(!1), n.splice(i, 1)) : ++i
			}
			if (!0 === e) {
				n = t.getChildren();
				i = 0;
				for (r = n.length; i < r; i++) this.removeListeners(n[i], !0)
			}
		} else t == cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : t == cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : t == cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : t == cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : t == cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
	},
	removeCustomListeners: function(t) {
		this._removeListenersForListenerID(t)
	},
	removeAllListeners: function() {
		var t = this._listenersMap,
			e = this._internalCustomListenerIDs,
			i;
		for (i in t) - 1 === e.indexOf(i) && this._removeListenersForListenerID(i)
	},
	setPriority: function(t, e) {
		if (null != t) {
			var i = this._listenersMap,
				n;
			for (n in i) {
				var r = i[n].getFixedPriorityListeners();
				if (r && -1 != r.indexOf(t)) {
					null != t._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority);
					t._getFixedPriority() !== e && (t._setFixedPriority(e), this._setDirty(t._getListenerID(), this.DIRTY_FIXED_PRIORITY));
					break
				}
			}
		}
	},
	setEnabled: function(t) {
		this._isEnabled = t
	},
	isEnabled: function() {
		return this._isEnabled
	},
	dispatchEvent: function(t) {
		if (this._isEnabled) {
			this._updateDirtyFlagForSceneGraph();
			this._inDispatch++;
			if (!t || !t.getType) throw "event is undefined";
			if (t.getType() == cc.Event.TOUCH) this._dispatchTouchEvent(t);
			else {
				var e = cc.__getListenerID(t);
				this._sortEventListeners(e);
				e = this._listenersMap[e];
				null != e && this._dispatchEventToListeners(e, this._onListenerCallback, t);
				this._updateListeners(t)
			}
			this._inDispatch--
		}
	},
	_onListenerCallback: function(t, e) {
		e._setCurrentTarget(t._getSceneGraphPriority());
		t._onEvent(e);
		return e.isStopped()
	},
	dispatchCustomEvent: function(t, e) {
		var i = new cc.EventCustom(t);
		i.setUserData(e);
		this.dispatchEvent(i)
	}
};
cc.EventHelper = function() {};
cc.EventHelper.prototype = {
	constructor: cc.EventHelper,
	apply: function(t) {
		t.addEventListener = cc.EventHelper.prototype.addEventListener;
		t.hasEventListener = cc.EventHelper.prototype.hasEventListener;
		t.removeEventListener = cc.EventHelper.prototype.removeEventListener;
		t.dispatchEvent = cc.EventHelper.prototype.dispatchEvent
	},
	addEventListener: function(t, e, i) {
		void 0 === this._listeners && (this._listeners = {});
		var n = this._listeners;
		void 0 === n[t] && (n[t] = []);
		this.hasEventListener(t, e, i) || n[t].push({
			callback: e,
			eventTarget: i
		})
	},
	hasEventListener: function(t, e, i) {
		if (void 0 === this._listeners) return !1;
		var n = this._listeners;
		if (void 0 !== n[t]) {
			t = 0;
			for (var r = n.length; t < r; t++) {
				var c = n[t];
				if (c.callback == e && c.eventTarget == i) return !0
			}
		}
		return !1
	},
	removeEventListener: function(t, e) {
		if (void 0 !== this._listeners) {
			var i = this._listeners[t];
			if (void 0 !== i) for (var n = 0; n < i.length;) i[n].eventTarget == e ? i.splice(n, 1) : n++
		}
	},
	dispatchEvent: function(t, e) {
		if (void 0 !== this._listeners) {
			null == e && (e = !0);
			var i = this._listeners[t];
			if (void 0 !== i) {
				for (var n = [], r = i.length, c = 0; c < r; c++) n[c] = i[c];
				for (c = 0; c < r; c++) n[c].callback.call(n[c].eventTarget, this);
				e && (i.length = 0)
			}
		}
	}
};
cc.EventAcceleration = cc.Event.extend({
	_acc: null,
	ctor: function(t) {
		cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
		this._acc = t
	}
});
cc.EventKeyboard = cc.Event.extend({
	_keyCode: 0,
	_isPressed: !1,
	ctor: function(t, e) {
		cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
		this._keyCode = t;
		this._isPressed = e
	}
});
cc._EventListenerAcceleration = cc.EventListener.extend({
	_onAccelerationEvent: null,
	ctor: function(t) {
		this._onAccelerationEvent = t;
		var e = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(t) {
			e._onAccelerationEvent(t._acc, t)
		})
	},
	checkAvailable: function() {
		cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable);
		return !0
	},
	clone: function() {
		return new cc._EventListenerAcceleration(this._onAccelerationEvent)
	}
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function(t) {
	return new cc._EventListenerAcceleration(t)
};
cc._EventListenerKeyboard = cc.EventListener.extend({
	onKeyPressed: null,
	onKeyReleased: null,
	ctor: function() {
		var t = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(e) {
			if (e._isPressed) {
				if (t.onKeyPressed) t.onKeyPressed(e._keyCode, e)
			} else if (t.onKeyReleased) t.onKeyReleased(e._keyCode, e)
		})
	},
	clone: function() {
		var t = new cc._EventListenerKeyboard;
		t.onKeyPressed = this.onKeyPressed;
		t.onKeyReleased = this.onKeyReleased;
		return t
	},
	checkAvailable: function() {
		return null == this.onKeyPressed && null == this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
	}
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function() {
	return new cc._EventListenerKeyboard
};
cc.rendererCanvas = {
	childrenOrderDirty: !0,
	_transformNodePool: [],
	_renderCmds: [],
	_isCacheToCanvasOn: !1,
	_cacheToCanvasCmds: {},
	_cacheInstanceIds: [],
	_currentID: 0,
	getRenderCmd: function(t) {
		return t._createRenderCmd()
	},
	rendering: function(t) {
		var e = this._renderCmds,
			i, n = cc.view.getScaleX(),
			r = cc.view.getScaleY(),
			c = t || cc._renderContext;
		t = 0;
		for (i = e.length; t < i; t++) e[t].rendering(c, n, r)
	},
	_renderingToCacheCanvas: function(t, e, i, n) {
		t || cc.log("The context of RenderTexture is invalid.");
		i = cc.isUndefined(i) ? 1 : i;
		n = cc.isUndefined(n) ? 1 : n;
		e = e || this._currentID;
		var r = this._cacheToCanvasCmds[e],
			c, s;
		c = 0;
		for (s = r.length; c < s; c++) r[c].rendering(t, i, n);
		r.length = 0;
		t = this._cacheInstanceIds;
		delete this._cacheToCanvasCmds[e];
		cc.arrayRemoveObject(t, e);
		0 === t.length ? this._isCacheToCanvasOn = !1 : this._currentID = t[t.length - 1]
	},
	_turnToCacheMode: function(t) {
		this._isCacheToCanvasOn = !0;
		t = t || 0;
		this._cacheToCanvasCmds[t] = []; - 1 === this._cacheInstanceIds.indexOf(t) && this._cacheInstanceIds.push(t);
		this._currentID = t
	},
	_turnToNormalMode: function() {
		this._isCacheToCanvasOn = !1
	},
	resetFlag: function() {
		this.childrenOrderDirty = !1;
		this._transformNodePool.length = 0
	},
	transform: function() {
		var t = this._transformNodePool;
		t.sort(this._sortNodeByLevelAsc);
		for (var e = 0, i = t.length; e < i; e++) 0 !== t[e]._dirtyFlag && t[e].updateStatus();
		t.length = 0
	},
	transformDirty: function() {
		return 0 < this._transformNodePool.length
	},
	_sortNodeByLevelAsc: function(t, e) {
		return t._curLevel - e._curLevel
	},
	pushDirtyNode: function(t) {
		this._transformNodePool.push(t)
	},
	clearRenderCommands: function() {
		this._renderCmds.length = 0
	},
	pushRenderCommand: function(t) {
		if (t._needDraw) if (this._isCacheToCanvasOn) {
			var e = this._cacheToCanvasCmds[this._currentID]; - 1 === e.indexOf(t) && e.push(t)
		} else - 1 === this._renderCmds.indexOf(t) && this._renderCmds.push(t)
	}
};
cc._renderType === cc._RENDER_TYPE_CANVAS && (cc.renderer = cc.rendererCanvas);
cc.rendererWebGL = {
	childrenOrderDirty: !0,
	_transformNodePool: [],
	_renderCmds: [],
	_isCacheToBufferOn: !1,
	_cacheToBufferCmds: {},
	_cacheInstanceIds: [],
	_currentID: 0,
	getRenderCmd: function(t) {
		return t._createRenderCmd()
	},
	rendering: function(t) {
		var e = this._renderCmds,
			i, n = t || cc._renderContext;
		t = 0;
		for (i = e.length; t < i; t++) e[t].rendering(n)
	},
	_turnToCacheMode: function(t) {
		this._isCacheToBufferOn = !0;
		t = t || 0;
		this._cacheToBufferCmds[t] = [];
		this._cacheInstanceIds.push(t);
		this._currentID = t
	},
	_turnToNormalMode: function() {
		this._isCacheToBufferOn = !1
	},
	_renderingToBuffer: function(t) {
		t = t || this._currentID;
		var e = this._cacheToBufferCmds[t],
			i, n, r = cc._renderContext,
			c = this._cacheInstanceIds;
		i = 0;
		for (n = e.length; i < n; i++) e[i].rendering(r);
		e.length = 0;
		delete this._cacheToBufferCmds[t];
		cc.arrayRemoveObject(c, t);
		0 === c.length ? this._isCacheToBufferOn = !1 : this._currentID = c[c.length - 1]
	},
	resetFlag: function() {
		this.childrenOrderDirty = !1;
		this._transformNodePool.length = 0
	},
	transform: function() {
		var t = this._transformNodePool;
		t.sort(this._sortNodeByLevelAsc);
		for (var e = 0, i = t.length; e < i; e++) t[e].updateStatus();
		t.length = 0
	},
	transformDirty: function() {
		return 0 < this._transformNodePool.length
	},
	_sortNodeByLevelAsc: function(t, e) {
		return t._curLevel - e._curLevel
	},
	pushDirtyNode: function(t) {
		this._transformNodePool.push(t)
	},
	clearRenderCommands: function() {
		this._renderCmds.length = 0
	},
	pushRenderCommand: function(t) {
		if (t._needDraw) if (this._isCacheToBufferOn) {
			var e = this._cacheToBufferCmds[this._currentID]; - 1 === e.indexOf(t) && e.push(t)
		} else - 1 === this._renderCmds.indexOf(t) && this._renderCmds.push(t)
	}
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.renderer = cc.rendererWebGL);
cc._tmp.PrototypeCCNode = function() {
	var t = cc.Node.prototype;
	cc.defineGetterSetter(t, "x", t.getPositionX, t.setPositionX);
	cc.defineGetterSetter(t, "y", t.getPositionY, t.setPositionY);
	cc.defineGetterSetter(t, "width", t._getWidth, t._setWidth);
	cc.defineGetterSetter(t, "height", t._getHeight, t._setHeight);
	cc.defineGetterSetter(t, "anchorX", t._getAnchorX, t._setAnchorX);
	cc.defineGetterSetter(t, "anchorY", t._getAnchorY, t._setAnchorY);
	cc.defineGetterSetter(t, "skewX", t.getSkewX, t.setSkewX);
	cc.defineGetterSetter(t, "skewY", t.getSkewY, t.setSkewY);
	cc.defineGetterSetter(t, "zIndex", t.getLocalZOrder, t.setLocalZOrder);
	cc.defineGetterSetter(t, "vertexZ", t.getVertexZ, t.setVertexZ);
	cc.defineGetterSetter(t, "rotation", t.getRotation, t.setRotation);
	cc.defineGetterSetter(t, "rotationX", t.getRotationX, t.setRotationX);
	cc.defineGetterSetter(t, "rotationY", t.getRotationY, t.setRotationY);
	cc.defineGetterSetter(t, "scale", t.getScale, t.setScale);
	cc.defineGetterSetter(t, "scaleX", t.getScaleX, t.setScaleX);
	cc.defineGetterSetter(t, "scaleY", t.getScaleY, t.setScaleY);
	cc.defineGetterSetter(t, "children", t.getChildren);
	cc.defineGetterSetter(t, "childrenCount", t.getChildrenCount);
	cc.defineGetterSetter(t, "parent", t.getParent, t.setParent);
	cc.defineGetterSetter(t, "visible", t.isVisible, t.setVisible);
	cc.defineGetterSetter(t, "running", t.isRunning);
	cc.defineGetterSetter(t, "ignoreAnchor", t.isIgnoreAnchorPointForPosition, t.ignoreAnchorPointForPosition);
	cc.defineGetterSetter(t, "actionManager", t.getActionManager, t.setActionManager);
	cc.defineGetterSetter(t, "scheduler", t.getScheduler, t.setScheduler);
	cc.defineGetterSetter(t, "shaderProgram", t.getShaderProgram, t.setShaderProgram);
	cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity);
	cc.defineGetterSetter(t, "opacityModifyRGB", t.isOpacityModifyRGB);
	cc.defineGetterSetter(t, "cascadeOpacity", t.isCascadeOpacityEnabled, t.setCascadeOpacityEnabled);
	cc.defineGetterSetter(t, "color", t.getColor, t.setColor);
	cc.defineGetterSetter(t, "cascadeColor", t.isCascadeColorEnabled, t.setCascadeColorEnabled)
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
	_localZOrder: 0,
	_globalZOrder: 0,
	_vertexZ: 0,
	_rotationX: 0,
	_rotationY: 0,
	_scaleX: 1,
	_scaleY: 1,
	_position: null,
	_normalizedPosition: null,
	_usingNormalizedPosition: !1,
	_normalizedPositionDirty: !1,
	_skewX: 0,
	_skewY: 0,
	_children: null,
	_visible: !0,
	_anchorPoint: null,
	_contentSize: null,
	_running: !1,
	_parent: null,
	_ignoreAnchorPointForPosition: !1,
	tag: cc.NODE_TAG_INVALID,
	userData: null,
	userObject: null,
	_reorderChildDirty: !1,
	_shaderProgram: null,
	arrivalOrder: 0,
	_actionManager: null,
	_scheduler: null,
	_eventDispatcher: null,
	_additionalTransformDirty: !1,
	_additionalTransform: null,
	_componentContainer: null,
	_isTransitionFinished: !1,
	_className: "Node",
	_showNode: !1,
	_name: "",
	_realOpacity: 255,
	_realColor: null,
	_cascadeColorEnabled: !1,
	_cascadeOpacityEnabled: !1,
	_renderCmd: null,
	ctor: function() {
		this._initNode();
		this._initRendererCmd()
	},
	_initNode: function() {
		this._anchorPoint = cc.p(0, 0);
		this._contentSize = cc.size(0, 0);
		this._position = cc.p(0, 0);
		this._normalizedPosition = cc.p(0, 0);
		this._children = [];
		var t = cc.director;
		this._actionManager = t.getActionManager();
		this._scheduler = t.getScheduler();
		this._additionalTransform = cc.affineTransformMakeIdentity();
		cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this));
		this._realOpacity = 255;
		this._realColor = cc.color(255, 255, 255, 255);
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
	},
	init: function() {
		return !0
	},
	_arrayMakeObjectsPerformSelector: function(t, e) {
		if (t && 0 !== t.length) {
			var i, n = t.length,
				r;
			i = cc.Node._stateCallbackType;
			switch (e) {
			case i.onEnter:
				for (i = 0; i < n; i++) if (r = t[i]) r.onEnter();
				break;
			case i.onExit:
				for (i = 0; i < n; i++) if (r = t[i]) r.onExit();
				break;
			case i.onEnterTransitionDidFinish:
				for (i = 0; i < n; i++) if (r = t[i]) r.onEnterTransitionDidFinish();
				break;
			case i.cleanup:
				for (i = 0; i < n; i++)(r = t[i]) && r.cleanup();
				break;
			case i.updateTransform:
				for (i = 0; i < n; i++)(r = t[i]) && r.updateTransform();
				break;
			case i.onExitTransitionDidStart:
				for (i = 0; i < n; i++) if (r = t[i]) r.onExitTransitionDidStart();
				break;
			case i.sortAllChildren:
				for (i = 0; i < n; i++)(r = t[i]) && r.sortAllChildren();
				break;
			default:
				cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
			}
		}
	},
	attr: function(t) {
		for (var e in t) this[e] = t[e]
	},
	getSkewX: function() {
		return this._skewX
	},
	setSkewX: function(t) {
		this._skewX = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getSkewY: function() {
		return this._skewY
	},
	setSkewY: function(t) {
		this._skewY = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setLocalZOrder: function(t) {
		this._localZOrder = t;
		this._parent && this._parent.reorderChild(this, t);
		cc.eventManager._setDirtyForNode(this)
	},
	_setLocalZOrder: function(t) {
		this._localZOrder = t
	},
	getLocalZOrder: function() {
		return this._localZOrder
	},
	getZOrder: function() {
		cc.log(cc._LogInfos.Node_getZOrder);
		return this.getLocalZOrder()
	},
	setZOrder: function(t) {
		cc.log(cc._LogInfos.Node_setZOrder);
		this.setLocalZOrder(t)
	},
	setGlobalZOrder: function(t) {
		this._globalZOrder != t && (this._globalZOrder = t, cc.eventManager._setDirtyForNode(this))
	},
	getGlobalZOrder: function() {
		return this._globalZOrder
	},
	getVertexZ: function() {
		return this._vertexZ
	},
	setVertexZ: function(t) {
		this._vertexZ = t
	},
	getRotation: function() {
		this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation);
		return this._rotationX
	},
	setRotation: function(t) {
		this._rotationX = this._rotationY = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getRotationX: function() {
		return this._rotationX
	},
	setRotationX: function(t) {
		this._rotationX = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getRotationY: function() {
		return this._rotationY
	},
	setRotationY: function(t) {
		this._rotationY = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getScale: function() {
		this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale);
		return this._scaleX
	},
	setScale: function(t, e) {
		this._scaleX = t;
		this._scaleY = e || 0 === e ? e : t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getScaleX: function() {
		return this._scaleX
	},
	setScaleX: function(t) {
		this._scaleX = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getScaleY: function() {
		return this._scaleY
	},
	setScaleY: function(t) {
		this._scaleY = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setPosition: function(t, e) {
		var i = this._position;
		void 0 === e ? (i.x = t.x, i.y = t.y) : (i.x = t, i.y = e);
		this._usingNormalizedPosition = !1;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setNormalizedPosition: function(t, e) {
		var i = this._normalizedPosition;
		void 0 === e ? (i.x = t.x, i.y = t.y) : (i.x = t, i.y = e);
		this._normalizedPositionDirty = this._usingNormalizedPosition = !0;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getPosition: function() {
		return cc.p(this._position)
	},
	getNormalizedPosition: function() {
		return cc.p(this._normalizedPosition)
	},
	getPositionX: function() {
		return this._position.x
	},
	setPositionX: function(t) {
		this._position.x = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getPositionY: function() {
		return this._position.y
	},
	setPositionY: function(t) {
		this._position.y = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getChildrenCount: function() {
		return this._children.length
	},
	getChildren: function() {
		return this._children
	},
	isVisible: function() {
		return this._visible
	},
	setVisible: function(t) {
		this._visible !== t && (this._visible = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), cc.renderer.childrenOrderDirty = !0)
	},
	getAnchorPoint: function() {
		return cc.p(this._anchorPoint)
	},
	setAnchorPoint: function(t, e) {
		var i = this._anchorPoint;
		if (void 0 === e) {
			if (t.x === i.x && t.y === i.y) return;
			i.x = t.x;
			i.y = t.y
		} else {
			if (t === i.x && e === i.y) return;
			i.x = t;
			i.y = e
		}
		this._renderCmd._updateAnchorPointInPoint()
	},
	_getAnchorX: function() {
		return this._anchorPoint.x
	},
	_setAnchorX: function(t) {
		this._anchorPoint.x !== t && (this._anchorPoint.x = t, this._renderCmd._updateAnchorPointInPoint())
	},
	_getAnchorY: function() {
		return this._anchorPoint.y
	},
	_setAnchorY: function(t) {
		this._anchorPoint.y !== t && (this._anchorPoint.y = t, this._renderCmd._updateAnchorPointInPoint())
	},
	getAnchorPointInPoints: function() {
		return this._renderCmd.getAnchorPointInPoints()
	},
	_getWidth: function() {
		return this._contentSize.width
	},
	_setWidth: function(t) {
		this._contentSize.width = t;
		this._renderCmd._updateAnchorPointInPoint()
	},
	_getHeight: function() {
		return this._contentSize.height
	},
	_setHeight: function(t) {
		this._contentSize.height = t;
		this._renderCmd._updateAnchorPointInPoint()
	},
	getContentSize: function() {
		return cc.size(this._contentSize)
	},
	setContentSize: function(t, e) {
		var i = this._contentSize;
		if (void 0 === e) {
			if (t.width === i.width && t.height === i.height) return;
			i.width = t.width;
			i.height = t.height
		} else {
			if (t === i.width && e === i.height) return;
			i.width = t;
			i.height = e
		}
		this._renderCmd._updateAnchorPointInPoint()
	},
	isRunning: function() {
		return this._running
	},
	getParent: function() {
		return this._parent
	},
	setParent: function(t) {
		this._parent = t
	},
	isIgnoreAnchorPointForPosition: function() {
		return this._ignoreAnchorPointForPosition
	},
	ignoreAnchorPointForPosition: function(t) {
		t != this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
	},
	getTag: function() {
		return this.tag
	},
	setTag: function(t) {
		this.tag = t
	},
	setName: function(t) {
		this._name = t
	},
	getName: function() {
		return this._name
	},
	getUserData: function() {
		return this.userData
	},
	setUserData: function(t) {
		this.userData = t
	},
	getUserObject: function() {
		return this.userObject
	},
	setUserObject: function(t) {
		this.userObject != t && (this.userObject = t)
	},
	getOrderOfArrival: function() {
		return this.arrivalOrder
	},
	setOrderOfArrival: function(t) {
		this.arrivalOrder = t
	},
	getActionManager: function() {
		this._actionManager || (this._actionManager = cc.director.getActionManager());
		return this._actionManager
	},
	setActionManager: function(t) {
		this._actionManager != t && (this.stopAllActions(), this._actionManager = t)
	},
	getScheduler: function() {
		this._scheduler || (this._scheduler = cc.director.getScheduler());
		return this._scheduler
	},
	setScheduler: function(t) {
		this._scheduler != t && (this.unscheduleAllCallbacks(), this._scheduler = t)
	},
	boundingBox: function() {
		cc.log(cc._LogInfos.Node_boundingBox);
		return this.getBoundingBox()
	},
	getBoundingBox: function() {
		var t = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
		return cc._rectApplyAffineTransformIn(t, this.getNodeToParentTransform())
	},
	cleanup: function() {
		this.stopAllActions();
		this.unscheduleAllCallbacks();
		cc.eventManager.removeListeners(this);
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.cleanup)
	},
	getChildByTag: function(t) {
		var e = this._children;
		if (null != e) for (var i = 0; i < e.length; i++) {
			var n = e[i];
			if (n && n.tag == t) return n
		}
		return null
	},
	getChildByName: function(t) {
		if (!t) return cc.log("Invalid name"), null;
		for (var e = this._children, i = 0, n = e.length; i < n; i++) if (e[i]._name == t) return e[i];
		return null
	},
	addChild: function(t, e, i) {
		e = void 0 === e ? t._localZOrder : e;
		var n, r = !1;
		cc.isUndefined(i) ? (i = void 0, n = t._name) : cc.isString(i) ? (n = i, i = void 0) : cc.isNumber(i) && (r = !0, n = "");
		cc.assert(t, cc._LogInfos.Node_addChild_3);
		cc.assert(null === t._parent, "child already added. It can't be added again");
		this._addChildHelper(t, e, i, n, r)
	},
	_addChildHelper: function(t, e, i, n, r) {
		this._children || (this._children = []);
		this._insertChild(t, e);
		r ? t.setTag(i) : t.setName(n);
		t.setParent(this);
		t.setOrderOfArrival(cc.s_globalOrderOfArrival++);
		if (this._running && (t.onEnter(), this._isTransitionFinished)) t.onEnterTransitionDidFinish();
		this._cascadeColorEnabled && t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
		this._cascadeOpacityEnabled && t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	removeFromParent: function(t) {
		this._parent && (null == t && (t = !0), this._parent.removeChild(this, t))
	},
	removeFromParentAndCleanup: function(t) {
		cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
		this.removeFromParent(t)
	},
	removeChild: function(t, e) {
		0 !== this._children.length && (null == e && (e = !0), -1 < this._children.indexOf(t) && this._detachChild(t, e), cc.renderer.childrenOrderDirty = !0)
	},
	removeChildByTag: function(t, e) {
		t === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
		var i = this.getChildByTag(t);
		null == i ? cc.log(cc._LogInfos.Node_removeChildByTag_2, t) : this.removeChild(i, e)
	},
	removeAllChildrenWithCleanup: function(t) {
		this.removeAllChildren(t)
	},
	removeAllChildren: function(t) {
		var e = this._children;
		if (null != e) {
			null == t && (t = !0);
			for (var i = 0; i < e.length; i++) {
				var n = e[i];
				n && (this._running && (n.onExitTransitionDidStart(), n.onExit()), t && n.cleanup(), n.parent = null)
			}
			this._children.length = 0
		}
	},
	_detachChild: function(t, e) {
		this._running && (t.onExitTransitionDidStart(), t.onExit());
		e && t.cleanup();
		t.parent = null;
		t._renderCmd.detachFromParent();
		cc.arrayRemoveObject(this._children, t)
	},
	_insertChild: function(t, e) {
		cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
		this._children.push(t);
		t._setLocalZOrder(e)
	},
	setNodeDirty: function() {
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	reorderChild: function(t, e) {
		cc.assert(t, cc._LogInfos.Node_reorderChild);
		cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
		t.arrivalOrder = cc.s_globalOrderOfArrival;
		cc.s_globalOrderOfArrival++;
		t._setLocalZOrder(e)
	},
	sortAllChildren: function() {
		if (this._reorderChildDirty) {
			var t = this._children,
				e = t.length,
				i, n, r;
			for (i = 1; i < e; i++) {
				r = t[i];
				for (n = i - 1; 0 <= n;) {
					if (r._localZOrder < t[n]._localZOrder) t[n + 1] = t[n];
					else if (r._localZOrder === t[n]._localZOrder && r.arrivalOrder < t[n].arrivalOrder) t[n + 1] = t[n];
					else break;
					n--
				}
				t[n + 1] = r
			}
			this._reorderChildDirty = !1
		}
	},
	draw: function(t) {},
	transformAncestors: function() {
		null != this._parent && (this._parent.transformAncestors(), this._parent.transform())
	},
	onEnter: function() {
		this._isTransitionFinished = !1;
		this._running = !0;
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnter);
		this.resume()
	},
	onEnterTransitionDidFinish: function() {
		this._isTransitionFinished = !0;
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnterTransitionDidFinish)
	},
	onExitTransitionDidStart: function() {
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExitTransitionDidStart)
	},
	onExit: function() {
		this._running = !1;
		this.pause();
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExit);
		this.removeAllComponents()
	},
	runAction: function(t) {
		cc.assert(t, cc._LogInfos.Node_runAction);
		this.actionManager.addAction(t, this, !this._running);
		return t
	},
	stopAllActions: function() {
		this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
	},
	stopAction: function(t) {
		this.actionManager.removeAction(t)
	},
	stopActionByTag: function(t) {
		t === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(t, this)
	},
	getActionByTag: function(t) {
		return t === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(t, this)
	},
	getNumberOfRunningActions: function() {
		return this.actionManager.numberOfRunningActionsInTarget(this)
	},
	scheduleUpdate: function() {
		this.scheduleUpdateWithPriority(0)
	},
	scheduleUpdateWithPriority: function(t) {
		this.scheduler.scheduleUpdateForTarget(this, t, !this._running)
	},
	unscheduleUpdate: function() {
		this.scheduler.unscheduleUpdateForTarget(this)
	},
	schedule: function(t, e, i, n) {
		e = e || 0;
		cc.assert(t, cc._LogInfos.Node_schedule);
		cc.assert(0 <= e, cc._LogInfos.Node_schedule_2);
		i = null == i ? cc.REPEAT_FOREVER : i;
		this.scheduler.scheduleCallbackForTarget(this, t, e, i, n || 0, !this._running)
	},
	scheduleOnce: function(t, e) {
		this.schedule(t, 0, 0, e)
	},
	unschedule: function(t) {
		t && this.scheduler.unscheduleCallbackForTarget(this, t)
	},
	unscheduleAllCallbacks: function() {
		this.scheduler.unscheduleAllCallbacksForTarget(this)
	},
	resumeSchedulerAndActions: function() {
		cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
		this.resume()
	},
	resume: function() {
		this.scheduler.resumeTarget(this);
		this.actionManager && this.actionManager.resumeTarget(this);
		cc.eventManager.resumeTarget(this)
	},
	pauseSchedulerAndActions: function() {
		cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
		this.pause()
	},
	pause: function() {
		this.scheduler.pauseTarget(this);
		this.actionManager && this.actionManager.pauseTarget(this);
		cc.eventManager.pauseTarget(this)
	},
	setAdditionalTransform: function(t) {
		this._additionalTransform = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
		this._additionalTransformDirty = !0
	},
	getParentToNodeTransform: function() {
		this._renderCmd.getParentToNodeTransform()
	},
	parentToNodeTransform: function() {
		return this.getParentToNodeTransform()
	},
	getNodeToWorldTransform: function() {
		for (var t = this.getNodeToParentTransform(), e = this._parent; null != e; e = e.parent) t = cc.affineTransformConcat(t, e.getNodeToParentTransform());
		return t
	},
	nodeToWorldTransform: function() {
		return this.getNodeToWorldTransform()
	},
	getWorldToNodeTransform: function() {
		return cc.affineTransformInvert(this.getNodeToWorldTransform())
	},
	worldToNodeTransform: function() {
		return this.getWorldToNodeTransform()
	},
	convertToNodeSpace: function(t) {
		return cc.pointApplyAffineTransform(t, this.getWorldToNodeTransform())
	},
	convertToWorldSpace: function(t) {
		t = t || cc.p(0, 0);
		return cc.pointApplyAffineTransform(t, this.getNodeToWorldTransform())
	},
	convertToNodeSpaceAR: function(t) {
		return cc.pSub(this.convertToNodeSpace(t), this._renderCmd.getAnchorPointInPoints())
	},
	convertToWorldSpaceAR: function(t) {
		t = t || cc.p(0, 0);
		t = cc.pAdd(t, this._renderCmd.getAnchorPointInPoints());
		return this.convertToWorldSpace(t)
	},
	_convertToWindowSpace: function(t) {
		t = this.convertToWorldSpace(t);
		return cc.director.convertToUI(t)
	},
	convertTouchToNodeSpace: function(t) {
		t = t.getLocation();
		return this.convertToNodeSpace(t)
	},
	convertTouchToNodeSpaceAR: function(t) {
		t = cc.director.convertToGL(t.getLocation());
		return this.convertToNodeSpaceAR(t)
	},
	update: function(t) {
		this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(t)
	},
	updateTransform: function() {
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.updateTransform)
	},
	retain: function() {},
	release: function() {},
	getComponent: function(t) {
		return this._componentContainer ? this._componentContainer.getComponent(t) : null
	},
	addComponent: function(t) {
		this._componentContainer && this._componentContainer.add(t)
	},
	removeComponent: function(t) {
		return this._componentContainer ? this._componentContainer.remove(t) : !1
	},
	removeAllComponents: function() {
		this._componentContainer && this._componentContainer.removeAll()
	},
	grid: null,
	visit: function(t) {
		this._renderCmd.visit(t)
	},
	transform: function(t, e) {
		this._renderCmd.transform(t, e)
	},
	nodeToParentTransform: function() {
		return this.getNodeToParentTransform()
	},
	getNodeToParentTransform: function() {
		return this._renderCmd.getNodeToParentTransform()
	},
	getCamera: function() {
		this._camera || (this._camera = new cc.Camera);
		return this._camera
	},
	getGrid: function() {
		return this.grid
	},
	setGrid: function(t) {
		this.grid = t
	},
	getShaderProgram: function() {
		return this._renderCmd.getShaderProgram()
	},
	setShaderProgram: function(t) {
		this._renderCmd.setShaderProgram(t)
	},
	getGLServerState: function() {
		return 0
	},
	setGLServerState: function(t) {},
	getBoundingBoxToWorld: function() {
		var t = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
			e = this.getNodeToWorldTransform(),
			t = cc.rectApplyAffineTransform(t, e);
		if (!this._children) return t;
		for (var i = this._children, n = 0; n < i.length; n++) {
			var r = i[n];
			r && r._visible && (r = r._getBoundingBoxToCurrentNode(e)) && (t = cc.rectUnion(t, r))
		}
		return t
	},
	_getBoundingBoxToCurrentNode: function(t) {
		var e = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
		t = null == t ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), t);
		e = cc.rectApplyAffineTransform(e, t);
		if (!this._children) return e;
		for (var i = this._children, n = 0; n < i.length; n++) {
			var r = i[n];
			r && r._visible && (r = r._getBoundingBoxToCurrentNode(t)) && (e = cc.rectUnion(e, r))
		}
		return e
	},
	getOpacity: function() {
		return this._realOpacity
	},
	getDisplayedOpacity: function() {
		return this._renderCmd.getDisplayedOpacity()
	},
	setOpacity: function(t) {
		this._realOpacity = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	updateDisplayedOpacity: function(t) {
		this._renderCmd._updateDisplayOpacity(t)
	},
	isCascadeOpacityEnabled: function() {
		return this._cascadeOpacityEnabled
	},
	setCascadeOpacityEnabled: function(t) {
		this._cascadeOpacityEnabled !== t && (this._cascadeOpacityEnabled = t, this._renderCmd.setCascadeOpacityEnabledDirty())
	},
	getColor: function() {
		var t = this._realColor;
		return cc.color(t.r, t.g, t.b, t.a)
	},
	getDisplayedColor: function() {
		return this._renderCmd.getDisplayedColor()
	},
	setColor: function(t) {
		var e = this._realColor;
		e.r = t.r;
		e.g = t.g;
		e.b = t.b;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	updateDisplayedColor: function(t) {
		this._renderCmd._updateDisplayColor(t)
	},
	isCascadeColorEnabled: function() {
		return this._cascadeColorEnabled
	},
	setCascadeColorEnabled: function(t) {
		this._cascadeColorEnabled !== t && (this._cascadeColorEnabled = t, this._renderCmd.setCascadeColorEnabledDirty())
	},
	setOpacityModifyRGB: function(t) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	_initRendererCmd: function() {
		this._renderCmd = cc.renderer.getRenderCmd(this)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Node.CanvasRenderCmd(this) : new cc.Node.WebGLRenderCmd(this)
	}
});
cc.Node.create = function() {
	return new cc.Node
};
cc.Node._stateCallbackType = {
	onEnter: 1,
	onExit: 2,
	cleanup: 3,
	onEnterTransitionDidFinish: 4,
	updateTransform: 5,
	onExitTransitionDidStart: 6,
	sortAllChildren: 7
};
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.CustomRenderCmd = function(t, e) {
	this._needDraw = !0;
	this._target = t;
	this._callback = e;
	this.rendering = function(t, e, i) {
		this._callback && this._callback.call(this._target, t, e, i)
	}
};
cc.Node._dirtyFlags = {
	transformDirty: 1,
	visibleDirty: 2,
	colorDirty: 4,
	opacityDirty: 8,
	cacheDirty: 16,
	orderDirty: 32,
	textDirty: 64,
	gradientDirty: 128,
	all: 255
};
cc.Node.RenderCmd = function(t) {
	this._dirtyFlag = 1;
	this._node = t;
	this._needDraw = !1;
	this._anchorPointInPoints = new cc.Point(0, 0);
	this._transform = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	};
	this._worldTransform = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	};
	this._inverse = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	};
	this._displayedOpacity = 255;
	this._displayedColor = cc.color(255, 255, 255, 255);
	this._cascadeOpacityEnabledDirty = this._cascadeColorEnabledDirty = !1;
	this._curLevel = -1
};
cc.Node.RenderCmd.prototype = {
	constructor: cc.Node.RenderCmd,
	getAnchorPointInPoints: function() {
		return cc.p(this._anchorPointInPoints)
	},
	getDisplayedColor: function() {
		var t = this._displayedColor;
		return cc.color(t.r, t.g, t.b, t.a)
	},
	getDisplayedOpacity: function() {
		return this._displayedOpacity
	},
	setCascadeColorEnabledDirty: function() {
		this._cascadeColorEnabledDirty = !0;
		this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	setCascadeOpacityEnabledDirty: function() {
		this._cascadeOpacityEnabledDirty = !0;
		this.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getParentToNodeTransform: function() {
		this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()));
		return this._inverse
	},
	detachFromParent: function() {},
	_updateAnchorPointInPoint: function() {
		var t = this._anchorPointInPoints,
			e = this._node._contentSize,
			i = this._node._anchorPoint;
		t.x = e.width * i.x;
		t.y = e.height * i.y;
		this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setDirtyFlag: function(t) {
		0 === this._dirtyFlag && 0 !== t && cc.renderer.pushDirtyNode(this);
		this._dirtyFlag |= t
	},
	getParentRenderCmd: function() {
		return this._node && this._node._parent && this._node._parent._renderCmd ? this._node._parent._renderCmd : null
	},
	_updateDisplayColor: function(t) {
		var e = this._node,
			i = this._displayedColor,
			n = e._realColor,
			r;
		if (this._cascadeColorEnabledDirty && !e._cascadeColorEnabled) {
			i.r = n.r;
			i.g = n.g;
			i.b = n.b;
			i = new cc.Color(255, 255, 255, 255);
			t = e._children;
			e = 0;
			for (n = t.length; e < n; e++)(r = t[e]) && r._renderCmd && r._renderCmd._updateDisplayColor(i)
		} else if (void 0 === t && (t = (t = e._parent) && t._cascadeColorEnabled ? t.getDisplayedColor() : cc.color.WHITE), i.r = 0 | n.r * t.r / 255, i.g = 0 | n.g * t.g / 255, i.b = 0 | n.b * t.b / 255, e._cascadeColorEnabled) {
			t = e._children;
			e = 0;
			for (n = t.length; e < n; e++) if ((r = t[e]) && r._renderCmd) r._renderCmd._updateDisplayColor(i), r._renderCmd._updateColor()
		}
		this._cascadeColorEnabledDirty = !1;
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.colorDirty
	},
	_updateDisplayOpacity: function(t) {
		var e = this._node,
			i, n;
		if (this._cascadeOpacityEnabledDirty && !e._cascadeOpacityEnabled) {
			this._displayedOpacity = e._realOpacity;
			i = this._children;
			t = 0;
			for (e = i.length; t < e; t++)(n = i[t]) && n._renderCmd && n._renderCmd._updateDisplayOpacity(255)
		} else if (void 0 === t && (i = e._parent, t = 255, i && i._cascadeOpacityEnabled && (t = i.getDisplayedOpacity())), this._displayedOpacity = e._realOpacity * t / 255, e._cascadeOpacityEnabled) {
			i = e._children;
			t = 0;
			for (e = i.length; t < e; t++) if ((n = i[t]) && n._renderCmd) n._renderCmd._updateDisplayOpacity(this._displayedOpacity), n._renderCmd._updateColor()
		}
		this._cascadeOpacityEnabledDirty = !1;
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty
	},
	_syncDisplayColor: function(t) {
		var e = this._node,
			i = this._displayedColor,
			n = e._realColor;
		void 0 === t && (t = (t = e._parent) && t._cascadeColorEnabled ? t.getDisplayedColor() : cc.color.WHITE);
		i.r = 0 | n.r * t.r / 255;
		i.g = 0 | n.g * t.g / 255;
		i.b = 0 | n.b * t.b / 255
	},
	_syncDisplayOpacity: function(t) {
		var e = this._node;
		if (void 0 === t) {
			var i = e._parent;
			t = 255;
			i && i._cascadeOpacityEnabled && (t = i.getDisplayedOpacity())
		}
		this._displayedOpacity = e._realOpacity * t / 255
	},
	_updateColor: function() {},
	updateStatus: function() {
		var t = cc.Node._dirtyFlags,
			e = this._dirtyFlag,
			i = e & t.colorDirty,
			n = e & t.opacityDirty;
		i && this._updateDisplayColor();
		n && this._updateDisplayOpacity();
		(i || n) && this._updateColor();
		e & t.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
	}
};
(function() {
	cc.Node.CanvasRenderCmd = function(t) {
		cc.Node.RenderCmd.call(this, t);
		this._cachedParent = null;
		this._cacheDirty = !1
	};
	var t = cc.Node.CanvasRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
	t.constructor = cc.Node.CanvasRenderCmd;
	t.transform = function(t, e) {
		var i = this.getNodeToParentTransform(),
			n = this._worldTransform;
		if (t) {
			var r = t._worldTransform;
			n.a = i.a * r.a + i.b * r.c;
			n.b = i.a * r.b + i.b * r.d;
			n.c = i.c * r.a + i.d * r.c;
			n.d = i.c * r.b + i.d * r.d;
			var c = t._transform,
				s = -(c.b + c.c) * i.tx;
			n.tx = i.tx * r.a + i.ty * r.c + r.tx + -(c.b + c.c) * i.ty;
			n.ty = i.tx * r.b + i.ty * r.d + r.ty + s
		} else n.a = i.a, n.b = i.b, n.c = i.c, n.d = i.d, n.tx = i.tx, n.ty = i.ty;
		if (e && (i = this._node._children) && 0 !== i.length) {
			n = 0;
			for (r = i.length; n < r; n++) i[n]._renderCmd.transform(this, e)
		}
	};
	t.getNodeToParentTransform = function() {
		var t = this._node,
			e = !1;
		t._usingNormalizedPosition && t._parent && (e = t._parent._contentSize, t._position.x = t._normalizedPosition.x * e.width, t._position.y = t._normalizedPosition.y * e.height, t._normalizedPositionDirty = !1, e = !0);
		if (e || this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
			e = this._transform;
			e.tx = t._position.x;
			e.ty = t._position.y;
			var i = 1,
				n = 0;
			t._rotationX && (n = .017453292519943295 * t._rotationX, i = Math.cos(n), n = Math.sin(n));
			e.a = e.d = i;
			e.b = -n;
			e.c = n;
			var r = t._scaleX,
				c = t._scaleY,
				s = this._anchorPointInPoints.x,
				o = this._anchorPointInPoints.y,
				a = 1e-6 > r && -1e-6 < r ? 1e-6 : r,
				h = 1e-6 > c && -1e-6 < c ? 1e-6 : c;
			if (t._skewX || t._skewY) {
				var l = Math.tan(-t._skewX * Math.PI / 180),
					u = Math.tan(-t._skewY * Math.PI / 180);
				Infinity === l && (l = 99999999);
				Infinity === u && (u = 99999999);
				var d = o * l * a,
					_ = s * u * h;
				e.a = i + -n * u;
				e.b = i * l + -n;
				e.c = n + i * u;
				e.d = n * l + i;
				e.tx += i * d + -n * _;
				e.ty += n * d + i * _
			}
			if (1 !== r || 1 !== c) e.a *= a, e.c *= a, e.b *= h, e.d *= h;
			e.tx += i * -s * a + -n * o * h;
			e.ty -= n * -s * a + i * o * h;
			t._ignoreAnchorPointForPosition && (e.tx += s, e.ty += o);
			t._additionalTransformDirty && (this._transform = cc.affineTransformConcat(e, t._additionalTransform), t._additionalTransformDirty = !1)
		}
		return this._transform
	};
	t.visit = function(t) {
		var e = this._node;
		if (e._visible) {
			if (t = t || this.getParentRenderCmd()) this._curLevel = t._curLevel + 1;
			var i = e._children,
				n;
			this._syncStatus(t);
			t = i.length;
			if (0 < t) {
				e.sortAllChildren();
				for (e = 0; e < t; e++) if (n = i[e], 0 > n._localZOrder) n._renderCmd.visit(this);
				else break;
				for (cc.renderer.pushRenderCommand(this); e < t; e++) i[e]._renderCmd.visit(this)
			} else cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0
		}
	};
	t._syncStatus = function(t) {
		var e = cc.Node._dirtyFlags,
			i = this._dirtyFlag,
			n = t ? t._node : null;
		n && (n._cascadeColorEnabled && t._dirtyFlag & e.colorDirty) && (i |= e.colorDirty);
		n && (n._cascadeOpacityEnabled && t._dirtyFlag & e.opacityDirty) && (i |= e.opacityDirty);
		t && t._dirtyFlag & e.transformDirty && (i |= e.transformDirty);
		var n = i & e.colorDirty,
			r = i & e.opacityDirty,
			e = i & e.transformDirty;
		this._dirtyFlag = i;
		n && this._syncDisplayColor();
		r && this._syncDisplayOpacity();
		n && this._updateColor();
		e && this.transform(t)
	};
	t.setDirtyFlag = function(t) {
		cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, t);
		this._setCacheDirty();
		this._cachedParent && this._cachedParent.setDirtyFlag(t)
	};
	t._setCacheDirty = function() {
		if (!1 === this._cacheDirty) {
			this._cacheDirty = !0;
			var t = this._cachedParent;
			t && t != this && t._setNodeDirtyForCache && t._setNodeDirtyForCache()
		}
	};
	t._setCachedParent = function(t) {
		if (this._cachedParent != t) {
			this._cachedParent = t;
			for (var e = this._node._children, i = 0, n = e.length; i < n; i++) e[i]._renderCmd._setCachedParent(t)
		}
	};
	t.detachFromParent = function() {
		this._cachedParent = null;
		for (var t = this._node._children, e, i = 0, n = t.length; i < n; i++)(e = t[i]) && e._renderCmd && e._renderCmd.detachFromParent()
	};
	t.setShaderProgram = function(t) {};
	t.getShaderProgram = function() {
		return null
	};
	cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(t) {
		return t ? t.src == cc.SRC_ALPHA && t.dst == cc.ONE || t.src == cc.ONE && t.dst == cc.ONE ? "lighter" : t.src == cc.ZERO && t.dst == cc.SRC_ALPHA ? "destination-in" : t.src == cc.ZERO && t.dst == cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over"
	}
})();
(function() {
	cc.Node.WebGLRenderCmd = function(t) {
		cc.Node.RenderCmd.call(this, t);
		t = new cc.kmMat4;
		t.mat[2] = t.mat[3] = t.mat[6] = t.mat[7] = t.mat[8] = t.mat[9] = t.mat[11] = t.mat[14] = 0;
		t.mat[10] = t.mat[15] = 1;
		this._transform4x4 = t;
		this._stackMatrix = new cc.kmMat4;
		this._camera = this._shaderProgram = null
	};
	var t = cc.Node.WebGLRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
	t.constructor = cc.Node.WebGLRenderCmd;
	t.getNodeToParentTransform = function() {
		var t = this._node;
		if (t._usingNormalizedPosition && t._parent) {
			var e = t._parent._contentSize;
			t._position.x = t._normalizedPosition.x * e.width;
			t._position.y = t._normalizedPosition.y * e.height;
			t._normalizedPositionDirty = !1
		}
		if (this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
			var e = t._position.x,
				i = t._position.y,
				n = this._anchorPointInPoints.x,
				r = -n,
				c = this._anchorPointInPoints.y,
				s = -c,
				o = t._scaleX,
				a = t._scaleY,
				h = .017453292519943295 * t._rotationX,
				l = .017453292519943295 * t._rotationY;
			t._ignoreAnchorPointForPosition && (e += n, i += c);
			var u = 1,
				d = 0,
				_ = 1,
				f = 0;
			if (0 !== t._rotationX || 0 !== t._rotationY) u = Math.cos(-h), d = Math.sin(-h), _ = Math.cos(-l), f = Math.sin(-l);
			h = t._skewX || t._skewY;
			if (!h && (0 !== n || 0 !== c)) e += _ * r * o + -d * s * a, i += f * r * o + u * s * a;
			l = this._transform;
			l.a = _ * o;
			l.b = f * o;
			l.c = -d * a;
			l.d = u * a;
			l.tx = e;
			l.ty = i;
			if (h && (l = cc.affineTransformConcat({
				a: 1,
				b: Math.tan(cc.degreesToRadians(t._skewY)),
				c: Math.tan(cc.degreesToRadians(t._skewX)),
				d: 1,
				tx: 0,
				ty: 0
			}, l), 0 !== n || 0 !== c)) l = cc.affineTransformTranslate(l, r, s);
			t._additionalTransformDirty && (l = cc.affineTransformConcat(l, t._additionalTransform), t._additionalTransformDirty = !1);
			this._transform = l
		}
		return this._transform
	};
	t._syncStatus = function(t) {
		var e = cc.Node._dirtyFlags,
			i = this._dirtyFlag,
			n = t ? t._node : null;
		n && (n._cascadeColorEnabled && t._dirtyFlag & e.colorDirty) && (i |= e.colorDirty);
		n && (n._cascadeOpacityEnabled && t._dirtyFlag & e.opacityDirty) && (i |= e.opacityDirty);
		t && t._dirtyFlag & e.transformDirty && (i |= e.transformDirty);
		n = i & e.colorDirty;
		e = i & e.opacityDirty;
		this._dirtyFlag = i;
		n && this._syncDisplayColor();
		e && this._syncDisplayOpacity();
		(n || e) && this._updateColor();
		this.transform(t)
	};
	t._updateColor = function() {};
	t.visit = function(t) {
		var e = this._node;
		if (e._visible) {
			t = t || this.getParentRenderCmd();
			e._parent && e._parent._renderCmd && (this._curLevel = e._parent._renderCmd._curLevel + 1);
			var i = cc.current_stack;
			i.stack.push(i.top);
			this._syncStatus(t);
			i.top = this._stackMatrix;
			if ((t = e._children) && 0 < t.length) {
				var n = t.length;
				e.sortAllChildren();
				for (e = 0; e < n; e++) if (t[e] && 0 > t[e]._localZOrder) t[e]._renderCmd.visit(this);
				else break;
				for (cc.renderer.pushRenderCommand(this); e < n; e++) t[e] && t[e]._renderCmd.visit(this)
			} else cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0;
			i.top = i.stack.pop()
		}
	};
	t.transform = function(t, e) {
		var i = this._transform4x4,
			n = this._stackMatrix,
			r = this._node,
			c = (t = t || this.getParentRenderCmd()) ? t._stackMatrix : cc.current_stack.top,
			s = this.getNodeToParentTransform();
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty;
		var o = i.mat;
		o[0] = s.a;
		o[4] = s.c;
		o[12] = s.tx;
		o[1] = s.b;
		o[5] = s.d;
		o[13] = s.ty;
		o[14] = r._vertexZ;
		cc.kmMat4Multiply(n, c, i);
		null != r._camera && !(null != r.grid && r.grid.isActive()) && (i = this._anchorPointInPoints.x, c = this._anchorPointInPoints.y, 0 !== i || 0 !== c ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (i |= 0, c |= 0), s = new cc.kmMat4, cc.kmMat4Translation(s, i, c, 0), cc.kmMat4Multiply(n, n, s), r._camera._locateForRenderer(n), cc.kmMat4Translation(s, -i, -c, 0), cc.kmMat4Multiply(n, n, s)) : r._camera._locateForRenderer(n));
		if (e && r._children && 0 !== r._children.length) {
			i = r._children;
			n = 0;
			for (r = i.length; n < r; n++) i[n]._renderCmd.transform(this, e)
		}
	};
	t.setShaderProgram = function(t) {
		this._shaderProgram = t
	};
	t.getShaderProgram = function() {
		return this._shaderProgram
	}
})();
cc.AtlasNode = cc.Node.extend({
	textureAtlas: null,
	quadsToDraw: 0,
	_itemsPerRow: 0,
	_itemsPerColumn: 0,
	_itemWidth: 0,
	_itemHeight: 0,
	_opacityModifyRGB: !1,
	_blendFunc: null,
	_ignoreContentScaleFactor: !1,
	_className: "AtlasNode",
	_textureForCanvas: null,
	ctor: function(t, e, i, n) {
		cc.Node.prototype.ctor.call(this);
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		this._ignoreContentScaleFactor = !1;
		void 0 !== n && this.initWithTileFile(t, e, i, n)
	},
	_createRenderCmd: function() {
		this._renderCmd = cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.AtlasNode.CanvasRenderCmd(this) : new cc.AtlasNode.WebGLRenderCmd(this)
	},
	updateAtlasValues: function() {
		cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
	},
	getColor: function() {
		return this._opacityModifyRGB ? this._renderCmd._colorUnmodified : cc.Node.prototype.getColor.call(this)
	},
	setOpacityModifyRGB: function(t) {
		var e = this.color;
		this._opacityModifyRGB = t;
		this.setColor(e)
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(t, e) {
		this._blendFunc = void 0 === e ? t : {
			src: t,
			dst: e
		}
	},
	setTextureAtlas: function(t) {
		this.textureAtlas = t
	},
	getTextureAtlas: function() {
		return this.textureAtlas
	},
	getQuadsToDraw: function() {
		return this.quadsToDraw
	},
	setQuadsToDraw: function(t) {
		this.quadsToDraw = t
	},
	initWithTileFile: function(t, e, i, n) {
		if (!t) throw "cc.AtlasNode.initWithTileFile(): title should not be null";
		t = cc.textureCache.addImage(t);
		return this.initWithTexture(t, e, i, n)
	},
	initWithTexture: function(t, e, i, n) {
		return this._renderCmd.initWithTexture(t, e, i, n)
	},
	setColor: function(t) {
		this._renderCmd.setColor(t)
	},
	setOpacity: function(t) {
		this._renderCmd.setOpacity(t)
	},
	getTexture: function() {
		return this._renderCmd.getTexture()
	},
	setTexture: function(t) {
		this._renderCmd.setTexture(t)
	},
	_setIgnoreContentScaleFactor: function(t) {
		this._ignoreContentScaleFactor = t
	}
});
_p = cc.AtlasNode.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.EventHelper.prototype.apply(_p);
cc.AtlasNode.create = function(t, e, i, n) {
	return new cc.AtlasNode(t, e, i, n)
};
(function() {
	cc.AtlasNode.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._needDraw = !1;
		this._colorUnmodified = cc.color.WHITE;
		this._texture = this._originalTexture = null
	};
	var t = cc.AtlasNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.AtlasNode.CanvasRenderCmd;
	t.initWithTexture = function(t, e, i, n) {
		var r = this._node;
		r._itemWidth = e;
		r._itemHeight = i;
		r._opacityModifyRGB = !0;
		this._originalTexture = t;
		if (!this._originalTexture) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
		this._texture = this._originalTexture;
		this._calculateMaxItems();
		r.quadsToDraw = n;
		return !0
	};
	t.setColor = function(t) {
		var e = this._node._realColor;
		e.r == t.r && e.g == t.g && e.b == t.b || (this._colorUnmodified = t, this._changeTextureColor())
	};
	t._changeTextureColor = cc.sys._supportCanvasNewBlendModes ?
	function() {
		var t = this._node,
			e = t.getTexture();
		if (e && this._originalTexture) {
			var i = this._originalTexture.getHtmlElementObj();
			if (i) {
				var n = e.getHtmlElementObj(),
					e = cc.rect(0, 0, i.width, i.height);
				n instanceof HTMLCanvasElement ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(i, this._colorUnmodified, e, n) : (n = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(i, this._colorUnmodified, e), e = new cc.Texture2D, e.initWithElement(n), e.handleLoadedTexture(), t.setTexture(e))
			}
		}
	} : function() {
		var t = this._node,
			e, i = t.getTexture();
		if (i && this._originalTexture && (e = i.getHtmlElementObj())) {
			var n = this._originalTexture.getHtmlElementObj();
			if (i = cc.textureCache.getTextureColors(n)) n = cc.rect(0, 0, n.width, n.height), e instanceof HTMLCanvasElement ? cc.Sprite.CanvasRenderCmd._generateTintImage(e, i, this._displayedColor, n, e) : (e = cc.Sprite.CanvasRenderCmd._generateTintImage(e, i, this._displayedColor, n), i = new cc.Texture2D, i.initWithElement(e), i.handleLoadedTexture(), t.setTexture(i))
		}
	};
	t.setOpacity = function(t) {
		cc.Node.prototype.setOpacity.call(this._node, t)
	};
	t.getTexture = function() {
		return this._texture
	};
	t.setTexture = function(t) {
		this._texture = t
	};
	t._calculateMaxItems = function() {
		var t = this._node,
			e = this._texture.getContentSize();
		t._itemsPerColumn = 0 | e.height / t._itemHeight;
		t._itemsPerRow = 0 | e.width / t._itemWidth
	}
})();
(function() {
	cc.AtlasNode.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !0;
		this._textureAtlas = null;
		this._colorUnmodified = cc.color.WHITE;
		this._uniformColor = this._colorF32Array = null
	};
	var t = cc.AtlasNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	t.constructor = cc.AtlasNode.WebGLRenderCmd;
	t._updateBlendFunc = function() {
		var t = this._node;
		this._textureAtlas.texture.hasPremultipliedAlpha() || (t._blendFunc.src = cc.SRC_ALPHA, t._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
	};
	t._updateOpacityModifyRGB = function() {
		this._node._opacityModifyRGB = this._textureAtlas.texture.hasPremultipliedAlpha()
	};
	t.rendering = function(t) {
		t = t || cc._renderContext;
		var e = this._node;
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst);
		this._uniformColor && this._colorF32Array && (t.uniform4fv(this._uniformColor, this._colorF32Array), this._textureAtlas.drawNumberOfQuads(e.quadsToDraw, 0))
	};
	t.initWithTexture = function(t, e, i, n) {
		var r = this._node;
		r._itemWidth = e;
		r._itemHeight = i;
		this._colorUnmodified = cc.color.WHITE;
		r._opacityModifyRGB = !0;
		r._blendFunc.src = cc.BLEND_SRC;
		r._blendFunc.dst = cc.BLEND_DST;
		e = r._realColor;
		this._colorF32Array = new Float32Array([e.r / 255, e.g / 255, e.b / 255, r._realOpacity / 255]);
		this._textureAtlas = new cc.TextureAtlas;
		this._textureAtlas.initWithTexture(t, n);
		if (!this._textureAtlas) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
		this._updateBlendFunc();
		this._updateOpacityModifyRGB();
		this._calculateMaxItems();
		r.quadsToDraw = n;
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
		this._uniformColor = cc._renderContext.getUniformLocation(r.shaderProgram.getProgram(), "u_color");
		return !0
	};
	t.setColor = function(t) {
		var e = cc.color(t.r, t.g, t.b),
			i = this._node;
		this._colorUnmodified = t;
		t = this._displayedOpacity;
		i._opacityModifyRGB && (e.r = e.r * t / 255, e.g = e.g * t / 255, e.b = e.b * t / 255);
		cc.Node.prototype.setColor.call(i, e)
	};
	t.setOpacity = function(t) {
		var e = this._node;
		cc.Node.prototype.setOpacity.call(e, t);
		e._opacityModifyRGB && (e.color = this._colorUnmodified)
	};
	t._updateColor = function() {
		var t = this._displayedColor;
		this._colorF32Array = new Float32Array([t.r / 255, t.g / 255, t.b / 255, this._displayedOpacity / 255])
	};
	t.getTexture = function() {
		return this._textureAtlas.texture
	};
	t.setTexture = function(t) {
		this._textureAtlas.texture = t;
		this._updateBlendFunc();
		this._updateOpacityModifyRGB()
	};
	t._calculateMaxItems = function() {
		var t = this._node,
			e = this._textureAtlas.texture,
			i = e.getContentSize();
		t._ignoreContentScaleFactor && (i = e.getContentSizeInPixels());
		t._itemsPerColumn = 0 | i.height / t._itemHeight;
		t._itemsPerRow = 0 | i.width / t._itemWidth
	}
})();
cc._tmp.WebGLTexture2D = function() {
	cc.Texture2D = cc.Class.extend({
		_pVRHaveAlphaPremultiplied: !0,
		_pixelFormat: null,
		_pixelsWide: 0,
		_pixelsHigh: 0,
		_name: "",
		_contentSize: null,
		maxS: 0,
		maxT: 0,
		_hasPremultipliedAlpha: !1,
		_hasMipmaps: !1,
		shaderProgram: null,
		_isLoaded: !1,
		_htmlElementObj: null,
		_webTextureObj: null,
		url: null,
		ctor: function() {
			this._contentSize = cc.size(0, 0);
			this._pixelFormat = cc.Texture2D.defaultPixelFormat
		},
		releaseTexture: function() {
			this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
			cc.loader.release(this.url)
		},
		getPixelFormat: function() {
			return this._pixelFormat
		},
		getPixelsWide: function() {
			return this._pixelsWide
		},
		getPixelsHigh: function() {
			return this._pixelsHigh
		},
		getName: function() {
			return this._webTextureObj
		},
		getContentSize: function() {
			return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
		},
		_getWidth: function() {
			return this._contentSize.width / cc.contentScaleFactor()
		},
		_getHeight: function() {
			return this._contentSize.height / cc.contentScaleFactor()
		},
		getContentSizeInPixels: function() {
			return this._contentSize
		},
		getMaxS: function() {
			return this.maxS
		},
		setMaxS: function(t) {
			this.maxS = t
		},
		getMaxT: function() {
			return this.maxT
		},
		setMaxT: function(t) {
			this.maxT = t
		},
		getShaderProgram: function() {
			return this.shaderProgram
		},
		setShaderProgram: function(t) {
			this.shaderProgram = t
		},
		hasPremultipliedAlpha: function() {
			return this._hasPremultipliedAlpha
		},
		hasMipmaps: function() {
			return this._hasMipmaps
		},
		description: function() {
			return "<cc.Texture2D | Name = " + this._name + " | Dimensions = " + this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates = (" + this.maxS + ", " + this.maxT + ")>"
		},
		releaseData: function(t) {},
		keepData: function(t, e) {
			return t
		},
		initWithData: function(t, e, i, n, r) {
			var c = cc.Texture2D,
				s = cc._renderContext,
				o = s.RGBA,
				a = s.UNSIGNED_BYTE,
				h = i * cc.Texture2D._B[e] / 8;
			0 === h % 8 ? s.pixelStorei(s.UNPACK_ALIGNMENT, 8) : 0 === h % 4 ? s.pixelStorei(s.UNPACK_ALIGNMENT, 4) : 0 === h % 2 ? s.pixelStorei(s.UNPACK_ALIGNMENT, 2) : s.pixelStorei(s.UNPACK_ALIGNMENT, 1);
			this._webTextureObj = s.createTexture();
			cc.glBindTexture2D(this);
			s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR);
			s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR);
			s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE);
			s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE);
			switch (e) {
			case c.PIXEL_FORMAT_RGBA8888:
				o = s.RGBA;
				break;
			case c.PIXEL_FORMAT_RGB888:
				o = s.RGB;
				break;
			case c.PIXEL_FORMAT_RGBA4444:
				a = s.UNSIGNED_SHORT_4_4_4_4;
				break;
			case c.PIXEL_FORMAT_RGB5A1:
				a = s.UNSIGNED_SHORT_5_5_5_1;
				break;
			case c.PIXEL_FORMAT_RGB565:
				a = s.UNSIGNED_SHORT_5_6_5;
				break;
			case c.PIXEL_FORMAT_AI88:
				o = s.LUMINANCE_ALPHA;
				break;
			case c.PIXEL_FORMAT_A8:
				o = s.ALPHA;
				break;
			case c.PIXEL_FORMAT_I8:
				o = s.LUMINANCE;
				break;
			default:
				cc.assert(0, cc._LogInfos.Texture2D_initWithData)
			}
			s.texImage2D(s.TEXTURE_2D, 0, o, i, n, 0, o, a, t);
			this._contentSize.width = r.width;
			this._contentSize.height = r.height;
			this._pixelsWide = i;
			this._pixelsHigh = n;
			this._pixelFormat = e;
			this.maxS = r.width / i;
			this.maxT = r.height / n;
			this._hasMipmaps = this._hasPremultipliedAlpha = !1;
			this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
			return this._isLoaded = !0
		},
		drawAtPoint: function(t) {
			var e = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
				i = this._pixelsWide * this.maxS,
				n = this._pixelsHigh * this.maxT;
			t = [t.x, t.y, 0, i + t.x, t.y, 0, t.x, n + t.y, 0, i + t.x, n + t.y, 0];
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
			this._shaderProgram.use();
			this._shaderProgram.setUniformsForBuiltins();
			cc.glBindTexture2D(this);
			i = cc._renderContext;
			i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, i.FLOAT, !1, 0, t);
			i.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, i.FLOAT, !1, 0, e);
			i.drawArrays(i.TRIANGLE_STRIP, 0, 4)
		},
		drawInRect: function(t) {
			var e = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
			t = [t.x, t.y, t.x + t.width, t.y, t.x, t.y + t.height, t.x + t.width, t.y + t.height];
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
			this._shaderProgram.use();
			this._shaderProgram.setUniformsForBuiltins();
			cc.glBindTexture2D(this);
			var i = cc._renderContext;
			i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, i.FLOAT, !1, 0, t);
			i.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, i.FLOAT, !1, 0, e);
			i.drawArrays(i.TRIANGLE_STRIP, 0, 4)
		},
		initWithImage: function(t) {
			if (null == t) return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
			var e = t.getWidth(),
				i = t.getHeight(),
				n = cc.configuration.getMaxTextureSize();
			if (e > n || i > n) return cc.log(cc._LogInfos.Texture2D_initWithImage_2, e, i, n, n), !1;
			this._isLoaded = !0;
			return this._initPremultipliedATextureWithImage(t, e, i)
		},
		initWithElement: function(t) {
			t && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = t)
		},
		getHtmlElementObj: function() {
			return this._htmlElementObj
		},
		isLoaded: function() {
			return this._isLoaded
		},
		handleLoadedTexture: function() {
			if (cc._rendererInitialized) {
				if (!this._htmlElementObj) {
					var t = cc.loader.getRes(this.url);
					if (!t) return;
					this.initWithElement(t)
				}
				this._htmlElementObj.width && this._htmlElementObj.height && (this._isLoaded = !0, t = cc._renderContext, cc.glBindTexture2D(this), t.pixelStorei(t.UNPACK_ALIGNMENT, 4), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, this._htmlElementObj), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), t = this._htmlElementObj.height, this._pixelsWide = this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = t, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasMipmaps = this._hasPremultipliedAlpha = !1, this.dispatchEvent("load"))
			}
		},
		initWithString: function(t, e, i, n, r, c) {
			cc.log(cc._LogInfos.Texture2D_initWithString);
			return null
		},
		initWithETCFile: function(t) {
			cc.log(cc._LogInfos.Texture2D_initWithETCFile_2);
			return !1
		},
		initWithPVRFile: function(t) {
			cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2);
			return !1
		},
		initWithPVRTCData: function(t, e, i, n, r, c) {
			cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2);
			return !1
		},
		setTexParameters: function(t, e, i, n) {
			var r = cc._renderContext;
			void 0 !== e && (t = {
				minFilter: t,
				magFilter: e,
				wrapS: i,
				wrapT: n
			});
			cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh) || t.wrapS == r.CLAMP_TO_EDGE && t.wrapT == r.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
			cc.glBindTexture2D(this);
			r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, t.minFilter);
			r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, t.magFilter);
			r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, t.wrapS);
			r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, t.wrapT)
		},
		setAntiAliasTexParameters: function() {
			var t = cc._renderContext;
			cc.glBindTexture2D(this);
			this._hasMipmaps ? t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR_MIPMAP_NEAREST) : t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR);
			t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR)
		},
		setAliasTexParameters: function() {
			var t = cc._renderContext;
			cc.glBindTexture2D(this);
			this._hasMipmaps ? t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST_MIPMAP_NEAREST) : t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST);
			t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST)
		},
		generateMipmap: function() {
			cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
			cc.glBindTexture2D(this);
			cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
			this._hasMipmaps = !0
		},
		stringForFormat: function() {
			return cc.Texture2D._M[this._pixelFormat]
		},
		bitsPerPixelForFormat: function(t) {
			t = t || this._pixelFormat;
			var e = cc.Texture2D._B[t];
			if (null != e) return e;
			cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, t);
			return -1
		},
		_initPremultipliedATextureWithImage: function(t, e, i) {
			var n = cc.Texture2D,
				r = t.getData(),
				c = null,
				c = null,
				s = t.hasAlpha(),
				o = cc.size(t.getWidth(), t.getHeight()),
				a = n.defaultPixelFormat,
				h = t.getBitsPerComponent();
			s || (8 <= h ? a = n.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), a = n.PIXEL_FORMAT_RGB565));
			var l = e * i;
			if (a == n.PIXEL_FORMAT_RGB565) if (s) {
				r = new Uint16Array(e * i);
				c = t.getData();
				for (h = 0; h < l; ++h) r[h] = (c[h] >> 0 & 255) >> 3 << 11 | (c[h] >> 8 & 255) >> 2 << 5 | (c[h] >> 16 & 255) >> 3 << 0
			} else {
				r = new Uint16Array(e * i);
				c = t.getData();
				for (h = 0; h < l; ++h) r[h] = (c[h] & 255) >> 3 << 11 | (c[h] & 255) >> 2 << 5 | (c[h] & 255) >> 3 << 0
			} else if (a == n.PIXEL_FORMAT_RGBA4444) {
				r = new Uint16Array(e * i);
				c = t.getData();
				for (h = 0; h < l; ++h) r[h] = (c[h] >> 0 & 255) >> 4 << 12 | (c[h] >> 8 & 255) >> 4 << 8 | (c[h] >> 16 & 255) >> 4 << 4 | (c[h] >> 24 & 255) >> 4 << 0
			} else if (a == n.PIXEL_FORMAT_RGB5A1) {
				r = new Uint16Array(e * i);
				c = t.getData();
				for (h = 0; h < l; ++h) r[h] = (c[h] >> 0 & 255) >> 3 << 11 | (c[h] >> 8 & 255) >> 3 << 6 | (c[h] >> 16 & 255) >> 3 << 1 | (c[h] >> 24 & 255) >> 7 << 0
			} else if (a == n.PIXEL_FORMAT_A8) {
				r = new Uint8Array(e * i);
				c = t.getData();
				for (h = 0; h < l; ++h) r[h] = c >> 24 & 255
			}
			if (s && a == n.PIXEL_FORMAT_RGB888) {
				c = t.getData();
				r = new Uint8Array(3 * e * i);
				for (h = 0; h < l; ++h) r[3 * h] = c >> 0 & 255, r[3 * h + 1] = c >> 8 & 255, r[3 * h + 2] = c >> 16 & 255
			}
			this.initWithData(r, a, e, i, o);
			t.getData();
			this._hasPremultipliedAlpha = t.isPremultipliedAlpha();
			return !0
		},
		addLoadedEventListener: function(t, e) {
			this.addEventListener("load", t, e)
		},
		removeLoadedEventListener: function(t) {
			this.removeEventListener("load", t)
		}
	})
};
cc._tmp.WebGLTextureAtlas = function() {
	var t = cc.TextureAtlas.prototype;
	t._setupVBO = function() {
		var t = cc._renderContext;
		this._buffersVBO[0] = t.createBuffer();
		this._buffersVBO[1] = t.createBuffer();
		this._quadsWebBuffer = t.createBuffer();
		this._mapBuffers()
	};
	t._mapBuffers = function() {
		var t = cc._renderContext;
		t.bindBuffer(t.ARRAY_BUFFER, this._quadsWebBuffer);
		t.bufferData(t.ARRAY_BUFFER, this._quadsArrayBuffer, t.DYNAMIC_DRAW);
		t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
		t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW)
	};
	t.drawNumberOfQuads = function(t, e) {
		e = e || 0;
		if (!(0 === t || !this.texture || !this.texture.isLoaded())) {
			var i = cc._renderContext;
			cc.glBindTexture2D(this.texture);
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
			i.bindBuffer(i.ARRAY_BUFFER, this._quadsWebBuffer);
			this.dirty && (i.bufferData(i.ARRAY_BUFFER, this._quadsArrayBuffer, i.DYNAMIC_DRAW), this.dirty = !1);
			i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, i.FLOAT, !1, 24, 0);
			i.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, i.UNSIGNED_BYTE, !0, 24, 12);
			i.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, i.FLOAT, !1, 24, 16);
			i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
			cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? i.drawElements(i.TRIANGLE_STRIP, 6 * t, i.UNSIGNED_SHORT, 6 * e * this._indices.BYTES_PER_ELEMENT) : i.drawElements(i.TRIANGLES, 6 * t, i.UNSIGNED_SHORT, 6 * e * this._indices.BYTES_PER_ELEMENT);
			cc.g_NumberOfDraws++
		}
	}
};
cc._tmp.WebGLTextureCache = function() {
	var t = cc.textureCache;
	t.handleLoadedTexture = function(t) {
		var e = this._textures;
		cc._rendererInitialized || (e = this._loadedTexturesBefore);
		var i = e[t];
		i || (i = e[t] = new cc.Texture2D, i.url = t);
		i.handleLoadedTexture()
	};
	t.addImage = function(t, e, i) {
		cc.assert(t, cc._LogInfos.Texture2D_addImage_2);
		var n = this._textures;
		cc._rendererInitialized || (n = this._loadedTexturesBefore);
		var r = n[t] || n[cc.loader._aliases[t]];
		if (r) return e && e.call(i, r), r;
		r = n[t] = new cc.Texture2D;
		r.url = t;
		(cc.loader._checkIsImageURL(t) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, t, function(r, c) {
			if (r) return e && e.call(i, r);
			cc.textureCache.handleLoadedTexture(t);
			var s = n[t];
			e && e.call(i, s)
		});
		return r
	};
	t = null
};
cc._tmp.PrototypeTexture2D = function() {
	var t = cc.Texture2D;
	t.PVRImagesHavePremultipliedAlpha = function(t) {
		cc.PVRHaveAlphaPremultiplied_ = t
	};
	t.PIXEL_FORMAT_RGBA8888 = 2;
	t.PIXEL_FORMAT_RGB888 = 3;
	t.PIXEL_FORMAT_RGB565 = 4;
	t.PIXEL_FORMAT_A8 = 5;
	t.PIXEL_FORMAT_I8 = 6;
	t.PIXEL_FORMAT_AI88 = 7;
	t.PIXEL_FORMAT_RGBA4444 = 8;
	t.PIXEL_FORMAT_RGB5A1 = 7;
	t.PIXEL_FORMAT_PVRTC4 = 9;
	t.PIXEL_FORMAT_PVRTC2 = 10;
	t.PIXEL_FORMAT_DEFAULT = t.PIXEL_FORMAT_RGBA8888;
	var e = cc.Texture2D._M = {};
	e[t.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
	e[t.PIXEL_FORMAT_RGB888] = "RGB888";
	e[t.PIXEL_FORMAT_RGB565] = "RGB565";
	e[t.PIXEL_FORMAT_A8] = "A8";
	e[t.PIXEL_FORMAT_I8] = "I8";
	e[t.PIXEL_FORMAT_AI88] = "AI88";
	e[t.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
	e[t.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
	e[t.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
	e[t.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
	e = cc.Texture2D._B = {};
	e[t.PIXEL_FORMAT_RGBA8888] = 32;
	e[t.PIXEL_FORMAT_RGB888] = 24;
	e[t.PIXEL_FORMAT_RGB565] = 16;
	e[t.PIXEL_FORMAT_A8] = 8;
	e[t.PIXEL_FORMAT_I8] = 8;
	e[t.PIXEL_FORMAT_AI88] = 16;
	e[t.PIXEL_FORMAT_RGBA4444] = 16;
	e[t.PIXEL_FORMAT_RGB5A1] = 16;
	e[t.PIXEL_FORMAT_PVRTC4] = 4;
	e[t.PIXEL_FORMAT_PVRTC2] = 3;
	e = cc.Texture2D.prototype;
	cc.defineGetterSetter(e, "name", e.getName);
	cc.defineGetterSetter(e, "pixelFormat", e.getPixelFormat);
	cc.defineGetterSetter(e, "pixelsWidth", e.getPixelsWide);
	cc.defineGetterSetter(e, "pixelsHeight", e.getPixelsHigh);
	cc.defineGetterSetter(e, "width", e._getWidth);
	cc.defineGetterSetter(e, "height", e._getHeight);
	t.defaultPixelFormat = t.PIXEL_FORMAT_DEFAULT
};
cc._tmp.PrototypeTextureAtlas = function() {
	var t = cc.TextureAtlas.prototype;
	cc.defineGetterSetter(t, "totalQuads", t.getTotalQuads);
	cc.defineGetterSetter(t, "capacity", t.getCapacity);
	cc.defineGetterSetter(t, "quads", t.getQuads, t.setQuads)
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.Texture2D = cc.Class.extend({
	_contentSize: null,
	_isLoaded: !1,
	_htmlElementObj: null,
	url: null,
	_pattern: null,
	ctor: function() {
		this._contentSize = cc.size(0, 0);
		this._isLoaded = !1;
		this._htmlElementObj = null;
		this._pattern = ""
	},
	getPixelsWide: function() {
		return this._contentSize.width
	},
	getPixelsHigh: function() {
		return this._contentSize.height
	},
	getContentSize: function() {
		var t = cc.contentScaleFactor();
		return cc.size(this._contentSize.width / t, this._contentSize.height / t)
	},
	_getWidth: function() {
		return this._contentSize.width / cc.contentScaleFactor()
	},
	_getHeight: function() {
		return this._contentSize.height / cc.contentScaleFactor()
	},
	getContentSizeInPixels: function() {
		return this._contentSize
	},
	initWithElement: function(t) {
		t && (this._htmlElementObj = t)
	},
	getHtmlElementObj: function() {
		return this._htmlElementObj
	},
	isLoaded: function() {
		return this._isLoaded
	},
	handleLoadedTexture: function() {
		if (!this._isLoaded) {
			if (!this._htmlElementObj) {
				var t = cc.loader.getRes(this.url);
				if (!t) return;
				this.initWithElement(t)
			}
			this._isLoaded = !0;
			t = this._htmlElementObj;
			this._contentSize.width = t.width;
			this._contentSize.height = t.height;
			this.dispatchEvent("load")
		}
	},
	description: function() {
		return "<cc.Texture2D | width = " + this._contentSize.width + " height " + this._contentSize.height + ">"
	},
	initWithData: function(t, e, i, n, r) {
		return !1
	},
	initWithImage: function(t) {
		return !1
	},
	initWithString: function(t, e, i, n, r, c) {
		return !1
	},
	releaseTexture: function() {},
	getName: function() {
		return null
	},
	getMaxS: function() {
		return 1
	},
	setMaxS: function(t) {},
	getMaxT: function() {
		return 1
	},
	setMaxT: function(t) {},
	getPixelFormat: function() {
		return null
	},
	getShaderProgram: function() {
		return null
	},
	setShaderProgram: function(t) {},
	hasPremultipliedAlpha: function() {
		return !1
	},
	hasMipmaps: function() {
		return !1
	},
	releaseData: function(t) {},
	keepData: function(t, e) {
		return t
	},
	drawAtPoint: function(t) {},
	drawInRect: function(t) {},
	initWithETCFile: function(t) {
		cc.log(cc._LogInfos.Texture2D_initWithETCFile);
		return !1
	},
	initWithPVRFile: function(t) {
		cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
		return !1
	},
	initWithPVRTCData: function(t, e, i, n, r, c) {
		cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
		return !1
	},
	setTexParameters: function(t, e, i, n) {
		void 0 !== e && (t = {
			minFilter: t,
			magFilter: e,
			wrapS: i,
			wrapT: n
		});
		this._pattern = t.wrapS === cc.REPEAT && t.wrapT === cc.REPEAT ? "repeat" : t.wrapS === cc.REPEAT ? "repeat-x" : t.wrapT === cc.REPEAT ? "repeat-y" : ""
	},
	setAntiAliasTexParameters: function() {},
	setAliasTexParameters: function() {},
	generateMipmap: function() {},
	stringForFormat: function() {
		return ""
	},
	bitsPerPixelForFormat: function(t) {
		return -1
	},
	addLoadedEventListener: function(t, e) {
		this.addEventListener("load", t, e)
	},
	removeLoadedEventListener: function(t) {
		this.removeEventListener("load", t)
	}
}) : (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
cc.EventHelper.prototype.apply(cc.Texture2D.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTexture2D();
delete cc._tmp.PrototypeTexture2D;
cc.textureCache = {
	_textures: {},
	_textureColorsCache: {},
	_textureKeySeq: 0 | 1e3 * Math.random(),
	_loadedTexturesBefore: {},
	_initializingRenderer: function() {
		var t, e = this._loadedTexturesBefore,
			i = this._textures;
		for (t in e) {
			var n = e[t];
			n.handleLoadedTexture();
			i[t] = n
		}
		this._loadedTexturesBefore = {}
	},
	addPVRTCImage: function(t) {
		cc.log(cc._LogInfos.textureCache_addPVRTCImage)
	},
	addETCImage: function(t) {
		cc.log(cc._LogInfos.textureCache_addETCImage)
	},
	description: function() {
		return "<TextureCache | Number of textures = " + this._textures.length + ">"
	},
	textureForKey: function(t) {
		cc.log(cc._LogInfos.textureCache_textureForKey);
		return this.getTextureForKey(t)
	},
	getTextureForKey: function(t) {
		return this._textures[t] || this._textures[cc.loader._aliases[t]]
	},
	getKeyByTexture: function(t) {
		for (var e in this._textures) if (this._textures[e] == t) return e;
		return null
	},
	_generalTextureKey: function() {
		this._textureKeySeq++;
		return "_textureKey_" + this._textureKeySeq
	},
	getTextureColors: function(t) {
		var e = this.getKeyByTexture(t);
		e || (e = t instanceof HTMLImageElement ? t.src : this._generalTextureKey());
		this._textureColorsCache[e] || (this._textureColorsCache[e] = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor(t));
		return this._textureColorsCache[e]
	},
	addPVRImage: function(t) {
		cc.log(cc._LogInfos.textureCache_addPVRImage)
	},
	removeAllTextures: function() {
		var t = this._textures,
			e;
		for (e in t) t[e] && t[e].releaseTexture();
		this._textures = {}
	},
	removeTexture: function(t) {
		if (t) {
			var e = this._textures,
				i;
			for (i in e) e[i] == t && (e[i].releaseTexture(), delete e[i])
		}
	},
	removeTextureForKey: function(t) {
		null != t && this._textures[t] && delete this._textures[t]
	},
	cacheImage: function(t, e) {
		if (e instanceof cc.Texture2D) this._textures[t] = e;
		else {
			var i = new cc.Texture2D;
			i.initWithElement(e);
			i.handleLoadedTexture();
			this._textures[t] = i
		}
	},
	addUIImage: function(t, e) {
		cc.assert(t, cc._LogInfos.textureCache_addUIImage_2);
		if (e && this._textures[e]) return this._textures[e];
		var i = new cc.Texture2D;
		i.initWithImage(t);
		null != e && null != i ? this._textures[e] = i : cc.log(cc._LogInfos.textureCache_addUIImage);
		return i
	},
	dumpCachedTextureInfo: function() {
		var t = 0,
			e = 0,
			i = this._textures,
			n;
		for (n in i) {
			var r = i[n];
			t++;
			r.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, n, r.getHtmlElementObj().src, r.pixelsWidth, r.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, n, r.pixelsWidth, r.pixelsHeight);
			e += 4 * r.pixelsWidth * r.pixelsHeight
		}
		i = this._textureColorsCache;
		for (n in i) {
			var r = i[n],
				c;
			for (c in r) {
				var s = r[c];
				t++;
				cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, n, s.width, s.height);
				e += 4 * s.width * s.height
			}
		}
		cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, t, e / 1024, (e / 1048576).toFixed(2))
	},
	_clear: function() {
		this._textures = {};
		this._textureColorsCache = {};
		this._textureKeySeq = 0 | 1e3 * Math.random();
		this._loadedTexturesBefore = {}
	}
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.textureCache, _p.handleLoadedTexture = function(t) {
	var e = this._textures,
		i = e[t];
	i || (i = e[t] = new cc.Texture2D, i.url = t);
	i.handleLoadedTexture()
}, _p.addImage = function(t, e, i) {
	cc.assert(t, cc._LogInfos.Texture2D_addImage);
	var n = this._textures,
		r = n[t] || n[cc.loader._aliases[t]];
	if (r) return e && e.call(i, r), r;
	r = n[t] = new cc.Texture2D;
	r.url = t;
	(cc.loader._checkIsImageURL(t) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, t, function(r, c) {
		if (r) return e && e.call(i, r);
		cc.textureCache.handleLoadedTexture(t);
		var s = n[t];
		e && e.call(i, s)
	});
	return r
}, _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache);
cc.TextureAtlas = cc.Class.extend({
	dirty: !1,
	texture: null,
	_indices: null,
	_buffersVBO: null,
	_capacity: 0,
	_quads: null,
	_quadsArrayBuffer: null,
	_quadsWebBuffer: null,
	_quadsReader: null,
	ctor: function(t, e) {
		this._buffersVBO = [];
		cc.isString(t) ? this.initWithFile(t, e) : t instanceof cc.Texture2D && this.initWithTexture(t, e)
	},
	getTotalQuads: function() {
		return this._totalQuads
	},
	getCapacity: function() {
		return this._capacity
	},
	getTexture: function() {
		return this.texture
	},
	setTexture: function(t) {
		this.texture = t
	},
	setDirty: function(t) {
		this.dirty = t
	},
	isDirty: function() {
		return this.dirty
	},
	getQuads: function() {
		return this._quads
	},
	setQuads: function(t) {
		this._quads = t
	},
	_copyQuadsToTextureAtlas: function(t, e) {
		if (t) for (var i = 0; i < t.length; i++) this._setQuadToArray(t[i], e + i)
	},
	_setQuadToArray: function(t, e) {
		var i = this._quads;
		i[e] ? (i[e].bl = t.bl, i[e].br = t.br, i[e].tl = t.tl, i[e].tr = t.tr) : i[e] = new cc.V3F_C4B_T2F_Quad(t.tl, t.bl, t.tr, t.br, this._quadsArrayBuffer, e * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
	},
	description: function() {
		return "<cc.TextureAtlas | totalQuads =" + this._totalQuads + ">"
	},
	_setupIndices: function() {
		if (0 !== this._capacity) for (var t = this._indices, e = this._capacity, i = 0; i < e; i++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (t[6 * i + 0] = 4 * i + 0, t[6 * i + 1] = 4 * i + 0, t[6 * i + 2] = 4 * i + 2, t[6 * i + 3] = 4 * i + 1, t[6 * i + 4] = 4 * i + 3, t[6 * i + 5] = 4 * i + 3) : (t[6 * i + 0] = 4 * i + 0, t[6 * i + 1] = 4 * i + 1, t[6 * i + 2] = 4 * i + 2, t[6 * i + 3] = 4 * i + 3, t[6 * i + 4] = 4 * i + 2, t[6 * i + 5] = 4 * i + 1)
	},
	_setupVBO: function() {
		var t = cc._renderContext;
		this._buffersVBO[0] = t.createBuffer();
		this._buffersVBO[1] = t.createBuffer();
		this._quadsWebBuffer = t.createBuffer();
		this._mapBuffers()
	},
	_mapBuffers: function() {
		var t = cc._renderContext;
		t.bindBuffer(t.ARRAY_BUFFER, this._quadsWebBuffer);
		t.bufferData(t.ARRAY_BUFFER, this._quadsArrayBuffer, t.DYNAMIC_DRAW);
		t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
		t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW)
	},
	initWithFile: function(t, e) {
		var i = cc.textureCache.addImage(t);
		if (i) return this.initWithTexture(i, e);
		cc.log(cc._LogInfos.TextureAtlas_initWithFile, t);
		return !1
	},
	initWithTexture: function(t, e) {
		cc.assert(t, cc._LogInfos.TextureAtlas_initWithTexture);
		this._capacity = e |= 0;
		this._totalQuads = 0;
		this.texture = t;
		this._quads = [];
		this._indices = new Uint16Array(6 * e);
		var i = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
		this._quadsArrayBuffer = new ArrayBuffer(i * e);
		this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
		if ((!this._quads || !this._indices) && 0 < e) return !1;
		for (var n = this._quads, r = 0; r < e; r++) n[r] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, r * i);
		this._setupIndices();
		this._setupVBO();
		return this.dirty = !0
	},
	updateQuad: function(t, e) {
		cc.assert(t, cc._LogInfos.TextureAtlas_updateQuad);
		cc.assert(0 <= e && e < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2);
		this._totalQuads = Math.max(e + 1, this._totalQuads);
		this._setQuadToArray(t, e);
		this.dirty = !0
	},
	insertQuad: function(t, e) {
		cc.assert(e < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2);
		this._totalQuads++;
		if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
		else {
			var i = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
				n = e * i,
				r = (this._totalQuads - 1 - e) * i;
			this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * i);
			this._quadsReader.set(this._quadsReader.subarray(n, n + r), n + i);
			this._setQuadToArray(t, e);
			this.dirty = !0
		}
	},
	insertQuads: function(t, e, i) {
		i = i || t.length;
		cc.assert(e + i <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
		var n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
		this._totalQuads += i;
		if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
		else {
			var r = e * n,
				c = (this._totalQuads - 1 - e - i) * n,
				s = this._totalQuads - 1 - i,
				o;
			for (o = 0; o < i; o++) this._quads[s + o] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * n);
			this._quadsReader.set(this._quadsReader.subarray(r, r + c), r + n * i);
			for (o = 0; o < i; o++) this._setQuadToArray(t[o], e + o);
			this.dirty = !0
		}
	},
	insertQuadFromIndex: function(t, e) {
		if (t !== e) {
			cc.assert(0 <= e || e < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex);
			cc.assert(0 <= t || t < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
			var i = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
				n = this._quadsReader,
				r = n.subarray(t * i, i),
				c;
			t > e ? (c = e * i, n.set(n.subarray(c, c + (t - e) * i), c + i), n.set(r, c)) : (c = (t + 1) * i, n.set(n.subarray(c, c + (e - t) * i), c - i), n.set(r, e * i));
			this.dirty = !0
		}
	},
	removeQuadAtIndex: function(t) {
		cc.assert(t < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
		var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
		this._totalQuads--;
		this._quads.length = this._totalQuads;
		if (t !== this._totalQuads) {
			var i = (t + 1) * e;
			this._quadsReader.set(this._quadsReader.subarray(i, i + (this._totalQuads - t) * e), i - e)
		}
		this.dirty = !0
	},
	removeQuadsAtIndex: function(t, e) {
		cc.assert(t + e <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex);
		this._totalQuads -= e;
		if (t !== this._totalQuads) {
			var i = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
				n = (t + e) * i;
			this._quadsReader.set(this._quadsReader.subarray(n, n + (this._totalQuads - t) * i), t * i)
		}
		this.dirty = !0
	},
	removeAllQuads: function() {
		this._totalQuads = this._quads.length = 0
	},
	_setDirty: function(t) {
		this.dirty = t
	},
	resizeCapacity: function(t) {
		if (t == this._capacity) return !0;
		var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
			i = this._capacity;
		this._totalQuads = Math.min(this._totalQuads, t);
		var n = this._capacity = 0 | t,
			r = this._totalQuads;
		if (null == this._quads) {
			this._quads = [];
			this._quadsArrayBuffer = new ArrayBuffer(e * n);
			this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
			for (t = 0; t < n; t++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, t * e)
		} else {
			var c, s, o = this._quads;
			if (n > i) {
				c = [];
				s = new ArrayBuffer(e * n);
				for (t = 0; t < r; t++) c[t] = new cc.V3F_C4B_T2F_Quad(o[t].tl, o[t].bl, o[t].tr, o[t].br, s, t * e);
				for (; t < n; t++) c[t] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, s, t * e)
			} else {
				r = Math.max(r, n);
				c = [];
				s = new ArrayBuffer(e * n);
				for (t = 0; t < r; t++) c[t] = new cc.V3F_C4B_T2F_Quad(o[t].tl, o[t].bl, o[t].tr, o[t].br, s, t * e)
			}
			this._quadsReader = new Uint8Array(s);
			this._quads = c;
			this._quadsArrayBuffer = s
		}
		null == this._indices ? this._indices = new Uint16Array(6 * n) : n > i ? (e = new Uint16Array(6 * n), e.set(this._indices, 0), this._indices = e) : this._indices = this._indices.subarray(0, 6 * n);
		this._setupIndices();
		this._mapBuffers();
		return this.dirty = !0
	},
	increaseTotalQuadsWith: function(t) {
		this._totalQuads += t
	},
	moveQuadsFromIndex: function(t, e, i) {
		if (void 0 === i) {
			if (i = e, e = this._totalQuads - t, cc.assert(i + (this._totalQuads - t) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === e) return
		} else if (cc.assert(i + e <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(t < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), t == i) return;
		var n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
			r = t * n,
			c = e * n,
			s = this._quadsReader,
			o = s.subarray(r, r + c),
			a = i * n;
		i < t ? (e = i * n, s.set(s.subarray(e, e + (t - i) * n), e + c)) : (e = (t + e) * n, s.set(s.subarray(e, e + (i - t) * n), r));
		s.set(o, a);
		this.dirty = !0
	},
	fillWithEmptyQuadsFromIndex: function(t, e) {
		for (var i = e * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, n = new Uint8Array(this._quadsArrayBuffer, t * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, i), r = 0; r < i; r++) n[r] = 0
	},
	drawQuads: function() {
		this.drawNumberOfQuads(this._totalQuads, 0)
	},
	_releaseBuffer: function() {
		var t = cc._renderContext;
		this._buffersVBO && (this._buffersVBO[0] && t.deleteBuffer(this._buffersVBO[0]), this._buffersVBO[1] && t.deleteBuffer(this._buffersVBO[1]));
		this._quadsWebBuffer && t.deleteBuffer(this._quadsWebBuffer)
	}
});
_p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function(t, e) {
	return new cc.TextureAtlas(t, e)
};
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create;
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas);
cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.Scene = cc.Node.extend({
	_className: "Scene",
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		this._ignoreAnchorPointForPosition = !0;
		this.setAnchorPoint(.5, .5);
		this.setContentSize(cc.director.getWinSize())
	}
});
cc.Scene.create = function() {
	return new cc.Scene
};
cc.LoaderScene = cc.Scene.extend({
	_interval: null,
	_label: null,
	_className: "LoaderScene",
	init: function() {
		var t = this,
			e = 200,
			i = t._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
		t.addChild(i, 0);
		var n = 24,
			r = -e / 2 + 100;
		cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
			isCrossOrigin: !1
		}, function(i, n) {
			e = n.height;
			t._initStage(n, cc.visibleRect.center)
		}), n = 14, r = -e / 2 - 10);
		n = t._label = new cc.LabelTTF("Loading... 0%", "Arial", n);
		n.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, r)));
		n.setColor(cc.color(180, 180, 180));
		i.addChild(this._label, 10);
		return !0
	},
	_initStage: function(t, e) {
		var i = this._texture2d = new cc.Texture2D;
		i.initWithElement(t);
		i.handleLoadedTexture();
		i = this._logo = new cc.Sprite(i);
		i.setScale(cc.contentScaleFactor());
		i.x = e.x;
		i.y = e.y;
		this._bgLayer.addChild(i, 10)
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this.schedule(this._startLoading, .3)
	},
	onExit: function() {
		cc.Node.prototype.onExit.call(this);
		this._label.setString("Loading... 0%")
	},
	initWithResources: function(t, e) {
		cc.isString(t) && (t = [t]);
		this.resources = t || [];
		this.cb = e
	},
	_startLoading: function() {
		var t = this;
		t.unschedule(t._startLoading);
		cc.loader.load(t.resources, function(e, i, n) {
			e = Math.min(100 * (n / i) | 0, 100);
			t._label.setString("Loading... " + e + "%")
		}, function() {
			t.cb && t.cb()
		})
	}
});
cc.LoaderScene.preload = function(t, e) {
	var i = cc;
	i.loaderScene || (i.loaderScene = new cc.LoaderScene, i.loaderScene.init());
	i.loaderScene.initWithResources(t, e);
	cc.director.runScene(i.loaderScene);
	return i.loaderScene
};
cc.Layer = cc.Node.extend({
	_className: "Layer",
	ctor: function() {
		var t = cc.Node.prototype;
		t.ctor.call(this);
		this._ignoreAnchorPointForPosition = !0;
		t.setAnchorPoint.call(this, .5, .5);
		t.setContentSize.call(this, cc.winSize)
	},
	init: function() {
		this._ignoreAnchorPointForPosition = !0;
		this.setAnchorPoint(.5, .5);
		this.setContentSize(cc.winSize);
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1;
		return !0
	},
	bake: function() {
		this._renderCmd.bake()
	},
	unbake: function() {
		this._renderCmd.unbake()
	},
	isBaked: function() {
		return this._isBaked
	},
	addChild: function(t, e, i) {
		cc.Node.prototype.addChild.call(this, t, e, i);
		this._renderCmd._bakeForAddChild(t)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Layer.CanvasRenderCmd(this) : new cc.Layer.WebGLRenderCmd(this)
	}
});
cc.Layer.create = function() {
	return new cc.Layer
};
cc.LayerColor = cc.Layer.extend({
	_blendFunc: null,
	_className: "LayerColor",
	getBlendFunc: function() {
		return this._blendFunc
	},
	changeWidthAndHeight: function(t, e) {
		this.width = t;
		this.height = e
	},
	changeWidth: function(t) {
		this.width = t
	},
	changeHeight: function(t) {
		this.height = t
	},
	setOpacityModifyRGB: function(t) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	ctor: function(t, e, i) {
		cc.Layer.prototype.ctor.call(this);
		this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
		cc.LayerColor.prototype.init.call(this, t, e, i)
	},
	init: function(t, e, i) {
		cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
		var n = cc.director.getWinSize();
		t = t || cc.color(0, 0, 0, 255);
		e = void 0 === e ? n.width : e;
		i = void 0 === i ? n.height : i;
		n = this._realColor;
		n.r = t.r;
		n.g = t.g;
		n.b = t.b;
		this._realOpacity = t.a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty);
		cc.LayerColor.prototype.setContentSize.call(this, e, i);
		return !0
	},
	setBlendFunc: function(t, e) {
		var i = this._blendFunc;
		void 0 === e ? (i.src = t.src, i.dst = t.dst) : (i.src = t, i.dst = e);
		this._renderCmd.updateBlendFunc(i)
	},
	_setWidth: function(t) {
		cc.Node.prototype._setWidth.call(this, t);
		this._renderCmd._updateSquareVerticesWidth(t)
	},
	_setHeight: function(t) {
		cc.Node.prototype._setHeight.call(this, t);
		this._renderCmd._updateSquareVerticesHeight(t)
	},
	setContentSize: function(t, e) {
		cc.Layer.prototype.setContentSize.call(this, t, e);
		this._renderCmd._updateSquareVertices(t, e)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LayerColor.CanvasRenderCmd(this) : new cc.LayerColor.WebGLRenderCmd(this)
	}
});
cc.LayerColor.create = function(t, e, i) {
	return new cc.LayerColor(t, e, i)
};
(function() {
	var t = cc.LayerColor.prototype;
	cc.defineGetterSetter(t, "width", t._getWidth, t._setWidth);
	cc.defineGetterSetter(t, "height", t._getHeight, t._setHeight)
})();
cc.LayerGradient = cc.LayerColor.extend({
	_endColor: null,
	_startOpacity: 255,
	_endOpacity: 255,
	_alongVector: null,
	_compressedInterpolation: !1,
	_className: "LayerGradient",
	ctor: function(t, e, i) {
		cc.LayerColor.prototype.ctor.call(this);
		this._endColor = cc.color(0, 0, 0, 255);
		this._alongVector = cc.p(0, -1);
		this._endOpacity = this._startOpacity = 255;
		cc.LayerGradient.prototype.init.call(this, t, e, i)
	},
	init: function(t, e, i) {
		t = t || cc.color(0, 0, 0, 255);
		e = e || cc.color(0, 0, 0, 255);
		i = i || cc.p(0, -1);
		var n = this._endColor;
		this._startOpacity = t.a;
		n.r = e.r;
		n.g = e.g;
		n.b = e.b;
		this._endOpacity = e.a;
		this._alongVector = i;
		this._compressedInterpolation = !0;
		cc.LayerColor.prototype.init.call(this, cc.color(t.r, t.g, t.b, 255));
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty);
		return !0
	},
	setContentSize: function(t, e) {
		cc.LayerColor.prototype.setContentSize.call(this, t, e);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	_setWidth: function(t) {
		cc.LayerColor.prototype._setWidth.call(this, t);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	_setHeight: function(t) {
		cc.LayerColor.prototype._setHeight.call(this, t);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	getStartColor: function() {
		return this._realColor
	},
	setStartColor: function(t) {
		this.color = t
	},
	setEndColor: function(t) {
		this._endColor = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	getEndColor: function() {
		return this._endColor
	},
	setStartOpacity: function(t) {
		this._startOpacity = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getStartOpacity: function() {
		return this._startOpacity
	},
	setEndOpacity: function(t) {
		this._endOpacity = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getEndOpacity: function() {
		return this._endOpacity
	},
	setVector: function(t) {
		this._alongVector.x = t.x;
		this._alongVector.y = t.y;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	getVector: function() {
		return cc.p(this._alongVector.x, this._alongVector.y)
	},
	isCompressedInterpolation: function() {
		return this._compressedInterpolation
	},
	setCompressedInterpolation: function(t) {
		this._compressedInterpolation = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LayerGradient.CanvasRenderCmd(this) : new cc.LayerGradient.WebGLRenderCmd(this)
	}
});
cc.LayerGradient.create = function(t, e, i) {
	return new cc.LayerGradient(t, e, i)
};
(function() {
	var t = cc.LayerGradient.prototype;
	cc.defineGetterSetter(t, "startColor", t.getStartColor, t.setStartColor);
	cc.defineGetterSetter(t, "endColor", t.getEndColor, t.setEndColor);
	cc.defineGetterSetter(t, "startOpacity", t.getStartOpacity, t.setStartOpacity);
	cc.defineGetterSetter(t, "endOpacity", t.getEndOpacity, t.setEndOpacity);
	cc.defineGetterSetter(t, "vector", t.getVector, t.setVector)
})();
cc.LayerMultiplex = cc.Layer.extend({
	_enabledLayer: 0,
	_layers: null,
	_className: "LayerMultiplex",
	ctor: function(t) {
		cc.Layer.prototype.ctor.call(this);
		t instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, t) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
	},
	initWithLayers: function(t) {
		0 < t.length && null == t[t.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
		this._layers = t;
		this._enabledLayer = 0;
		this.addChild(this._layers[this._enabledLayer]);
		return !0
	},
	switchTo: function(t) {
		t >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = t, this.addChild(this._layers[t]))
	},
	switchToAndReleaseMe: function(t) {
		t >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = t, this.addChild(this._layers[t]))
	},
	addLayer: function(t) {
		t ? this._layers.push(t) : cc.log(cc._LogInfos.LayerMultiplex_addLayer)
	}
});
cc.LayerMultiplex.create = function() {
	return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
};
(function() {
	cc.Layer.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._isBaked = !1;
		this._bakeSprite = null
	};
	var t = cc.Layer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.Layer.CanvasRenderCmd;
	t.bake = function() {
		if (!this._isBaked) {
			this._needDraw = !0;
			this._isBaked = this._cacheDirty = cc.renderer.childrenOrderDirty = !0;
			for (var t = this._node._children, e = 0, i = t.length; e < i; e++) t[e]._renderCmd._setCachedParent(this);
			this._bakeSprite || (this._bakeSprite = new cc.BakeSprite, this._bakeSprite._parent = this._node)
		}
	};
	t.unbake = function() {
		if (this._isBaked) {
			cc.renderer.childrenOrderDirty = !0;
			this._isBaked = this._needDraw = !1;
			this._cacheDirty = !0;
			for (var t = this._node._children, e = 0, i = t.length; e < i; e++) t[e]._renderCmd._setCachedParent(null)
		}
	};
	t.isBaked = function() {
		return this._isBaked
	};
	t.rendering = function() {
		if (this._cacheDirty) {
			var t = this._node,
				e = t._children,
				i = this._bakeSprite;
			this.transform(this.getParentRenderCmd(), !0);
			var n = this._getBoundingBoxForBake();
			n.width = 0 | n.width + .5;
			n.height = 0 | n.height + .5;
			var r = i.getCacheContext();
			i.resetCanvasSize(n.width, n.height);
			r.translate(0 - n.x, n.height + n.y);
			var c = cc.affineTransformInvert(this._worldTransform);
			r.transform(c.a, c.c, c.b, c.d, c.tx, -c.ty);
			c = i.getAnchorPointInPoints();
			i.setPosition(c.x + n.x, c.y + n.y);
			t.sortAllChildren();
			cc.renderer._turnToCacheMode(this.__instanceId);
			t = 0;
			for (n = e.length; t < n; t++) e[t].visit(this);
			cc.renderer._renderingToCacheCanvas(r, this.__instanceId);
			i.transform();
			this._cacheDirty = !1
		}
	};
	t.visit = function(t) {
		if (this._isBaked) {
			var e = this._node,
				i = e._children.length;
			e._visible && 0 !== i && (this._syncStatus(t), cc.renderer.pushRenderCommand(this), this._bakeSprite.visit(this), this._dirtyFlag = 0)
		} else cc.Node.CanvasRenderCmd.prototype.visit.call(this, t)
	};
	t._bakeForAddChild = function(t) {
		t._parent == this._node && this._isBaked && t._renderCmd._setCachedParent(this)
	};
	t._getBoundingBoxForBake = function() {
		var t = null,
			e = this._node;
		if (!e._children || 0 === e._children.length) return cc.rect(0, 0, 10, 10);
		for (var e = e._children, i = 0; i < e.length; i++) {
			var n = e[i];
			n && n._visible && (t ? (n = n._getBoundingBoxToCurrentNode()) && (t = cc.rectUnion(t, n)) : t = n._getBoundingBoxToCurrentNode())
		}
		return t
	}
})();
(function() {
	cc.LayerColor.CanvasRenderCmd = function(t) {
		cc.Layer.CanvasRenderCmd.call(this, t);
		this._needDraw = !0;
		this._blendFuncStr = "source-over";
		this._bakeRenderCmd = new cc.CustomRenderCmd(this, this._bakeRendering)
	};
	var t = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
	t.constructor = cc.LayerColor.CanvasRenderCmd;
	t.unbake = function() {
		cc.Layer.CanvasRenderCmd.prototype.unbake.call(this);
		this._needDraw = !0
	};
	t.rendering = function(t, e, i) {
		t = t || cc._renderContext;
		var n = this._node,
			r = this._worldTransform,
			c = this._displayedColor,
			s = this._displayedOpacity / 255,
			o = n._contentSize.width,
			n = n._contentSize.height;
		if (0 !== s) {
			var a = 1 !== r.a || 0 !== r.b || 0 !== r.c || 1 !== r.d,
				h = "source-over" !== this._blendFuncStr || a;
			h && (t.save(), t.globalCompositeOperation = this._blendFuncStr);
			t.globalAlpha = s;
			t.fillStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + ", 1)";
			a ? (t.transform(r.a, r.c, r.b, r.d, r.tx * e, -r.ty * i), t.fillRect(0, 0, o * e, -n * i)) : t.fillRect(r.tx * e, -r.ty * i, o * e, -n * i);
			h && t.restore();
			cc.g_NumberOfDraws++
		}
	};
	t.updateBlendFunc = function(t) {
		this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(t)
	};
	t._updateSquareVertices = t._updateSquareVerticesWidth = t._updateSquareVerticesHeight = function() {};
	t._bakeRendering = function() {
		if (this._cacheDirty) {
			var t = this._node,
				e = this._bakeSprite,
				i = t._children,
				n = i.length;
			this.transform(this.getParentRenderCmd(), !0);
			var r = this._getBoundingBoxForBake();
			r.width |= 0;
			r.height |= 0;
			var c = e.getCacheContext();
			e.resetCanvasSize(r.width, r.height);
			var s = e.getAnchorPointInPoints(),
				o = t._position;
			if (t._ignoreAnchorPointForPosition) c.translate(0 - r.x + o.x, r.height + r.y - o.y), e.setPosition(s.x + r.x - o.x, s.y + r.y - o.y);
			else {
				var a = this.getAnchorPointInPoints(),
					h = o.x - a.x,
					o = o.y - a.y;
				c.translate(0 - r.x + h, r.height + r.y - o);
				e.setPosition(s.x + r.x - h, s.y + r.y - o)
			}
			r = cc.affineTransformInvert(this._worldTransform);
			c.transform(r.a, r.c, r.b, r.d, r.tx, -r.ty);
			cc.renderer._turnToCacheMode(this.__instanceId);
			if (0 < n) {
				t.sortAllChildren();
				for (t = 0; t < n; t++) if (r = i[t], 0 > r._localZOrder) r._renderCmd.visit(this);
				else break;
				for (cc.renderer.pushRenderCommand(this); t < n; t++) i[t]._renderCmd.visit(this)
			} else cc.renderer.pushRenderCommand(this);
			cc.renderer._renderingToCacheCanvas(c, this.__instanceId);
			e.transform(this);
			this._cacheDirty = !1
		}
	};
	t.visit = function(t) {
		this._isBaked ? this._node._visible && (this._syncStatus(t), cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._bakeSprite.visit(this), this._dirtyFlag = 0) : cc.Node.CanvasRenderCmd.prototype.visit.call(this)
	};
	t._getBoundingBoxForBake = function() {
		var t = this._node,
			e = cc.rect(0, 0, t._contentSize.width, t._contentSize.height),
			i = t.getNodeToWorldTransform(),
			e = cc.rectApplyAffineTransform(e, t.getNodeToWorldTransform());
		if (!t._children || 0 === t._children.length) return e;
		for (var t = t._children, n = 0; n < t.length; n++) {
			var r = t[n];
			r && r._visible && (r = r._getBoundingBoxToCurrentNode(i), e = cc.rectUnion(e, r))
		}
		return e
	}
})();
(function() {
	cc.LayerGradient.RenderCmd = {
		updateStatus: function() {
			var t = cc.Node._dirtyFlags,
				e = this._dirtyFlag,
				i = e & t.colorDirty,
				n = e & t.opacityDirty;
			i && this._updateDisplayColor();
			n && this._updateDisplayOpacity();
			e & t.transformDirty && this.transform(null, !0);
			(i || n || e & t.gradientDirty) && this._updateColor();
			this._dirtyFlag = 0
		}
	}
})();
(function() {
	cc.LayerGradient.CanvasRenderCmd = function(t) {
		cc.LayerColor.CanvasRenderCmd.call(this, t);
		this._needDraw = !0;
		this._startPoint = cc.p(0, 0);
		this._endPoint = cc.p(0, 0);
		this._endStopStr = this._startStopStr = null
	};
	var t = cc.LayerGradient.CanvasRenderCmd.prototype = Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
	cc.inject(cc.LayerGradient.RenderCmd, t);
	t.constructor = cc.LayerGradient.CanvasRenderCmd;
	t.rendering = function(t, e, i) {
		t = t || cc._renderContext;
		var n = this._node,
			r = this._displayedOpacity / 255,
			c = this._worldTransform;
		if (0 !== r) {
			var s = 1 !== c.a || 0 !== c.b || 0 !== c.c || 1 !== c.d,
				o = "source-over" !== this._blendFuncStr || s;
			o && (t.save(), t.globalCompositeOperation = this._blendFuncStr);
			t.globalAlpha = r;
			var r = n._contentSize.width,
				n = n._contentSize.height,
				a = t.createLinearGradient(this._startPoint.x, this._startPoint.y, this._endPoint.x, this._endPoint.y);
			a.addColorStop(0, this._startStopStr);
			a.addColorStop(1, this._endStopStr);
			t.fillStyle = a;
			s ? (t.transform(c.a, c.c, c.b, c.d, c.tx * e, -c.ty * i), t.fillRect(0, 0, r * e, -n * i)) : t.fillRect(c.tx * e, -c.ty * i, r * e, -n * i);
			o && t.restore();
			cc.g_NumberOfDraws++
		}
	};
	t._syncStatus = function(t) {
		var e = cc.Node._dirtyFlags,
			i = this._dirtyFlag,
			n = t ? t._node : null;
		n && (n._cascadeColorEnabled && t._dirtyFlag & e.colorDirty) && (i |= e.colorDirty);
		n && (n._cascadeOpacityEnabled && t._dirtyFlag & e.opacityDirty) && (i |= e.opacityDirty);
		t && t._dirtyFlag & e.transformDirty && (i |= e.transformDirty);
		var n = i & e.colorDirty,
			r = i & e.opacityDirty;
		this._dirtyFlag = i;
		n && this._syncDisplayColor();
		r && this._syncDisplayOpacity();
		i & e.transformDirty && this.transform(t);
		(n || r || i & e.gradientDirty) && this._updateColor()
	};
	t._updateColor = function() {
		var t = this._node,
			e = t._contentSize,
			i = t._alongVector,
			n = .5 * e.width,
			e = .5 * e.height;
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
		this._startPoint.x = n * -i.x + n;
		this._startPoint.y = e * i.y - e;
		this._endPoint.x = n * i.x + n;
		this._endPoint.y = e * -i.y - e;
		i = this._displayedColor;
		n = t._endColor;
		e = t._startOpacity / 255;
		t = t._endOpacity / 255;
		this._startStopStr = "rgba(" + Math.round(i.r) + "," + Math.round(i.g) + "," + Math.round(i.b) + "," + e.toFixed(4) + ")";
		this._endStopStr = "rgba(" + Math.round(n.r) + "," + Math.round(n.g) + "," + Math.round(n.b) + "," + t.toFixed(4) + ")"
	}
})();
(function() {
	cc.Layer.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t)
	};
	var t = cc.Layer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	t.constructor = cc.Layer.WebGLRenderCmd;
	t.bake = function() {};
	t.unbake = function() {};
	t._bakeForAddChild = function() {}
})();
(function() {
	cc.LayerColor.WebGLRenderCmd = function(t) {
		cc.Layer.WebGLRenderCmd.call(this, t);
		this._needDraw = !0;
		this._squareVerticesAB = new ArrayBuffer(32);
		this._squareColorsAB = new ArrayBuffer(16);
		t = this._squareVerticesAB;
		var e = this._squareColorsAB,
			i = cc.Vertex2F.BYTES_PER_ELEMENT,
			n = cc.Color.BYTES_PER_ELEMENT;
		this._squareVertices = [new cc.Vertex2F(0, 0, t, 0), new cc.Vertex2F(0, 0, t, i), new cc.Vertex2F(0, 0, t, 2 * i), new cc.Vertex2F(0, 0, t, 3 * i)];
		this._squareColors = [cc.color(0, 0, 0, 255, e, 0), cc.color(0, 0, 0, 255, e, n), cc.color(0, 0, 0, 255, e, 2 * n), cc.color(0, 0, 0, 255, e, 3 * n)];
		this._verticesFloat32Buffer = cc._renderContext.createBuffer();
		this._colorsUint8Buffer = cc._renderContext.createBuffer()
	};
	var t = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
	t.constructor = cc.LayerColor.WebGLRenderCmd;
	cc.LayerColor.WebGLRenderCmd.prototype.rendering = function(t) {
		t = t || cc._renderContext;
		var e = this._node;
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
		cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst);
		t.bindBuffer(t.ARRAY_BUFFER, this._verticesFloat32Buffer);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0);
		t.bindBuffer(t.ARRAY_BUFFER, this._colorsUint8Buffer);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 0, 0);
		t.drawArrays(t.TRIANGLE_STRIP, 0, 4)
	};
	t._updateSquareVertices = function(t, e) {
		var i = this._squareVertices;
		void 0 === e ? (i[1].x = t.width, i[2].y = t.height, i[3].x = t.width, i[3].y = t.height) : (i[1].x = t, i[2].y = e, i[3].x = t, i[3].y = e);
		this._bindLayerVerticesBufferData()
	};
	t._updateSquareVerticesWidth = function(t) {
		var e = this._squareVertices;
		e[1].x = t;
		e[3].x = t;
		this._bindLayerVerticesBufferData()
	};
	t._updateSquareVerticesHeight = function(t) {
		var e = this._squareVertices;
		e[2].y = t;
		e[3].y = t;
		this._bindLayerVerticesBufferData()
	};
	t._updateColor = function() {
		for (var t = this._displayedColor, e = this._displayedOpacity, i = this._squareColors, n = 0; 4 > n; n++) i[n].r = t.r, i[n].g = t.g, i[n].b = t.b, i[n].a = e;
		this._bindLayerColorsBufferData()
	};
	t._bindLayerVerticesBufferData = function() {
		var t = cc._renderContext;
		t.bindBuffer(t.ARRAY_BUFFER, this._verticesFloat32Buffer);
		t.bufferData(t.ARRAY_BUFFER, this._squareVerticesAB, t.STATIC_DRAW)
	};
	t._bindLayerColorsBufferData = function() {
		var t = cc._renderContext;
		t.bindBuffer(t.ARRAY_BUFFER, this._colorsUint8Buffer);
		t.bufferData(t.ARRAY_BUFFER, this._squareColorsAB, t.STATIC_DRAW)
	};
	t.updateBlendFunc = function(t) {}
})();
(function() {
	cc.LayerGradient.WebGLRenderCmd = function(t) {
		cc.LayerColor.WebGLRenderCmd.call(this, t);
		this._needDraw = !0
	};
	var t = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
	cc.inject(cc.LayerGradient.RenderCmd, t);
	t.constructor = cc.LayerGradient.WebGLRenderCmd;
	t._syncStatus = function(t) {
		var e = cc.Node._dirtyFlags,
			i = this._dirtyFlag,
			n = t ? t._node : null;
		n && (n._cascadeColorEnabled && t._dirtyFlag & e.colorDirty) && (i |= e.colorDirty);
		n && (n._cascadeOpacityEnabled && t._dirtyFlag & e.opacityDirty) && (i |= e.opacityDirty);
		t && t._dirtyFlag & e.transformDirty && (i |= e.transformDirty);
		var n = i & e.colorDirty,
			r = i & e.opacityDirty;
		this._dirtyFlag = i;
		n && this._syncDisplayColor();
		r && this._syncDisplayOpacity();
		this.transform(t);
		(n || r || i & e.gradientDirty) && this._updateColor()
	};
	t._updateColor = function() {
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
		var t = this._node,
			e = t._alongVector,
			i = cc.pLength(e);
		if (0 !== i) {
			var n = Math.sqrt(2),
				e = cc.p(e.x / i, e.y / i);
			t._compressedInterpolation && (i = 1 / (Math.abs(e.x) + Math.abs(e.y)), e = cc.pMult(e, i * n));
			var r = this._displayedOpacity / 255,
				i = this._displayedColor,
				c = t._endColor,
				i = {
					r: i.r,
					g: i.g,
					b: i.b,
					a: t._startOpacity * r
				},
				t = {
					r: c.r,
					g: c.g,
					b: c.b,
					a: t._endOpacity * r
				},
				s = this._squareColors,
				r = s[0],
				c = s[1],
				o = s[2],
				s = s[3];
			r.r = t.r + (i.r - t.r) * ((n + e.x + e.y) / (2 * n));
			r.g = t.g + (i.g - t.g) * ((n + e.x + e.y) / (2 * n));
			r.b = t.b + (i.b - t.b) * ((n + e.x + e.y) / (2 * n));
			r.a = t.a + (i.a - t.a) * ((n + e.x + e.y) / (2 * n));
			c.r = t.r + (i.r - t.r) * ((n - e.x + e.y) / (2 * n));
			c.g = t.g + (i.g - t.g) * ((n - e.x + e.y) / (2 * n));
			c.b = t.b + (i.b - t.b) * ((n - e.x + e.y) / (2 * n));
			c.a = t.a + (i.a - t.a) * ((n - e.x + e.y) / (2 * n));
			o.r = t.r + (i.r - t.r) * ((n + e.x - e.y) / (2 * n));
			o.g = t.g + (i.g - t.g) * ((n + e.x - e.y) / (2 * n));
			o.b = t.b + (i.b - t.b) * ((n + e.x - e.y) / (2 * n));
			o.a = t.a + (i.a - t.a) * ((n + e.x - e.y) / (2 * n));
			s.r = t.r + (i.r - t.r) * ((n - e.x - e.y) / (2 * n));
			s.g = t.g + (i.g - t.g) * ((n - e.x - e.y) / (2 * n));
			s.b = t.b + (i.b - t.b) * ((n - e.x - e.y) / (2 * n));
			s.a = t.a + (i.a - t.a) * ((n - e.x - e.y) / (2 * n));
			this._bindLayerColorsBufferData()
		}
	}
})();
cc._tmp.PrototypeSprite = function() {
	var t = cc.Sprite.prototype;
	cc.defineGetterSetter(t, "opacityModifyRGB", t.isOpacityModifyRGB, t.setOpacityModifyRGB);
	cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity);
	cc.defineGetterSetter(t, "color", t.getColor, t.setColor);
	cc.defineGetterSetter(t, "flippedX", t.isFlippedX, t.setFlippedX);
	cc.defineGetterSetter(t, "flippedY", t.isFlippedY, t.setFlippedY);
	cc.defineGetterSetter(t, "offsetX", t._getOffsetX);
	cc.defineGetterSetter(t, "offsetY", t._getOffsetY);
	cc.defineGetterSetter(t, "texture", t.getTexture, t.setTexture);
	cc.defineGetterSetter(t, "textureRectRotated", t.isTextureRectRotated);
	cc.defineGetterSetter(t, "batchNode", t.getBatchNode, t.setBatchNode);
	cc.defineGetterSetter(t, "quad", t.getQuad)
};
cc.Sprite = cc.Node.extend({
	dirty: !1,
	atlasIndex: 0,
	textureAtlas: null,
	_batchNode: null,
	_recursiveDirty: null,
	_hasChildren: null,
	_shouldBeHidden: !1,
	_transformToBatch: null,
	_blendFunc: null,
	_texture: null,
	_rect: null,
	_rectRotated: !1,
	_offsetPosition: null,
	_unflippedOffsetPositionFromCenter: null,
	_opacityModifyRGB: !1,
	_flippedX: !1,
	_flippedY: !1,
	_textureLoaded: !1,
	_className: "Sprite",
	ctor: function(t, e, i) {
		cc.Node.prototype.ctor.call(this);
		this._shouldBeHidden = !1;
		this._offsetPosition = cc.p(0, 0);
		this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		this._rect = cc.rect(0, 0, 0, 0);
		this._textureLoaded = !0;
		this._softInit(t, e, i)
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(t, e) {
		this.addEventListener("load", t, e)
	},
	isDirty: function() {
		return this.dirty
	},
	setDirty: function(t) {
		this.dirty = t
	},
	isTextureRectRotated: function() {
		return this._rectRotated
	},
	getAtlasIndex: function() {
		return this.atlasIndex
	},
	setAtlasIndex: function(t) {
		this.atlasIndex = t
	},
	getTextureRect: function() {
		return cc.rect(this._rect)
	},
	getTextureAtlas: function() {
		return this.textureAtlas
	},
	setTextureAtlas: function(t) {
		this.textureAtlas = t
	},
	getOffsetPosition: function() {
		return cc.p(this._offsetPosition)
	},
	_getOffsetX: function() {
		return this._offsetPosition.x
	},
	_getOffsetY: function() {
		return this._offsetPosition.y
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	initWithSpriteFrame: function(t) {
		cc.assert(t, cc._LogInfos.Sprite_initWithSpriteFrame);
		t.textureLoaded() || (this._textureLoaded = !1, t.addEventListener("load", this._renderCmd._spriteFrameLoadedCallback, this));
		var e = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : t._rotated,
			e = this.initWithTexture(t.getTexture(), t.getRect(), e);
		this.setSpriteFrame(t);
		return e
	},
	initWithSpriteFrameName: function(t) {
		cc.assert(t, cc._LogInfos.Sprite_initWithSpriteFrameName);
		var e = cc.spriteFrameCache.getSpriteFrame(t);
		cc.assert(e, t + cc._LogInfos.Sprite_initWithSpriteFrameName1);
		return this.initWithSpriteFrame(e)
	},
	useBatchNode: function(t) {
		this.textureAtlas = t.getTextureAtlas();
		this._batchNode = t
	},
	setVertexRect: function(t) {
		var e = this._rect;
		e.x = t.x;
		e.y = t.y;
		e.width = t.width;
		e.height = t.height
	},
	sortAllChildren: function() {
		if (this._reorderChildDirty) {
			var t = this._children,
				e = t.length,
				i, n, r;
			for (i = 1; i < e; i++) {
				r = t[i];
				for (n = i - 1; 0 <= n;) {
					if (r._localZOrder < t[n]._localZOrder) t[n + 1] = t[n];
					else if (r._localZOrder === t[n]._localZOrder && r.arrivalOrder < t[n].arrivalOrder) t[n + 1] = t[n];
					else break;
					n--
				}
				t[n + 1] = r
			}
			this._batchNode && this._arrayMakeObjectsPerformSelector(t, cc.Node._stateCallbackType.sortAllChildren);
			this._reorderChildDirty = !1
		}
	},
	reorderChild: function(t, e) {
		cc.assert(t, cc._LogInfos.Sprite_reorderChild_2); - 1 === this._children.indexOf(t) ? cc.log(cc._LogInfos.Sprite_reorderChild) : e !== t.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, t, e))
	},
	removeChild: function(t, e) {
		this._batchNode && this._batchNode.removeSpriteFromAtlas(t);
		cc.Node.prototype.removeChild.call(this, t, e)
	},
	setVisible: function(t) {
		cc.Node.prototype.setVisible.call(this, t);
		this._renderCmd.setDirtyRecursively(!0)
	},
	removeAllChildren: function(t) {
		var e = this._children,
			i = this._batchNode;
		if (i && null != e) for (var n = 0, r = e.length; n < r; n++) i.removeSpriteFromAtlas(e[n]);
		cc.Node.prototype.removeAllChildren.call(this, t);
		this._hasChildren = !1
	},
	ignoreAnchorPointForPosition: function(t) {
		this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, t)
	},
	setFlippedX: function(t) {
		this._flippedX != t && (this._flippedX = t, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
	},
	setFlippedY: function(t) {
		this._flippedY != t && (this._flippedY = t, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
	},
	isFlippedX: function() {
		return this._flippedX
	},
	isFlippedY: function() {
		return this._flippedY
	},
	setOpacityModifyRGB: function(t) {
		this._opacityModifyRGB !== t && (this._opacityModifyRGB = t, this._renderCmd._setColorDirty())
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	setDisplayFrameWithAnimationName: function(t, e) {
		cc.assert(t, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
		var i = cc.animationCache.getAnimation(t);
		i ? (i = i.getFrames()[e]) ? this.setSpriteFrame(i.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
	},
	getBatchNode: function() {
		return this._batchNode
	},
	_setReorderChildDirtyRecursively: function() {
		if (!this._reorderChildDirty) {
			this._reorderChildDirty = !0;
			for (var t = this._parent; t && t != this._batchNode;) t._setReorderChildDirtyRecursively(), t = t.parent
		}
	},
	getTexture: function() {
		return this._texture
	},
	_softInit: function(t, e, i) {
		if (void 0 === t) cc.Sprite.prototype.init.call(this);
		else if (cc.isString(t))"#" === t[0] ? (t = t.substr(1, t.length - 1), t = cc.spriteFrameCache.getSpriteFrame(t), this.initWithSpriteFrame(t)) : cc.Sprite.prototype.init.call(this, t, e);
		else if (cc.isObject(t)) if (t instanceof cc.Texture2D) this.initWithTexture(t, e, i);
		else if (t instanceof cc.SpriteFrame) this.initWithSpriteFrame(t);
		else if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) e = new cc.Texture2D, e.initWithElement(t), e.handleLoadedTexture(), this.initWithTexture(e)
	},
	getQuad: function() {
		return this._renderCmd.getQuad()
	},
	setBlendFunc: function(t, e) {
		var i = this._blendFunc;
		void 0 === e ? (i.src = t.src, i.dst = t.dst) : (i.src = t, i.dst = e);
		this._renderCmd.updateBlendFunc(i)
	},
	init: function() {
		if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
		cc.Node.prototype.init.call(this);
		this.dirty = this._recursiveDirty = !1;
		this._blendFunc.src = cc.BLEND_SRC;
		this._blendFunc.dst = cc.BLEND_DST;
		this.texture = null;
		this._textureLoaded = !0;
		this._flippedX = this._flippedY = !1;
		this.anchorY = this.anchorX = .5;
		this._offsetPosition.x = 0;
		this._offsetPosition.y = 0;
		this._hasChildren = !1;
		this._renderCmd._init();
		this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
		return !0
	},
	initWithFile: function(t, e) {
		cc.assert(t, cc._LogInfos.Sprite_initWithFile);
		var i = cc.textureCache.getTextureForKey(t);
		if (i) {
			if (!e) {
				var n = i.getContentSize();
				e = cc.rect(0, 0, n.width, n.height)
			}
			return this.initWithTexture(i, e)
		}
		i = cc.textureCache.addImage(t);
		return this.initWithTexture(i, e || cc.rect(0, 0, i._contentSize.width, i._contentSize.height))
	},
	initWithTexture: function(t, e, i) {
		cc.assert(0 != arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
		i = i || !1;
		t = this._renderCmd._handleTextureForRotatedTexture(t, e, i);
		if (!cc.Node.prototype.init.call(this)) return !1;
		this._batchNode = null;
		this.dirty = this._recursiveDirty = !1;
		this._opacityModifyRGB = !0;
		this._blendFunc.src = cc.BLEND_SRC;
		this._blendFunc.dst = cc.BLEND_DST;
		this._flippedX = this._flippedY = !1;
		this.setAnchorPoint(.5, .5);
		this._offsetPosition.x = 0;
		this._offsetPosition.y = 0;
		this._hasChildren = !1;
		this._renderCmd._init();
		var n = t.isLoaded();
		this._textureLoaded = n;
		if (!n) return this._rectRotated = i, e && (this._rect.x = e.x, this._rect.y = e.y, this._rect.width = e.width, this._rect.height = e.height), this.texture && this.texture.removeEventListener("load", this), t.addEventListener("load", this._renderCmd._textureLoadedCallback, this), this.texture = t, !0;
		e || (e = cc.rect(0, 0, t.width, t.height));
		this._renderCmd._checkTextureBoundary(t, e, i);
		this.texture = t;
		this.setTextureRect(e, i);
		this.setBatchNode(null);
		return !0
	},
	setTextureRect: function(t, e, i, n) {
		this._rectRotated = e || !1;
		this.setContentSize(i || t);
		this.setVertexRect(t);
		this._renderCmd._setTextureCoords(t, n);
		t = this._unflippedOffsetPositionFromCenter;
		this._flippedX && (t.x = -t.x);
		this._flippedY && (t.y = -t.y);
		e = this._rect;
		this._offsetPosition.x = t.x + (this._contentSize.width - e.width) / 2;
		this._offsetPosition.y = t.y + (this._contentSize.height - e.height) / 2;
		this._batchNode ? this.dirty = !0 : this._renderCmd._resetForBatchNode()
	},
	updateTransform: function() {
		this._renderCmd.updateTransform()
	},
	addChild: function(t, e, i) {
		cc.assert(t, cc._LogInfos.CCSpriteBatchNode_addChild_2);
		null == e && (e = t._localZOrder);
		null == i && (i = t.tag);
		this._renderCmd._setBatchNodeForAddChild(t) && (cc.Node.prototype.addChild.call(this, t, e, i), this._hasChildren = !0)
	},
	setSpriteFrame: function(t) {
		var e = this;
		cc.isString(t) && (t = cc.spriteFrameCache.getSpriteFrame(t), cc.assert(t, cc._LogInfos.Sprite_setSpriteFrame));
		this.setNodeDirty(!0);
		var i = t.getOffset();
		e._unflippedOffsetPositionFromCenter.x = i.x;
		e._unflippedOffsetPositionFromCenter.y = i.y;
		e._rectRotated = t.isRotated();
		i = t.getTexture();
		t.textureLoaded() || (e._textureLoaded = !1, t.addEventListener("load", function(t) {
			e._textureLoaded = !0;
			var i = t.getTexture();
			i != e._texture && (e.texture = i);
			e.setTextureRect(t.getRect(), t.isRotated(), t.getOriginalSize());
			e.dispatchEvent("load")
		}, e));
		i != e._texture && (e.texture = i);
		e.setTextureRect(t.getRect(), e._rectRotated, t.getOriginalSize());
		this._renderCmd._updateForSetSpriteFrame(i)
	},
	setDisplayFrame: function(t) {
		cc.log(cc._LogInfos.Sprite_setDisplayFrame);
		this.setSpriteFrame(t)
	},
	isFrameDisplayed: function(t) {
		return this._renderCmd.isFrameDisplayed(t)
	},
	displayFrame: function() {
		return new cc.SpriteFrame(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
	},
	setBatchNode: function(t) {
		(this._batchNode = t) ? (this._transformToBatch = cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.getTextureAtlas()) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1, this._renderCmd._resetForBatchNode())
	},
	setTexture: function(t) {
		var e = this;
		if (t && cc.isString(t)) {
			t = cc.textureCache.addImage(t);
			e.setTexture(t);
			var i = t.getContentSize();
			e.setTextureRect(cc.rect(0, 0, i.width, i.height));
			t._isLoaded || t.addEventListener("load", function() {
				var i = t.getContentSize();
				e.setTextureRect(cc.rect(0, 0, i.width, i.height))
			}, this)
		} else cc.assert(!t || t instanceof cc.Texture2D, cc._LogInfos.Sprite_setTexture_2), this._renderCmd._setTexture(t)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Sprite.CanvasRenderCmd(this) : new cc.Sprite.WebGLRenderCmd(this)
	}
});
cc.Sprite.create = function(t, e, i) {
	return new cc.Sprite(t, e, i)
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
(function() {
	cc.Sprite.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._needDraw = !0;
		this._textureCoord = {
			renderX: 0,
			renderY: 0,
			x: 0,
			y: 0,
			width: 0,
			height: 0,
			validRect: !1
		};
		this._blendFuncStr = "source-over";
		this._needSetBlend = this._colorized = !1;
		this._originalTexture = null
	};
	var t = cc.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.Sprite.CanvasRenderCmd;
	t._init = function() {};
	t.setDirtyRecursively = function(t) {};
	t._resetForBatchNode = function() {};
	t._setTexture = function(t) {
		var e = this._node;
		e._texture != t && (t && t.getHtmlElementObj() instanceof HTMLImageElement && (this._originalTexture = t), e._texture = t)
	};
	t._setColorDirty = function() {
		this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty)
	};
	t.isFrameDisplayed = function(t) {
		var e = this._node;
		return t.getTexture() != e._texture ? !1 : cc.rectEqualToRect(t.getRect(), e._rect)
	};
	t.updateBlendFunc = function(t) {
		this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(t);
		this._needSetBlend = "source-over" !== this._blendFuncStr
	};
	t._setBatchNodeForAddChild = function(t) {
		return !0
	};
	t._handleTextureForRotatedTexture = function(t, e, i) {
		i && t.isLoaded() && (t = t.getHtmlElementObj(), t = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(t, e), i = new cc.Texture2D, i.initWithElement(t), i.handleLoadedTexture(), t = i, this._node._rect = cc.rect(0, 0, e.width, e.height));
		return t
	};
	t._checkTextureBoundary = function(t, e, i) {
		t && t.url && (i = e.y + e.height, e.x + e.width > t.width && cc.error(cc._LogInfos.RectWidth, t.url), i > t.height && cc.error(cc._LogInfos.RectHeight, t.url));
		this._node._originalTexture = t
	};
	t.rendering = function(t, e, i) {
		var n = this._node;
		t = t || cc._renderContext;
		var r = this._textureCoord,
			c = this._displayedOpacity / 255;
		if (!(n._texture && (0 === r.width || 0 === r.height || !n._texture._isLoaded) || 0 === c)) {
			var s = this._worldTransform,
				o = n._offsetPosition.x,
				a = -n._offsetPosition.y - n._rect.height,
				h = n._rect.width,
				l = n._rect.height;
			1 !== s.a || 0 !== s.b || 0 !== s.c || 1 !== s.d || n._flippedX || n._flippedY ? (t.save(), t.globalAlpha = c, t.transform(s.a, s.c, s.b, s.d, s.tx * e, -s.ty * i), this._needSetBlend && (t.globalCompositeOperation = this._blendFuncStr), n._flippedX && (o = -o - h, t.scale(-1, 1)), n._flippedY && (a = n._offsetPosition.y, t.scale(1, -1)), n._texture ? (c = n._texture._htmlElementObj, "" != n._texture._pattern ? (t.save(), t.fillStyle = t.createPattern(c, n._texture._pattern), t.fillRect(o * e, a * i, h * e, l * i), t.restore()) : this._colorized ? t.drawImage(c, 0, 0, r.width, r.height, o * e, a * i, h * e, l * i) : t.drawImage(c, r.renderX, r.renderY, r.width, r.height, o * e, a * i, h * e, l * i)) : (n = n._contentSize, r.validRect && (r = this._displayedColor, t.fillStyle = "rgba(" + r.r + "," + r.g + "," + r.b + ",1)", t.fillRect(o * e, a * i, n.width * e, n.height * i))), t.restore()) : (this._needSetBlend && (t.save(), t.globalCompositeOperation = this._blendFuncStr), t.globalAlpha = c, n._texture ? (c = n._texture.getHtmlElementObj(), "" != n._texture._pattern ? (t.save(), t.transform(s.a, s.c, s.b, s.d, s.tx * e, -s.ty * i), t.fillStyle = t.createPattern(c, n._texture._pattern), t.fillRect(o * e, a * i, h * e, l * i), t.restore()) : this._colorized ? t.drawImage(c, 0, 0, r.width, r.height, (s.tx + o) * e, (-s.ty + a) * i, h * e, l * i) : t.drawImage(c, r.renderX, r.renderY, r.width, r.height, (s.tx + o) * e, (-s.ty + a) * i, h * e, l * i)) : (n = n._contentSize, r.validRect && (r = this._displayedColor, t.fillStyle = "rgba(" + r.r + "," + r.g + "," + r.b + ",1)", t.fillRect((s.tx + o) * e, (-s.ty + a) * i, n.width * e, n.height * i))), this._needSetBlend && t.restore());
			cc.g_NumberOfDraws++
		}
	};
	t._updateColor = function() {
		var t = this._node,
			e = this._displayedColor;
		if (this._colorized) {
			if (255 === e.r && 255 === e.g && 255 === e.b) {
				this._colorized = !1;
				t.texture = this._originalTexture;
				return
			}
		} else if (255 === e.r && 255 === e.g && 255 === e.b) return;
		var i, n = t._texture,
			r = this._textureCoord;
		if (n && (r.validRect && this._originalTexture) && (i = n.getHtmlElementObj())) if (cc.sys._supportCanvasNewBlendModes) this._colorized = !0, i instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor && this._originalTexture._htmlElementObj != i ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, e, r, i) : (i = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, e, r), n = new cc.Texture2D, n.initWithElement(i), n.handleLoadedTexture(), t.texture = n);
		else if (n = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) this._colorized = !0, i instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.Sprite.CanvasRenderCmd._generateTintImage(i, n, e, r, i) : (i = cc.Sprite.CanvasRenderCmd._generateTintImage(i, n, e, r), n = new cc.Texture2D, n.initWithElement(i), n.handleLoadedTexture(), t.texture = n)
	};
	t.getQuad = function() {
		return null
	};
	t._updateForSetSpriteFrame = function(t, e) {
		var i = this._node;
		i._rectRotated && (i._originalTexture = t);
		this._colorized = !1;
		this._textureCoord.renderX = this._textureCoord.x;
		this._textureCoord.renderY = this._textureCoord.y;
		e && (i = i.getColor(), (255 !== i.r || 255 !== i.g || 255 !== i.b) && this._updateColor())
	};
	t.updateTransform = function() {
		var t = this._node;
		if (t.dirty) {
			var e = t._parent;
			!t._visible || e && e != t._batchNode && e._shouldBeHidden ? t._shouldBeHidden = !0 : (t._shouldBeHidden = !1, t._transformToBatch = !e || e == t._batchNode ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), e._transformToBatch));
			t._recursiveDirty = !1;
			t.dirty = !1
		}
		t._hasChildren && t._arrayMakeObjectsPerformSelector(t._children, cc.Node._stateCallbackType.updateTransform)
	};
	t._updateDisplayColor = function(t) {
		cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, t);
		this._updateColor()
	};
	t._spriteFrameLoadedCallback = function(t) {
		this.setTextureRect(t.getRect(), t.isRotated(), t.getOriginalSize());
		t = this.getColor();
		(255 !== t.r || 255 !== t.g || 255 !== t.b) && this._updateColor();
		this.dispatchEvent("load")
	};
	t._textureLoadedCallback = function(t) {
		if (!this._textureLoaded) {
			this._textureLoaded = !0;
			var e = this._rect,
				i = this._renderCmd;
			e ? cc._rectEqualToZero(e) && (e.width = t.width, e.height = t.height) : e = cc.rect(0, 0, t.width, t.height);
			this.texture = i._originalTexture = t;
			this.setTextureRect(e, this._rectRotated);
			t = i._displayedColor;
			(255 != t.r || 255 != t.g || 255 != t.b) && i._updateColor();
			this.setBatchNode(this._batchNode);
			this.dispatchEvent("load")
		}
	};
	t._setTextureCoords = function(t, e) {
		void 0 === e && (e = !0);
		var i = this._textureCoord,
			n = e ? cc.contentScaleFactor() : 1;
		i.renderX = i.x = 0 | t.x * n;
		i.renderY = i.y = 0 | t.y * n;
		i.width = 0 | t.width * n;
		i.height = 0 | t.height * n;
		i.validRect = !(0 === i.width || 0 === i.height || 0 > i.x || 0 > i.y)
	};
	cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply = function(t, e, i, n) {
		n = n || cc.newElement("canvas");
		i = i || cc.rect(0, 0, t.width, t.height);
		var r = n.getContext("2d");
		n.width != i.width || n.height != i.height ? (n.width = i.width, n.height = i.height) : r.globalCompositeOperation = "source-over";
		r.fillStyle = "rgb(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + ")";
		r.fillRect(0, 0, i.width, i.height);
		r.globalCompositeOperation = "multiply";
		r.drawImage(t, i.x, i.y, i.width, i.height, 0, 0, i.width, i.height);
		r.globalCompositeOperation = "destination-atop";
		r.drawImage(t, i.x, i.y, i.width, i.height, 0, 0, i.width, i.height);
		return n
	};
	cc.Sprite.CanvasRenderCmd._generateTintImage = function(t, e, i, n, r) {
		n || (n = cc.rect(0, 0, t.width, t.height));
		t = i.r / 255;
		var c = i.g / 255;
		i = i.b / 255;
		var s = Math.min(n.width, e[0].width),
			o = Math.min(n.height, e[0].height),
			a;
		r ? (a = r.getContext("2d"), a.clearRect(0, 0, s, o)) : (r = cc.newElement("canvas"), r.width = s, r.height = o, a = r.getContext("2d"));
		a.save();
		a.globalCompositeOperation = "lighter";
		var h = a.globalAlpha;
		0 < t && (a.globalAlpha = t * h, a.drawImage(e[0], n.x, n.y, s, o, 0, 0, s, o));
		0 < c && (a.globalAlpha = c * h, a.drawImage(e[1], n.x, n.y, s, o, 0, 0, s, o));
		0 < i && (a.globalAlpha = i * h, a.drawImage(e[2], n.x, n.y, s, o, 0, 0, s, o));
		1 > t + c + i && (a.globalAlpha = h, a.drawImage(e[3], n.x, n.y, s, o, 0, 0, s, o));
		a.restore();
		return r
	};
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor = function(t) {
		function e() {
			var e = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor,
				n = t.width,
				r = t.height;
			i[0].width = n;
			i[0].height = r;
			i[1].width = n;
			i[1].height = r;
			i[2].width = n;
			i[2].height = r;
			i[3].width = n;
			i[3].height = r;
			e.canvas.width = n;
			e.canvas.height = r;
			var c = e.canvas.getContext("2d");
			c.drawImage(t, 0, 0);
			e.tempCanvas.width = n;
			e.tempCanvas.height = r;
			for (var c = c.getImageData(0, 0, n, r).data, s = 0; 4 > s; s++) {
				var o = i[s].getContext("2d");
				o.getImageData(0, 0, n, r).data;
				e.tempCtx.drawImage(t, 0, 0);
				for (var a = e.tempCtx.getImageData(0, 0, n, r), h = a.data, l = 0; l < c.length; l += 4) h[l] = 0 === s ? c[l] : 0, h[l + 1] = 1 === s ? c[l + 1] : 0, h[l + 2] = 2 === s ? c[l + 2] : 0, h[l + 3] = c[l + 3];
				o.putImageData(a, 0, 0)
			}
			t.onload = null
		}
		if (t.channelCache) return t.channelCache;
		var i = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
		try {
			e()
		} catch (n) {
			t.onload = e
		}
		return t.channelCache = i
	};
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.canvas = cc.newElement("canvas");
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas = cc.newElement("canvas");
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCtx = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas.getContext("2d");
	cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(t, e) {
		if (!t) return null;
		if (!e) return t;
		var i = cc.newElement("canvas");
		i.width = e.width;
		i.height = e.height;
		var n = i.getContext("2d");
		n.translate(i.width / 2, i.height / 2);
		n.rotate(-1.5707963267948966);
		n.drawImage(t, e.x, e.y, e.height, e.width, -e.height / 2, -e.width / 2, e.height, e.width);
		return i
	}
})();
(function() {
	cc.Sprite.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !0;
		this._quad = new cc.V3F_C4B_T2F_Quad;
		this._quadWebBuffer = cc._renderContext.createBuffer();
		this._quadDirty = !0;
		this._recursiveDirty = this._dirty = !1
	};
	var t = cc.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	t.constructor = cc.Sprite.WebGLRenderCmd;
	t.updateBlendFunc = function(t) {};
	t.setDirtyFlag = function(t) {
		cc.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, t);
		this._dirty = !0
	};
	t.setDirtyRecursively = function(t) {
		this._dirty = this._recursiveDirty = t;
		for (var e = this._node._children, i, n = e ? e.length : 0, r = 0; r < n; r++) i = e[r], i instanceof cc.Sprite && i._renderCmd.setDirtyRecursively(t)
	};
	t._setBatchNodeForAddChild = function(t) {
		var e = this._node;
		if (e._batchNode) {
			if (!(t instanceof cc.Sprite)) return cc.log(cc._LogInfos.Sprite_addChild), !1;
			t.texture._webTextureObj !== e.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2);
			e._batchNode.appendChild(t);
			e._reorderChildDirty || e._setReorderChildDirtyRecursively()
		}
		return !0
	};
	t._handleTextureForRotatedTexture = function(t) {
		return t
	};
	t.isFrameDisplayed = function(t) {
		var e = this._node;
		return cc.rectEqualToRect(t.getRect(), e._rect) && t.getTexture().getName() == e._texture.getName() && cc.pointEqualToPoint(t.getOffset(), e._unflippedOffsetPositionFromCenter)
	};
	t._init = function() {
		var t = {
			r: 255,
			g: 255,
			b: 255,
			a: 255
		},
			e = this._quad;
		e.bl.colors = t;
		e.br.colors = t;
		e.tl.colors = t;
		e.tr.colors = t;
		this._quadDirty = !0
	};
	t._resetForBatchNode = function() {
		var t = this._node,
			e = t._offsetPosition.x,
			i = t._offsetPosition.y,
			n = e + t._rect.width,
			t = i + t._rect.height,
			r = this._quad;
		r.bl.vertices = {
			x: e,
			y: i,
			z: 0
		};
		r.br.vertices = {
			x: n,
			y: i,
			z: 0
		};
		r.tl.vertices = {
			x: e,
			y: t,
			z: 0
		};
		r.tr.vertices = {
			x: n,
			y: t,
			z: 0
		};
		this._quadDirty = !0
	};
	t.getQuad = function() {
		return this._quad
	};
	t._updateForSetSpriteFrame = function() {};
	t._spriteFrameLoadedCallback = function(t) {
		this.setTextureRect(t.getRect(), t.isRotated(), t.getOriginalSize());
		this.dispatchEvent("load")
	};
	t._textureLoadedCallback = function(t) {
		var e = this._renderCmd;
		if (!this._textureLoaded) {
			this._textureLoaded = !0;
			var i = this._rect;
			i ? cc._rectEqualToZero(i) && (i.width = t.width, i.height = t.height) : i = cc.rect(0, 0, t.width, t.height);
			this.texture = t;
			this.setTextureRect(i, this._rectRotated);
			this.setBatchNode(this._batchNode);
			e._quadDirty = !0;
			this.dispatchEvent("load")
		}
	};
	t._setTextureCoords = function(t, e) {
		void 0 === e && (e = !0);
		e && (t = cc.rectPointsToPixels(t));
		var i = this._node,
			n = i._batchNode ? i.textureAtlas.texture : i._texture;
		if (n) {
			var r = n.pixelsWidth,
				c = n.pixelsHeight,
				s, o, a = this._quad;
			i._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (n = (2 * t.x + 1) / (2 * r), r = n + (2 * t.height - 2) / (2 * r), s = (2 * t.y + 1) / (2 * c), c = s + (2 * t.width - 2) / (2 * c)) : (n = t.x / r, r = (t.x + t.height) / r, s = t.y / c, c = (t.y + t.width) / c), i._flippedX && (o = s, s = c, c = o), i._flippedY && (o = n, n = r, r = o), a.bl.texCoords.u = n, a.bl.texCoords.v = s, a.br.texCoords.u = n, a.br.texCoords.v = c, a.tl.texCoords.u = r, a.tl.texCoords.v = s, a.tr.texCoords.u = r, a.tr.texCoords.v = c) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (n = (2 * t.x + 1) / (2 * r), r = n + (2 * t.width - 2) / (2 * r), s = (2 * t.y + 1) / (2 * c), c = s + (2 * t.height - 2) / (2 * c)) : (n = t.x / r, r = (t.x + t.width) / r, s = t.y / c, c = (t.y + t.height) / c), i._flippedX && (o = n, n = r, r = o), i._flippedY && (o = s, s = c, c = o), a.bl.texCoords.u = n, a.bl.texCoords.v = c, a.br.texCoords.u = r, a.br.texCoords.v = c, a.tl.texCoords.u = n, a.tl.texCoords.v = s, a.tr.texCoords.u = r, a.tr.texCoords.v = s);
			this._quadDirty = !0
		}
	};
	t.transform = function(t, e) {
		cc.Node.WebGLRenderCmd.prototype.transform.call(this, t, e);
		this._dirty = !0
	};
	t._setColorDirty = function() {};
	t._updateColor = function() {
		var t = this._displayedColor,
			e = this._displayedOpacity,
			i = this._node,
			t = {
				r: t.r,
				g: t.g,
				b: t.b,
				a: e
			};
		i._opacityModifyRGB && (t.r *= e / 255, t.g *= e / 255, t.b *= e / 255);
		e = this._quad;
		e.bl.colors = t;
		e.br.colors = t;
		e.tl.colors = t;
		e.tr.colors = t;
		i._batchNode && (i.atlasIndex != cc.Sprite.INDEX_NOT_INITIALIZED ? i.textureAtlas.updateQuad(e, i.atlasIndex) : this._dirty = !0);
		this._quadDirty = !0
	};
	t._updateBlendFunc = function() {
		if (this._batchNode) cc.log(cc._LogInfos.Sprite__updateBlendFunc);
		else {
			var t = this._node;
			!t._texture || !t._texture.hasPremultipliedAlpha() ? (t._blendFunc.src = cc.SRC_ALPHA, t._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, t.opacityModifyRGB = !1) : (t._blendFunc.src = cc.BLEND_SRC, t._blendFunc.dst = cc.BLEND_DST, t.opacityModifyRGB = !0)
		}
	};
	t._setTexture = function(t) {
		var e = this._node;
		e._batchNode && e._batchNode.texture != t ? cc.log(cc._LogInfos.Sprite_setTexture) : (this._shaderProgram = t ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR), !e._batchNode && e._texture != t && (e._texture = t, this._updateBlendFunc()))
	};
	t.updateTransform = function() {
		var t = this._node;
		if (this._dirty) {
			var e = this._quad,
				i = t._parent;
			if (!t._visible || i && i != t._batchNode && i._shouldBeHidden) e.br.vertices = e.tl.vertices = e.tr.vertices = e.bl.vertices = {
				x: 0,
				y: 0,
				z: 0
			}, t._shouldBeHidden = !0;
			else {
				t._shouldBeHidden = !1;
				0 !== this._dirtyFlag && (this.updateStatus(), this._dirtyFlag = 0);
				t._transformToBatch = !i || i == t._batchNode ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), i._transformToBatch);
				var n = t._transformToBatch,
					r = t._rect,
					i = t._offsetPosition.x,
					c = t._offsetPosition.y,
					s = i + r.width,
					o = c + r.height,
					a = n.tx,
					h = n.ty,
					l = n.a,
					u = n.b,
					d = n.d,
					_ = -n.c,
					n = i * l - c * _ + a,
					r = i * u + c * d + h,
					f = s * l - c * _ + a,
					c = s * u + c * d + h,
					p = s * l - o * _ + a,
					s = s * u + o * d + h,
					a = i * l - o * _ + a,
					i = i * u + o * d + h,
					o = t._vertexZ;
				cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (n |= 0, r |= 0, f |= 0, c |= 0, p |= 0, s |= 0, a |= 0, i |= 0);
				e.bl.vertices = {
					x: n,
					y: r,
					z: o
				};
				e.br.vertices = {
					x: f,
					y: c,
					z: o
				};
				e.tl.vertices = {
					x: a,
					y: i,
					z: o
				};
				e.tr.vertices = {
					x: p,
					y: s,
					z: o
				}
			}
			t.textureAtlas.updateQuad(e, t.atlasIndex);
			this._dirty = t._recursiveDirty = !1
		}
		t._hasChildren && t._arrayMakeObjectsPerformSelector(t._children, cc.Node._stateCallbackType.updateTransform)
	};
	t._checkTextureBoundary = function(t, e, i) {
		t && t.url && (i ? (i = e.x + e.height, e = e.y + e.width) : (i = e.x + e.width, e = e.y + e.height), i > t.width && cc.error(cc._LogInfos.RectWidth, t.url), e > t.height && cc.error(cc._LogInfos.RectHeight, t.url))
	};
	t.rendering = function(t) {
		var e = this._node;
		if (e._textureLoaded && 0 !== this._displayedOpacity) {
			t = t || cc._renderContext;
			var i = e._texture;
			i ? i._isLoaded && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst), cc.glBindTexture2DN(0, i), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), t.bindBuffer(t.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (t.bufferData(t.ARRAY_BUFFER, this._quad.arrayBuffer, t.DYNAMIC_DRAW), this._quadDirty = !1), t.vertexAttribPointer(0, 3, t.FLOAT, !1, 24, 0), t.vertexAttribPointer(1, 4, t.UNSIGNED_BYTE, !0, 24, 12), t.vertexAttribPointer(2, 2, t.FLOAT, !1, 24, 16), t.drawArrays(t.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), t.bindBuffer(t.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (t.bufferData(t.ARRAY_BUFFER, this._quad.arrayBuffer, t.STATIC_DRAW), this._quadDirty = !1), t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, t.FLOAT, !1, 24, 0), t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 24, 12), t.drawArrays(t.TRIANGLE_STRIP, 0, 4));
			cc.g_NumberOfDraws++;
			if (0 !== cc.SPRITE_DEBUG_DRAW || e._showNode) cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.current_stack.stack.push(cc.current_stack.top), cc.current_stack.top = this._stackMatrix, 1 === cc.SPRITE_DEBUG_DRAW || e._showNode ? (e = this._quad, e = [cc.p(e.tl.vertices.x, e.tl.vertices.y), cc.p(e.bl.vertices.x, e.bl.vertices.y), cc.p(e.br.vertices.x, e.br.vertices.y), cc.p(e.tr.vertices.x, e.tr.vertices.y)], cc._drawingUtil.drawPoly(e, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (t = e.getTextureRect(), e = e.getOffsetPosition(), e = [cc.p(e.x, e.y), cc.p(e.x + t.width, e.y), cc.p(e.x + t.width, e.y + t.height), cc.p(e.x, e.y + t.height)], cc._drawingUtil.drawPoly(e, 4, !0)), cc.current_stack.top = cc.current_stack.stack.pop()
		}
	}
})();
cc.SpriteBatchNode = cc.Node.extend({
	_blendFunc: null,
	_descendants: null,
	_className: "SpriteBatchNode",
	ctor: function(t, e) {
		cc.Node.prototype.ctor.call(this);
		this._descendants = [];
		this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
		var i;
		e = e || cc.SpriteBatchNode.DEFAULT_CAPACITY;
		cc.isString(t) ? (i = cc.textureCache.getTextureForKey(t)) || (i = cc.textureCache.addImage(t)) : t instanceof cc.Texture2D && (i = t);
		i && this.initWithTexture(i, e)
	},
	addSpriteWithoutQuad: function(t, e, i) {
		cc.assert(t, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2);
		if (!(t instanceof cc.Sprite)) return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
		t.atlasIndex = e;
		var n = 0,
			r, c = this._descendants;
		if (c && 0 < c.length) {
			n = 0;
			for (r = c.length; n < r; n++) {
				var s = c[n];
				if (s && s.atlasIndex >= e) break
			}
		}
		c.splice(n, 0, t);
		cc.Node.prototype.addChild.call(this, t, e, i);
		this.reorderBatch(!1);
		return this
	},
	getTextureAtlas: function() {
		return this._renderCmd.getTextureAtlas()
	},
	setTextureAtlas: function(t) {
		this._renderCmd.getTextureAtlas(t)
	},
	getDescendants: function() {
		return this._descendants
	},
	initWithFile: function(t, e) {
		var i = cc.textureCache.getTextureForKey(t);
		i || (i = cc.textureCache.addImage(t));
		return this.initWithTexture(i, e)
	},
	_setNodeDirtyForCache: function() {
		this._renderCmd && this._renderCmd._setNodeDirtyForCache && this._renderCmd._setNodeDirtyForCache()
	},
	init: function(t, e) {
		var i = cc.textureCache.getTextureForKey(t);
		i || (i = cc.textureCache.addImage(t));
		return this.initWithTexture(i, e)
	},
	increaseAtlasCapacity: function() {
		this._renderCmd.increaseAtlasCapacity()
	},
	removeChildAtIndex: function(t, e) {
		this.removeChild(this._children[t], e)
	},
	rebuildIndexInOrder: function(t, e) {
		var i = t.children;
		if (i && 0 < i.length) for (var n = 0; n < i.length; n++) {
			var r = i[n];
			r && 0 > r.zIndex && (e = this.rebuildIndexInOrder(r, e))
		}!t == this && (t.atlasIndex = e, e++);
		if (i && 0 < i.length) for (n = 0; n < i.length; n++)(r = i[n]) && 0 <= r.zIndex && (e = this.rebuildIndexInOrder(r, e));
		return e
	},
	highestAtlasIndexInChild: function(t) {
		var e = t.children;
		return !e || 0 == e.length ? t.atlasIndex : this.highestAtlasIndexInChild(e[e.length - 1])
	},
	lowestAtlasIndexInChild: function(t) {
		var e = t.children;
		return !e || 0 == e.length ? t.atlasIndex : this.lowestAtlasIndexInChild(e[e.length - 1])
	},
	atlasIndexForChild: function(t, e) {
		var i = t.parent,
			n = i.children,
			r = n.indexOf(t),
			c = null;
		0 < r && r < cc.UINT_MAX && (c = n[r - 1]);
		return i == this ? 0 == r ? 0 : this.highestAtlasIndexInChild(c) + 1 : 0 == r ? 0 > e ? i.atlasIndex : i.atlasIndex + 1 : 0 > c.zIndex && 0 > e || 0 <= c.zIndex && 0 <= e ? this.highestAtlasIndexInChild(c) + 1 : i.atlasIndex + 1
	},
	reorderBatch: function(t) {
		this._reorderChildDirty = t
	},
	setBlendFunc: function(t, e) {
		this._blendFunc = void 0 === e ? t : {
			src: t,
			dst: e
		}
	},
	getBlendFunc: function() {
		return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
	},
	reorderChild: function(t, e) {
		cc.assert(t, cc._LogInfos.SpriteBatchNode_reorderChild_2); - 1 === this._children.indexOf(t) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : e !== t.zIndex && cc.Node.prototype.reorderChild.call(this, t, e)
	},
	removeChild: function(t, e) {
		null != t && (-1 === this._children.indexOf(t) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(t), cc.Node.prototype.removeChild.call(this, t, e)))
	},
	updateQuadFromSprite: function(t, e) {
		cc.assert(t, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2);
		t instanceof cc.Sprite ? (this._renderCmd.checkAtlasCapacity(), t.batchNode = this, t.atlasIndex = e, t.dirty = !0, t.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
	},
	insertQuadFromSprite: function(t, e) {
		cc.assert(t, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2);
		t instanceof cc.Sprite ? (this._renderCmd.insertQuad(t, e), t.batchNode = this, t.atlasIndex = e, t.dirty = !0, t.updateTransform(), this._renderCmd.cutting(t, e)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
	},
	initWithTexture: function(t, e) {
		this._children.length = 0;
		this._descendants.length = 0;
		e = e || cc.SpriteBatchNode.DEFAULT_CAPACITY;
		this._renderCmd.initWithTexture(t, e);
		return !0
	},
	insertChild: function(t, e) {
		t.batchNode = this;
		t.atlasIndex = e;
		t.dirty = !0;
		this._renderCmd.insertQuad(t, e);
		this._descendants.splice(e, 0, t);
		var i = e + 1,
			n = this._descendants;
		if (n && 0 < n.length) for (; i < n.length; i++) n[i].atlasIndex++;
		var n = t.children,
			r, c;
		if (n) {
			i = 0;
			for (c = n.length || 0; i < c; i++) if (r = n[i]) {
				var s = this.atlasIndexForChild(r, r.zIndex);
				this.insertChild(r, s)
			}
		}
	},
	appendChild: function(t) {
		this._reorderChildDirty = !0;
		t.batchNode = this;
		t.dirty = !0;
		this._descendants.push(t);
		var e = this._descendants.length - 1;
		t.atlasIndex = e;
		this._renderCmd.insertQuad(t, e);
		t = t.children;
		for (var e = 0, i = t.length || 0; e < i; e++) this.appendChild(t[e])
	},
	removeSpriteFromAtlas: function(t) {
		this._renderCmd.removeQuadAtIndex(t.atlasIndex);
		t.batchNode = null;
		var e = this._descendants,
			i = e.indexOf(t);
		if (-1 != i) {
			e.splice(i, 1);
			for (var n = e.length; i < n; ++i) e[i].atlasIndex--
		}
		if (t = t.children) {
			e = 0;
			for (i = t.length || 0; e < i; e++) t[e] && this.removeSpriteFromAtlas(t[e])
		}
	},
	getTexture: function() {
		return this._renderCmd.getTexture()
	},
	setTexture: function(t) {
		this._renderCmd.setTexture(t)
	},
	addChild: function(t, e, i) {
		cc.assert(null != t, cc._LogInfos.CCSpriteBatchNode_addChild_3);
		this._renderCmd.isValidChild(t) && (e = null == e ? t.zIndex : e, i = null == i ? t.tag : i, cc.Node.prototype.addChild.call(this, t, e, i), this.appendChild(t))
	},
	removeAllChildren: function(t) {
		var e = this._descendants;
		if (e && 0 < e.length) for (var i = 0, n = e.length; i < n; i++) e[i] && (e[i].batchNode = null);
		cc.Node.prototype.removeAllChildren.call(this, t);
		this._descendants.length = 0;
		this._renderCmd.removeAllQuads()
	},
	sortAllChildren: function() {
		if (this._reorderChildDirty) {
			var t = this._children,
				e, i = 0,
				n = t.length,
				r;
			for (e = 1; e < n; e++) {
				var c = t[e],
					i = e - 1;
				for (r = t[i]; 0 <= i && (c._localZOrder < r._localZOrder || c._localZOrder == r._localZOrder && c.arrivalOrder < r.arrivalOrder);) t[i + 1] = r, i -= 1, r = t[i];
				t[i + 1] = c
			}
			0 < t.length && (this._arrayMakeObjectsPerformSelector(t, cc.Node._stateCallbackType.sortAllChildren), this._renderCmd.updateChildrenAtlasIndex(t));
			this._reorderChildDirty = !1
		}
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.SpriteBatchNode.CanvasRenderCmd(this) : new cc.SpriteBatchNode.WebGLRenderCmd(this)
	}
});
_p = cc.SpriteBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "textureAtlas", _p.getTextureAtlas, _p.setTextureAtlas);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
cc.SpriteBatchNode.DEFAULT_CAPACITY = 29;
cc.SpriteBatchNode.create = function(t, e) {
	return new cc.SpriteBatchNode(t, e)
};
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
(function() {
	cc.SpriteBatchNode.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._originalTexture = this._texture = null
	};
	var t = cc.SpriteBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.SpriteBatchNode.CanvasRenderCmd;
	t.checkAtlasCapacity = function() {};
	t.isValidChild = function(t) {
		return !(t instanceof cc.Sprite) ? (cc.log(cc._LogInfos.Sprite_addChild_4), !1) : !0
	};
	t.initWithTexture = function(t, e) {
		this._texture = this._originalTexture = t
	};
	t.insertQuad = function(t, e) {};
	t.increaseAtlasCapacity = function() {};
	t.removeQuadAtIndex = function() {};
	t.removeAllQuads = function() {};
	t.getTexture = function() {
		return this._texture
	};
	t.setTexture = function(t) {
		this._texture = t;
		for (var e = this._node._children, i = 0; i < e.length; i++) e[i].setTexture(t)
	};
	t.updateChildrenAtlasIndex = function() {};
	t.getTextureAtlas = function() {};
	t.setTextureAtlas = function(t) {};
	t.cutting = function(t, e) {
		this._node._children.splice(e, 0, t)
	}
})();
(function() {
	cc.SpriteBatchNode.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !0;
		this._textureAtlas = null
	};
	var t = cc.SpriteBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	t.constructor = cc.SpriteBatchNode.WebGLRenderCmd;
	t.isValidChild = function(t) {
		return !(t instanceof cc.Sprite) ? (cc.log(cc._LogInfos.Sprite_addChild_4), !1) : t.texture != this.getTexture() ? (cc.log(cc._LogInfos.Sprite_addChild_5), !1) : !0
	};
	t.rendering = function() {
		var t = this._node;
		0 !== this._textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), t._arrayMakeObjectsPerformSelector(t._children, cc.Node._stateCallbackType.updateTransform), cc.glBlendFunc(t._blendFunc.src, t._blendFunc.dst), this._textureAtlas.drawQuads())
	};
	t.updateStatus = function() {
		cc.Node.WebGLRenderCmd.prototype.updateStatus.call(this)
	};
	t.visit = function(t) {
		t = this._node;
		if (t._visible) {
			t._parent && t._parent._renderCmd && (this._curLevel = t._parent._renderCmd._curLevel + 1);
			var e = cc.current_stack;
			e.stack.push(e.top);
			this.updateStatus();
			e.top = this._stackMatrix;
			t.sortAllChildren();
			cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0;
			e.top = e.stack.pop()
		}
	};
	t.checkAtlasCapacity = function(t) {
		for (var e = this._textureAtlas; t >= e.capacity || e.capacity == e.totalQuads;) this.increaseAtlasCapacity()
	};
	t.increaseAtlasCapacity = function() {
		var t = this._textureAtlas.capacity,
			e = Math.floor(4 * (t + 1) / 3);
		cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, t, e);
		this._textureAtlas.resizeCapacity(e) || cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
	};
	t.initWithTexture = function(t, e) {
		this._textureAtlas = new cc.TextureAtlas;
		this._textureAtlas.initWithTexture(t, e);
		this._updateBlendFunc();
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	t.insertQuad = function(t, e) {
		var i = this._textureAtlas;
		i.totalQuads >= i.capacity && this.increaseAtlasCapacity();
		i.insertQuad(t.quad, e)
	};
	t.removeQuadAtIndex = function(t) {
		this._textureAtlas.removeQuadAtIndex(t)
	};
	t.getTexture = function() {
		return this._textureAtlas.texture
	};
	t.setTexture = function(t) {
		this._textureAtlas.setTexture(t);
		this._updateBlendFunc()
	};
	t.removeAllQuads = function() {
		this._textureAtlas.removeAllQuads()
	};
	t._swap = function(t, e) {
		var i = this._node._descendants,
			n = this._textureAtlas,
			r = n.quads,
			c = i[t],
			s = cc.V3F_C4B_T2F_QuadCopy(r[t]);
		i[e].atlasIndex = t;
		i[t] = i[e];
		n.updateQuad(r[e], t);
		i[e] = c;
		n.updateQuad(s, e)
	};
	t._updateAtlasIndex = function(t, e) {
		var i = 0,
			n = t.children;
		n && (i = n.length);
		var r = 0;
		if (0 === i) r = t.atlasIndex, t.atlasIndex = e, t.arrivalOrder = 0, r != e && this._swap(r, e), e++;
		else {
			r = !0;
			0 <= n[0].zIndex && (r = t.atlasIndex, t.atlasIndex = e, t.arrivalOrder = 0, r != e && this._swap(r, e), e++, r = !1);
			for (i = 0; i < n.length; i++) {
				var c = n[i];
				r && 0 <= c.zIndex && (r = t.atlasIndex, t.atlasIndex = e, t.arrivalOrder = 0, r != e && this._swap(r, e), e++, r = !1);
				e = this._updateAtlasIndex(c, e)
			}
			r && (r = t.atlasIndex, t.atlasIndex = e, t.arrivalOrder = 0, r != e && this._swap(r, e), e++)
		}
		return e
	};
	t.updateChildrenAtlasIndex = function(t) {
		for (var e = 0, i = 0; i < t.length; i++) e = this._updateAtlasIndex(t[i], e)
	};
	t._updateBlendFunc = function() {
		if (!this._textureAtlas.texture.hasPremultipliedAlpha()) {
			var t = this._node._blendFunc;
			t.src = cc.SRC_ALPHA;
			t.dst = cc.ONE_MINUS_SRC_ALPHA
		}
	};
	t.getTextureAtlas = function() {
		return this._textureAtlas
	};
	t.setTextureAtlas = function(t) {
		t != this._textureAtlas && (this._textureAtlas = t)
	};
	t.cutting = function() {}
})();
cc.BakeSprite = cc.Sprite.extend({
	_cacheCanvas: null,
	_cacheContext: null,
	ctor: function() {
		cc.Sprite.prototype.ctor.call(this);
		var t = document.createElement("canvas");
		t.width = t.height = 10;
		this._cacheCanvas = t;
		this._cacheContext = t.getContext("2d");
		var e = new cc.Texture2D;
		e.initWithElement(t);
		e.handleLoadedTexture();
		this.setTexture(e)
	},
	getCacheContext: function() {
		return this._cacheContext
	},
	getCacheCanvas: function() {
		return this._cacheCanvas
	},
	resetCanvasSize: function(t, e) {
		void 0 === e && (e = t.height, t = t.width);
		var i = this._cacheCanvas;
		i.width = t;
		i.height = e;
		this.getTexture().handleLoadedTexture();
		this.setTextureRect(cc.rect(0, 0, t, e), !1)
	}
});
cc.AnimationFrame = cc.Class.extend({
	_spriteFrame: null,
	_delayPerUnit: 0,
	_userInfo: null,
	ctor: function(t, e, i) {
		this._spriteFrame = t || null;
		this._delayPerUnit = e || 0;
		this._userInfo = i || null
	},
	clone: function() {
		var t = new cc.AnimationFrame;
		t.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
		return t
	},
	copyWithZone: function(t) {
		return cc.clone(this)
	},
	copy: function(t) {
		t = new cc.AnimationFrame;
		t.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
		return t
	},
	initWithSpriteFrame: function(t, e, i) {
		this._spriteFrame = t;
		this._delayPerUnit = e;
		this._userInfo = i;
		return !0
	},
	getSpriteFrame: function() {
		return this._spriteFrame
	},
	setSpriteFrame: function(t) {
		this._spriteFrame = t
	},
	getDelayUnits: function() {
		return this._delayPerUnit
	},
	setDelayUnits: function(t) {
		this._delayPerUnit = t
	},
	getUserInfo: function() {
		return this._userInfo
	},
	setUserInfo: function(t) {
		this._userInfo = t
	}
});
cc.AnimationFrame.create = function(t, e, i) {
	return new cc.AnimationFrame(t, e, i)
};
cc.Animation = cc.Class.extend({
	_frames: null,
	_loops: 0,
	_restoreOriginalFrame: !1,
	_duration: 0,
	_delayPerUnit: 0,
	_totalDelayUnits: 0,
	ctor: function(t, e, i) {
		this._frames = [];
		if (void 0 === t) this.initWithSpriteFrames(null, 0);
		else {
			var n = t[0];
			n && (n instanceof cc.SpriteFrame ? this.initWithSpriteFrames(t, e, i) : n instanceof cc.AnimationFrame && this.initWithAnimationFrames(t, e, i))
		}
	},
	getFrames: function() {
		return this._frames
	},
	setFrames: function(t) {
		this._frames = t
	},
	addSpriteFrame: function(t) {
		var e = new cc.AnimationFrame;
		e.initWithSpriteFrame(t, 1, null);
		this._frames.push(e);
		this._totalDelayUnits++
	},
	addSpriteFrameWithFile: function(t) {
		t = cc.textureCache.addImage(t);
		var e = cc.rect(0, 0, 0, 0);
		e.width = t.width;
		e.height = t.height;
		t = new cc.SpriteFrame(t, e);
		this.addSpriteFrame(t)
	},
	addSpriteFrameWithTexture: function(t, e) {
		var i = new cc.SpriteFrame(t, e);
		this.addSpriteFrame(i)
	},
	initWithAnimationFrames: function(t, e, i) {
		cc.arrayVerifyType(t, cc.AnimationFrame);
		this._delayPerUnit = e;
		this._loops = void 0 === i ? 1 : i;
		this._totalDelayUnits = 0;
		e = this._frames;
		for (i = e.length = 0; i < t.length; i++) {
			var n = t[i];
			e.push(n);
			this._totalDelayUnits += n.getDelayUnits()
		}
		return !0
	},
	clone: function() {
		var t = new cc.Animation;
		t.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
		t.setRestoreOriginalFrame(this._restoreOriginalFrame);
		return t
	},
	copyWithZone: function(t) {
		t = new cc.Animation;
		t.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
		t.setRestoreOriginalFrame(this._restoreOriginalFrame);
		return t
	},
	_copyFrames: function() {
		for (var t = [], e = 0; e < this._frames.length; e++) t.push(this._frames[e].clone());
		return t
	},
	copy: function(t) {
		return this.copyWithZone(null)
	},
	getLoops: function() {
		return this._loops
	},
	setLoops: function(t) {
		this._loops = t
	},
	setRestoreOriginalFrame: function(t) {
		this._restoreOriginalFrame = t
	},
	getRestoreOriginalFrame: function() {
		return this._restoreOriginalFrame
	},
	getDuration: function() {
		return this._totalDelayUnits * this._delayPerUnit
	},
	getDelayPerUnit: function() {
		return this._delayPerUnit
	},
	setDelayPerUnit: function(t) {
		this._delayPerUnit = t
	},
	getTotalDelayUnits: function() {
		return this._totalDelayUnits
	},
	initWithSpriteFrames: function(t, e, i) {
		cc.arrayVerifyType(t, cc.SpriteFrame);
		this._loops = void 0 === i ? 1 : i;
		this._delayPerUnit = e || 0;
		this._totalDelayUnits = 0;
		e = this._frames;
		e.length = 0;
		if (t) {
			for (i = 0; i < t.length; i++) {
				var n = t[i],
					r = new cc.AnimationFrame;
				r.initWithSpriteFrame(n, 1, null);
				e.push(r)
			}
			this._totalDelayUnits += t.length
		}
		return !0
	},
	retain: function() {},
	release: function() {}
});
cc.Animation.create = function(t, e, i) {
	return new cc.Animation(t, e, i)
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
	_animations: {},
	addAnimation: function(t, e) {
		this._animations[e] = t
	},
	removeAnimation: function(t) {
		t && this._animations[t] && delete this._animations[t]
	},
	getAnimation: function(t) {
		return this._animations[t] ? this._animations[t] : null
	},
	_addAnimationsWithDictionary: function(t, e) {
		var i = t.animations;
		if (i) {
			var n = 1,
				r = t.properties;
			if (r) for (var n = null != r.format ? parseInt(r.format) : n, r = r.spritesheets, c = cc.spriteFrameCache, s = cc.path, o = 0; o < r.length; o++) c.addSpriteFrames(s.changeBasename(e, r[o]));
			switch (n) {
			case 1:
				this._parseVersion1(i);
				break;
			case 2:
				this._parseVersion2(i);
				break;
			default:
				cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
			}
		} else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
	},
	addAnimations: function(t) {
		cc.assert(t, cc._LogInfos.animationCache_addAnimations_2);
		var e = cc.loader.getRes(t);
		e ? this._addAnimationsWithDictionary(e, t) : cc.log(cc._LogInfos.animationCache_addAnimations)
	},
	_parseVersion1: function(t) {
		var e = cc.spriteFrameCache,
			i;
		for (i in t) {
			var n = t[i],
				r = n.frames,
				n = parseFloat(n.delay) || 0,
				c = null;
			if (r) {
				for (var c = [], s = 0; s < r.length; s++) {
					var o = e.getSpriteFrame(r[s]);
					if (o) {
						var a = new cc.AnimationFrame;
						a.initWithSpriteFrame(o, 1, null);
						c.push(a)
					} else cc.log(cc._LogInfos.animationCache__parseVersion1_2, i, r[s])
				}
				0 === c.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, i) : (c.length != r.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, i), c = new cc.Animation(c, n, 1), cc.animationCache.addAnimation(c, i))
			} else cc.log(cc._LogInfos.animationCache__parseVersion1, i)
		}
	},
	_parseVersion2: function(t) {
		var e = cc.spriteFrameCache,
			i;
		for (i in t) {
			var n = t[i],
				r = n.loop,
				c = parseInt(n.loops),
				r = r ? cc.REPEAT_FOREVER : isNaN(c) ? 1 : c,
				c = n.restoreOriginalFrame && !0 == n.restoreOriginalFrame ? !0 : !1,
				s = n.frames;
			if (s) {
				for (var o = [], a = 0; a < s.length; a++) {
					var h = s[a],
						l = h.spriteframe,
						u = e.getSpriteFrame(l);
					if (u) {
						var l = parseFloat(h.delayUnits) || 0,
							h = h.notification,
							d = new cc.AnimationFrame;
						d.initWithSpriteFrame(u, l, h);
						o.push(d)
					} else cc.log(cc._LogInfos.animationCache__parseVersion2_2, i, l)
				}
				n = parseFloat(n.delayPerUnit) || 0;
				s = new cc.Animation;
				s.initWithAnimationFrames(o, n, r);
				s.setRestoreOriginalFrame(c);
				cc.animationCache.addAnimation(s, i)
			} else cc.log(cc._LogInfos.animationCache__parseVersion2, i)
		}
	},
	_clear: function() {
		this._animations = {}
	}
};
cc.SpriteFrame = cc.Class.extend({
	_offset: null,
	_originalSize: null,
	_rectInPixels: null,
	_rotated: !1,
	_rect: null,
	_offsetInPixels: null,
	_originalSizeInPixels: null,
	_texture: null,
	_textureFilename: "",
	_textureLoaded: !1,
	ctor: function(t, e, i, n, r) {
		this._offset = cc.p(0, 0);
		this._offsetInPixels = cc.p(0, 0);
		this._originalSize = cc.size(0, 0);
		this._rotated = !1;
		this._originalSizeInPixels = cc.size(0, 0);
		this._textureFilename = "";
		this._texture = null;
		this._textureLoaded = !1;
		void 0 !== t && void 0 !== e && (void 0 === i || void 0 === n || void 0 === r ? this.initWithTexture(t, e) : this.initWithTexture(t, e, i, n, r))
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(t, e) {
		this.addEventListener("load", t, e)
	},
	getRectInPixels: function() {
		var t = this._rectInPixels;
		return cc.rect(t.x, t.y, t.width, t.height)
	},
	setRectInPixels: function(t) {
		this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
		this._rectInPixels.x = t.x;
		this._rectInPixels.y = t.y;
		this._rectInPixels.width = t.width;
		this._rectInPixels.height = t.height;
		this._rect = cc.rectPixelsToPoints(t)
	},
	isRotated: function() {
		return this._rotated
	},
	setRotated: function(t) {
		this._rotated = t
	},
	getRect: function() {
		var t = this._rect;
		return cc.rect(t.x, t.y, t.width, t.height)
	},
	setRect: function(t) {
		this._rect || (this._rect = cc.rect(0, 0, 0, 0));
		this._rect.x = t.x;
		this._rect.y = t.y;
		this._rect.width = t.width;
		this._rect.height = t.height;
		this._rectInPixels = cc.rectPointsToPixels(this._rect)
	},
	getOffsetInPixels: function() {
		return cc.p(this._offsetInPixels)
	},
	setOffsetInPixels: function(t) {
		this._offsetInPixels.x = t.x;
		this._offsetInPixels.y = t.y;
		cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
	},
	getOriginalSizeInPixels: function() {
		return cc.size(this._originalSizeInPixels)
	},
	setOriginalSizeInPixels: function(t) {
		this._originalSizeInPixels.width = t.width;
		this._originalSizeInPixels.height = t.height
	},
	getOriginalSize: function() {
		return cc.size(this._originalSize)
	},
	setOriginalSize: function(t) {
		this._originalSize.width = t.width;
		this._originalSize.height = t.height
	},
	getTexture: function() {
		if (this._texture) return this._texture;
		if ("" !== this._textureFilename) {
			var t = cc.textureCache.addImage(this._textureFilename);
			t && (this._textureLoaded = t.isLoaded());
			return t
		}
		return null
	},
	setTexture: function(t) {
		if (this._texture != t) {
			var e = t.isLoaded();
			this._textureLoaded = e;
			this._texture = t;
			e || t.addEventListener("load", function(t) {
				this._textureLoaded = !0;
				if (this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
					var e = t.getHtmlElementObj(),
						e = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(e, this.getRect()),
						i = new cc.Texture2D;
					i.initWithElement(e);
					i.handleLoadedTexture();
					this.setTexture(i);
					e = this.getRect();
					this.setRect(cc.rect(0, 0, e.width, e.height))
				}
				e = this._rect;
				0 === e.width && 0 === e.height && (e = t.width, t = t.height, this._rect.width = e, this._rect.height = t, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = e, this._originalSize.height = t);
				this.dispatchEvent("load")
			}, this)
		}
	},
	getOffset: function() {
		return cc.p(this._offset)
	},
	setOffset: function(t) {
		this._offset.x = t.x;
		this._offset.y = t.y
	},
	clone: function() {
		var t = new cc.SpriteFrame;
		t.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
		t.setTexture(this._texture);
		return t
	},
	copyWithZone: function() {
		var t = new cc.SpriteFrame;
		t.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
		t.setTexture(this._texture);
		return t
	},
	copy: function() {
		return this.copyWithZone()
	},
	initWithTexture: function(t, e, i, n, r) {
		2 === arguments.length && (e = cc.rectPointsToPixels(e));
		n = n || cc.p(0, 0);
		r = r || e;
		i = i || !1;
		cc.isString(t) ? (this._texture = null, this._textureFilename = t) : t instanceof cc.Texture2D && this.setTexture(t);
		t = this.getTexture();
		this._rectInPixels = e;
		e = this._rect = cc.rectPixelsToPoints(e);
		if (t && t.url && t.isLoaded()) {
			var c, s;
			i ? (c = e.x + e.height, s = e.y + e.width) : (c = e.x + e.width, s = e.y + e.height);
			c > t.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, t.url);
			s > t.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, t.url)
		}
		this._offsetInPixels.x = n.x;
		this._offsetInPixels.y = n.y;
		cc._pointPixelsToPointsOut(n, this._offset);
		this._originalSizeInPixels.width = r.width;
		this._originalSizeInPixels.height = r.height;
		cc._sizePixelsToPointsOut(r, this._originalSize);
		this._rotated = i;
		return !0
	}
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function(t, e, i, n, r) {
	return new cc.SpriteFrame(t, e, i, n, r)
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function(t, e, i, n, r) {
	var c = new cc.SpriteFrame;
	c._texture = t;
	c._rectInPixels = e;
	c._rect = cc.rectPixelsToPoints(e);
	c._offsetInPixels.x = n.x;
	c._offsetInPixels.y = n.y;
	cc._pointPixelsToPointsOut(c._offsetInPixels, c._offset);
	c._originalSizeInPixels.width = r.width;
	c._originalSizeInPixels.height = r.height;
	cc._sizePixelsToPointsOut(c._originalSizeInPixels, c._originalSize);
	c._rotated = i;
	return c
};
cc.spriteFrameCache = {
	_CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
	_CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
	_spriteFrames: {},
	_spriteFramesAliases: {},
	_frameConfigCache: {},
	_rectFromString: function(t) {
		t = this._CCNS_REG2.exec(t);
		return !t ? cc.rect(0, 0, 0, 0) : cc.rect(parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3]), parseFloat(t[4]))
	},
	_pointFromString: function(t) {
		t = this._CCNS_REG1.exec(t);
		return !t ? cc.p(0, 0) : cc.p(parseFloat(t[1]), parseFloat(t[2]))
	},
	_sizeFromString: function(t) {
		t = this._CCNS_REG1.exec(t);
		return !t ? cc.size(0, 0) : cc.size(parseFloat(t[1]), parseFloat(t[2]))
	},
	_getFrameConfig: function(t) {
		var e = cc.loader.getRes(t);
		cc.assert(e, cc._LogInfos.spriteFrameCache__getFrameConfig_2, t);
		cc.loader.release(t);
		if (e._inited) return this._frameConfigCache[t] = e;
		var i = e.frames,
			n = e.metadata || e.meta,
			e = {},
			r = {},
			c = 0;
		n && (c = n.format, c = 1 >= c.length ? parseInt(c) : c, r.image = n.textureFileName || n.textureFileName || n.image);
		for (var s in i) {
			var o = i[s];
			if (o) {
				n = {};
				if (0 == c) {
					n.rect = cc.rect(o.x, o.y, o.width, o.height);
					n.rotated = !1;
					n.offset = cc.p(o.offsetX, o.offsetY);
					var a = o.originalWidth,
						o = o.originalHeight;
					(!a || !o) && cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
					a = Math.abs(a);
					o = Math.abs(o);
					n.size = cc.size(a, o)
				} else if (1 == c || 2 == c) n.rect = this._rectFromString(o.frame), n.rotated = o.rotated || !1, n.offset = this._pointFromString(o.offset), n.size = this._sizeFromString(o.sourceSize);
				else if (3 == c) {
					var a = this._sizeFromString(o.spriteSize),
						h = this._rectFromString(o.textureRect);
					a && (h = cc.rect(h.x, h.y, a.width, a.height));
					n.rect = h;
					n.rotated = o.textureRotated || !1;
					n.offset = this._pointFromString(o.spriteOffset);
					n.size = this._sizeFromString(o.spriteSourceSize);
					n.aliases = o.aliases
				} else a = o.frame, h = o.sourceSize, s = o.filename || s, n.rect = cc.rect(a.x, a.y, a.w, a.h), n.rotated = o.rotated || !1, n.offset = cc.p(0, 0), n.size = cc.size(h.w, h.h);
				e[s] = n
			}
		}
		return this._frameConfigCache[t] = {
			_inited: !0,
			frames: e,
			meta: r
		}
	},
	addSpriteFrames: function(t, e) {
		cc.assert(t, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
		var i = this._frameConfigCache[t] || cc.loader.getRes(t);
		if (i && i.frames) {
			var n = this._frameConfigCache[t] || this._getFrameConfig(t),
				i = n.frames,
				n = n.meta;
			e ? e instanceof cc.Texture2D || (cc.isString(e) ? e = cc.textureCache.addImage(e) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (n = cc.path.changeBasename(t, n.image || ".png"), e = cc.textureCache.addImage(n));
			var n = this._spriteFramesAliases,
				r = this._spriteFrames,
				c;
			for (c in i) {
				var s = i[c],
					o = r[c];
				if (!o) {
					o = new cc.SpriteFrame(e, s.rect, s.rotated, s.offset, s.size);
					if (s = s.aliases) for (var a = 0, h = s.length; a < h; a++) {
						var l = s[a];
						n[l] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, l);
						n[l] = c
					}
					cc._renderType === cc._RENDER_TYPE_CANVAS && o.isRotated() && o.getTexture().isLoaded() && (s = o.getTexture().getHtmlElementObj(), s = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(s, o.getRectInPixels()), a = new cc.Texture2D, a.initWithElement(s), a.handleLoadedTexture(), o.setTexture(a), s = o._rect, o.setRect(cc.rect(0, 0, s.width, s.height)));
					r[c] = o
				}
			}
		}
	},
	_checkConflict: function(t) {
		t = t.frames;
		for (var e in t) this._spriteFrames[e] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, e)
	},
	addSpriteFrame: function(t, e) {
		this._spriteFrames[e] = t
	},
	removeSpriteFrames: function() {
		this._spriteFrames = {};
		this._spriteFramesAliases = {}
	},
	removeSpriteFrameByName: function(t) {
		t && (this._spriteFramesAliases[t] && delete this._spriteFramesAliases[t], this._spriteFrames[t] && delete this._spriteFrames[t])
	},
	removeSpriteFramesFromFile: function(t) {
		var e = this._spriteFrames,
			i = this._spriteFramesAliases;
		if (t = this._frameConfigCache[t]) {
			t = t.frames;
			for (var n in t) if (e[n]) {
				delete e[n];
				for (var r in i) i[r] == n && delete i[r]
			}
		}
	},
	removeSpriteFramesFromTexture: function(t) {
		var e = this._spriteFrames,
			i = this._spriteFramesAliases,
			n;
		for (n in e) {
			var r = e[n];
			if (r && r.getTexture() == t) {
				delete e[n];
				for (var c in i) i[c] == n && delete i[c]
			}
		}
	},
	getSpriteFrame: function(t) {
		var e = this._spriteFrames[t];
		if (!e) {
			var i = this._spriteFramesAliases[t];
			i && ((e = this._spriteFrames[i.toString()]) || delete this._spriteFramesAliases[t])
		}
		e || cc.log(cc._LogInfos.spriteFrameCache_getSpriteFrame, t);
		return e
	},
	_clear: function() {
		this._spriteFrames = {};
		this._spriteFramesAliases = {};
		this._frameConfigCache = {}
	}
};
cc.configuration = {
	ERROR: 0,
	STRING: 1,
	INT: 2,
	DOUBLE: 3,
	BOOLEAN: 4,
	_maxTextureSize: 0,
	_maxModelviewStackDepth: 0,
	_supportsPVRTC: !1,
	_supportsNPOT: !1,
	_supportsBGRA8888: !1,
	_supportsDiscardFramebuffer: !1,
	_supportsShareableVAO: !1,
	_maxSamplesAllowed: 0,
	_maxTextureUnits: 0,
	_GlExtensions: "",
	_valueDict: {},
	_inited: !1,
	_init: function() {
		var t = this._valueDict;
		t["cocos2d.x.version"] = cc.ENGINE_VERSION;
		t["cocos2d.x.compiled_with_profiler"] = !1;
		t["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
		this._inited = !0
	},
	getMaxTextureSize: function() {
		return this._maxTextureSize
	},
	getMaxModelviewStackDepth: function() {
		return this._maxModelviewStackDepth
	},
	getMaxTextureUnits: function() {
		return this._maxTextureUnits
	},
	supportsNPOT: function() {
		return this._supportsNPOT
	},
	supportsPVRTC: function() {
		return this._supportsPVRTC
	},
	supportsETC: function() {
		return !1
	},
	supportsS3TC: function() {
		return !1
	},
	supportsATITC: function() {
		return !1
	},
	supportsBGRA8888: function() {
		return this._supportsBGRA8888
	},
	supportsDiscardFramebuffer: function() {
		return this._supportsDiscardFramebuffer
	},
	supportsShareableVAO: function() {
		return this._supportsShareableVAO
	},
	checkForGLExtension: function(t) {
		return -1 < this._GlExtensions.indexOf(t)
	},
	getValue: function(t, e) {
		this._inited || this._init();
		var i = this._valueDict;
		return i[t] ? i[t] : e
	},
	setValue: function(t, e) {
		this._valueDict[t] = e
	},
	dumpInfo: function() {
		0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
	},
	gatherGPUInfo: function() {
		if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
			this._inited || this._init();
			var t = cc._renderContext,
				e = this._valueDict;
			e["gl.vendor"] = t.getParameter(t.VENDOR);
			e["gl.renderer"] = t.getParameter(t.RENDERER);
			e["gl.version"] = t.getParameter(t.VERSION);
			this._GlExtensions = "";
			for (var i = t.getSupportedExtensions(), n = 0; n < i.length; n++) this._GlExtensions += i[n] + " ";
			this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);
			e["gl.max_texture_size"] = this._maxTextureSize;
			this._maxTextureUnits = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
			e["gl.max_texture_units"] = this._maxTextureUnits;
			this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
			e["gl.supports_PVRTC"] = this._supportsPVRTC;
			this._supportsNPOT = !1;
			e["gl.supports_NPOT"] = this._supportsNPOT;
			this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
			e["gl.supports_BGRA8888"] = this._supportsBGRA8888;
			this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
			e["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
			this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
			e["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
			cc.checkGLErrorDebug()
		}
	},
	loadConfigFile: function(t) {
		this._inited || this._init();
		var e = cc.loader.getRes(t);
		if (!e) throw "Please load the resource first : " + t;
		cc.assert(e, cc._LogInfos.configuration_loadConfigFile_2, t);
		if (e = e.data) for (var i in e) this._valueDict[i] = e[i];
		else cc.log(cc._LogInfos.configuration_loadConfigFile, t)
	}
};
cc._tmp.DirectorWebGL = function() {
	cc.DirectorDelegate = cc.Class.extend({
		updateProjection: function() {}
	});
	var t = cc.Director.prototype;
	t.setProjection = function(t) {
		var e = this._winSizeInPoints;
		this.setViewport();
		var i = this._openGLView,
			n = i._viewPortRect.x / i._scaleX,
			r = i._viewPortRect.y / i._scaleY;
		switch (t) {
		case cc.Director.PROJECTION_2D:
			cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
			cc.kmGLLoadIdentity();
			i = new cc.kmMat4;
			cc.kmMat4OrthographicProjection(i, -n, e.width - n, -r, e.height - r, -1024, 1024);
			cc.kmGLMultMatrix(i);
			cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
			cc.kmGLLoadIdentity();
			break;
		case cc.Director.PROJECTION_3D:
			var c = this.getZEye(),
				s = new cc.kmMat4,
				i = new cc.kmMat4;
			cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
			cc.kmGLLoadIdentity();
			cc.kmMat4PerspectiveProjection(s, 60, e.width / e.height, .1, 2 * c);
			cc.kmGLMultMatrix(s);
			cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
			cc.kmGLLoadIdentity();
			c = cc.kmVec3Fill(null, -n + e.width / 2, -r + e.height / 2, c);
			e = cc.kmVec3Fill(null, -n + e.width / 2, -r + e.height / 2, 0);
			n = cc.kmVec3Fill(null, 0, 1, 0);
			cc.kmMat4LookAt(i, c, e, n);
			cc.kmGLMultMatrix(i);
			break;
		case cc.Director.PROJECTION_CUSTOM:
			this._projectionDelegate && this._projectionDelegate.updateProjection();
			break;
		default:
			cc.log(cc._LogInfos.Director_setProjection)
		}
		this._projection = t;
		cc.eventManager.dispatchEvent(this._eventProjectionChanged);
		cc.setProjectionMatrixDirty();
		cc.renderer.childrenOrderDirty = !0
	};
	t.setDepthTest = function(t) {
		var e = cc._renderContext;
		t ? (e.clearDepth(1), e.enable(e.DEPTH_TEST), e.depthFunc(e.LEQUAL)) : e.disable(e.DEPTH_TEST)
	};
	t.setOpenGLView = function(t) {
		this._winSizeInPoints.width = cc._canvas.width;
		this._winSizeInPoints.height = cc._canvas.height;
		this._openGLView = t || cc.view;
		t = cc.configuration;
		t.gatherGPUInfo();
		t.dumpInfo();
		this._createStatsLabel();
		this.setGLDefaultValues();
		cc.eventManager && cc.eventManager.setEnabled(!0)
	};
	t._clear = function() {
		var t = cc._renderContext;
		t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT)
	};
	t._beforeVisitScene = function() {
		cc.kmGLPushMatrix()
	};
	t._afterVisitScene = function() {
		cc.kmGLPopMatrix()
	};
	t._createStatsLabel = function() {
		if (cc.LabelAtlas) {
			if (!(null == cc.Director._fpsImageLoaded || !1 == cc.Director._fpsImageLoaded)) {
				var t = new cc.Texture2D;
				t.initWithElement(cc.Director._fpsImage);
				t.handleLoadedTexture();
				var e = cc.view.getDesignResolutionSize().height / 320;
				0 === e && (e = this._winSizeInPoints.height / 320);
				var i = new cc.LabelAtlas;
				i._setIgnoreContentScaleFactor(!0);
				i.initWithString("00.0", t, 12, 32, ".");
				i.scale = e;
				this._FPSLabel = i;
				i = new cc.LabelAtlas;
				i._setIgnoreContentScaleFactor(!0);
				i.initWithString("0.000", t, 12, 32, ".");
				i.scale = e;
				this._SPFLabel = i;
				i = new cc.LabelAtlas;
				i._setIgnoreContentScaleFactor(!0);
				i.initWithString("000", t, 12, 32, ".");
				i.scale = e;
				this._drawsLabel = i;
				t = cc.DIRECTOR_STATS_POSITION;
				this._drawsLabel.setPosition(t.x, 34 * e + t.y);
				this._SPFLabel.setPosition(t.x, 17 * e + t.y);
				this._FPSLabel.setPosition(t)
			}
		} else this._createStatsLabelForCanvas()
	};
	t._createStatsLabelForCanvas = function() {
		var t = 0,
			t = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
		this._FPSLabel = new cc.LabelTTF("000.0", "Arial", t);
		this._SPFLabel = new cc.LabelTTF("0.000", "Arial", t);
		this._drawsLabel = new cc.LabelTTF("0000", "Arial", t);
		t = cc.DIRECTOR_STATS_POSITION;
		this._drawsLabel.setPosition(this._drawsLabel.width / 2 + t.x, 5 * this._drawsLabel.height / 2 + t.y);
		this._SPFLabel.setPosition(this._SPFLabel.width / 2 + t.x, 3 * this._SPFLabel.height / 2 + t.y);
		this._FPSLabel.setPosition(this._FPSLabel.width / 2 + t.x, this._FPSLabel.height / 2 + t.y)
	};
	t.convertToGL = function(t) {
		var e = new cc.kmMat4;
		cc.GLToClipTransform(e);
		var i = new cc.kmMat4;
		cc.kmMat4Inverse(i, e);
		var e = e.mat[14] / e.mat[15],
			n = this._openGLView.getDesignResolutionSize();
		t = new cc.kmVec3(2 * t.x / n.width - 1, 1 - 2 * t.y / n.height, e);
		e = new cc.kmVec3;
		cc.kmVec3TransformCoord(e, t, i);
		return cc.p(e.x, e.y)
	};
	t.convertToUI = function(t) {
		var e = new cc.kmMat4;
		cc.GLToClipTransform(e);
		var i = new cc.kmVec3;
		t = new cc.kmVec3(t.x, t.y, 0);
		cc.kmVec3TransformCoord(i, t, e);
		e = this._openGLView.getDesignResolutionSize();
		return cc.p(e.width * (.5 * i.x + .5), e.height * (.5 * -i.y + .5))
	};
	t.getVisibleSize = function() {
		return this._openGLView.getVisibleSize()
	};
	t.getVisibleOrigin = function() {
		return this._openGLView.getVisibleOrigin()
	};
	t.getZEye = function() {
		return this._winSizeInPoints.height / 1.1566
	};
	t.setViewport = function() {
		var t = this._openGLView;
		if (t) {
			var e = this._winSizeInPoints;
			t.setViewPortInPoints(-t._viewPortRect.x / t._scaleX, -t._viewPortRect.y / t._scaleY, e.width, e.height)
		}
	};
	t.getOpenGLView = function() {
		return this._openGLView
	};
	t.getProjection = function() {
		return this._projection
	};
	t.setAlphaBlending = function(t) {
		t ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
	};
	t.setGLDefaultValues = function() {
		this.setAlphaBlending(!0);
		this.setDepthTest(!1);
		this.setProjection(this._projection);
		cc._renderContext.clearColor(0, 0, 0, 1)
	}
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function(t) {
	var e = new cc.kmMat4;
	cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, e);
	var i = new cc.kmMat4;
	cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, i);
	cc.kmMat4Multiply(t, e, i)
};
cc.Director = cc.Class.extend({
	_landscape: !1,
	_nextDeltaTimeZero: !1,
	_paused: !1,
	_purgeDirectorInNextLoop: !1,
	_sendCleanupToScene: !1,
	_animationInterval: 0,
	_oldAnimationInterval: 0,
	_projection: 0,
	_accumDt: 0,
	_contentScaleFactor: 1,
	_displayStats: !1,
	_deltaTime: 0,
	_frameRate: 0,
	_FPSLabel: null,
	_SPFLabel: null,
	_drawsLabel: null,
	_winSizeInPoints: null,
	_lastUpdate: null,
	_nextScene: null,
	_notificationNode: null,
	_openGLView: null,
	_scenesStack: null,
	_projectionDelegate: null,
	_runningScene: null,
	_frames: 0,
	_totalFrames: 0,
	_secondsPerFrame: 0,
	_dirtyRegion: null,
	_scheduler: null,
	_actionManager: null,
	_eventProjectionChanged: null,
	_eventAfterDraw: null,
	_eventAfterVisit: null,
	_eventAfterUpdate: null,
	ctor: function() {
		var t = this;
		t._lastUpdate = Date.now();
		cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
			t._lastUpdate = Date.now()
		})
	},
	init: function() {
		this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
		this._scenesStack = [];
		this._projection = cc.Director.PROJECTION_DEFAULT;
		this._projectionDelegate = null;
		this._frameRate = this._accumDt = 0;
		this._displayStats = !1;
		this._totalFrames = this._frames = 0;
		this._lastUpdate = Date.now();
		this._purgeDirectorInNextLoop = this._paused = !1;
		this._winSizeInPoints = cc.size(0, 0);
		this._openGLView = null;
		this._contentScaleFactor = 1;
		this._scheduler = new cc.Scheduler;
		this._actionManager = cc.ActionManager ? new cc.ActionManager : null;
		this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1);
		this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
		this._eventAfterDraw.setUserData(this);
		this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
		this._eventAfterVisit.setUserData(this);
		this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
		this._eventAfterUpdate.setUserData(this);
		this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
		this._eventProjectionChanged.setUserData(this);
		return !0
	},
	calculateDeltaTime: function() {
		var t = Date.now();
		this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (t - this._lastUpdate) / 1e3;
		0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && .2 < this._deltaTime && (this._deltaTime = 1 / 60);
		this._lastUpdate = t
	},
	convertToGL: null,
	convertToUI: null,
	drawScene: function() {
		var t = cc.renderer;
		this.calculateDeltaTime();
		this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
		this._clear();
		this._nextScene && this.setNextScene();
		this._beforeVisitScene && this._beforeVisitScene();
		this._runningScene && (!0 === t.childrenOrderDirty ? (cc.renderer.clearRenderCommands(), this._runningScene._renderCmd._curLevel = 0, this._runningScene.visit(), t.resetFlag()) : !0 === t.transformDirty() && t.transform(), cc.eventManager.dispatchEvent(this._eventAfterVisit));
		this._notificationNode && this._notificationNode.visit();
		this._displayStats && this._showStats();
		this._afterVisitScene && this._afterVisitScene();
		t.rendering(cc._renderContext);
		cc.eventManager.dispatchEvent(this._eventAfterDraw);
		this._totalFrames++;
		this._displayStats && this._calculateMPF()
	},
	_beforeVisitScene: null,
	_afterVisitScene: null,
	end: function() {
		this._purgeDirectorInNextLoop = !0
	},
	getContentScaleFactor: function() {
		return this._contentScaleFactor
	},
	getNotificationNode: function() {
		return this._notificationNode
	},
	getWinSize: function() {
		return cc.size(this._winSizeInPoints)
	},
	getWinSizeInPixels: function() {
		return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
	},
	getVisibleSize: null,
	getVisibleOrigin: null,
	getZEye: null,
	pause: function() {
		this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(.25), this._paused = !0)
	},
	popScene: function() {
		cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
		this._scenesStack.pop();
		var t = this._scenesStack.length;
		0 == t ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[t - 1])
	},
	purgeCachedData: function() {
		cc.animationCache._clear();
		cc.spriteFrameCache._clear();
		cc.textureCache._clear()
	},
	purgeDirector: function() {
		this.getScheduler().unscheduleAllCallbacks();
		cc.eventManager && cc.eventManager.setEnabled(!1);
		this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup());
		this._nextScene = this._runningScene = null;
		this._scenesStack.length = 0;
		this.stopAnimation();
		this.purgeCachedData();
		cc.checkGLErrorDebug()
	},
	pushScene: function(t) {
		cc.assert(t, cc._LogInfos.Director_pushScene);
		this._sendCleanupToScene = !1;
		this._scenesStack.push(t);
		this._nextScene = t
	},
	runScene: function(t) {
		cc.assert(t, cc._LogInfos.Director_pushScene);
		if (this._runningScene) {
			var e = this._scenesStack.length;
			0 === e ? (this._sendCleanupToScene = !0, this._scenesStack[e] = t) : (this._sendCleanupToScene = !0, this._scenesStack[e - 1] = t);
			this._nextScene = t
		} else this.pushScene(t), this.startAnimation()
	},
	resume: function() {
		this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
	},
	setContentScaleFactor: function(t) {
		t != this._contentScaleFactor && (this._contentScaleFactor = t, this._createStatsLabel())
	},
	setDepthTest: null,
	setDefaultValues: function() {},
	setNextDeltaTimeZero: function(t) {
		this._nextDeltaTimeZero = t
	},
	setNextScene: function() {
		var t = !1,
			e = !1;
		cc.TransitionScene && (t = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, e = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
		if (!e) {
			if (e = this._runningScene) e.onExitTransitionDidStart(), e.onExit();
			this._sendCleanupToScene && e && e.cleanup()
		}
		this._runningScene = this._nextScene;
		cc.renderer.childrenOrderDirty = !0;
		this._nextScene = null;
		!t && null != this._runningScene && (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
	},
	setNotificationNode: function(t) {
		this._notificationNode = t
	},
	getDelegate: function() {
		return this._projectionDelegate
	},
	setDelegate: function(t) {
		this._projectionDelegate = t
	},
	setOpenGLView: null,
	setProjection: null,
	setViewport: null,
	getOpenGLView: null,
	getProjection: null,
	setAlphaBlending: null,
	_showStats: function() {
		this._frames++;
		this._accumDt += this._deltaTime;
		this._FPSLabel && this._SPFLabel && this._drawsLabel ? (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel();
		cc.g_NumberOfDraws = 0
	},
	isSendCleanupToScene: function() {
		return this._sendCleanupToScene
	},
	getRunningScene: function() {
		return this._runningScene
	},
	getAnimationInterval: function() {
		return this._animationInterval
	},
	isDisplayStats: function() {
		return this._displayStats
	},
	setDisplayStats: function(t) {
		this._displayStats = t
	},
	getSecondsPerFrame: function() {
		return this._secondsPerFrame
	},
	isNextDeltaTimeZero: function() {
		return this._nextDeltaTimeZero
	},
	isPaused: function() {
		return this._paused
	},
	getTotalFrames: function() {
		return this._totalFrames
	},
	popToRootScene: function() {
		this.popToSceneStackLevel(1)
	},
	popToSceneStackLevel: function(t) {
		cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
		var e = this._scenesStack,
			i = e.length;
		if (0 == i) this.end();
		else if (!(t > i)) {
			for (; i > t;) {
				var n = e.pop();
				n.running && (n.onExitTransitionDidStart(), n.onExit());
				n.cleanup();
				i--
			}
			this._nextScene = e[e.length - 1];
			this._sendCleanupToScene = !1
		}
	},
	getScheduler: function() {
		return this._scheduler
	},
	setScheduler: function(t) {
		this._scheduler != t && (this._scheduler = t)
	},
	getActionManager: function() {
		return this._actionManager
	},
	setActionManager: function(t) {
		this._actionManager != t && (this._actionManager = t)
	},
	getDeltaTime: function() {
		return this._deltaTime
	},
	_createStatsLabel: null,
	_calculateMPF: function() {
		this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1e3
	}
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({
	invalid: !1,
	startAnimation: function() {
		this._nextDeltaTimeZero = !0;
		this.invalid = !1
	},
	mainLoop: function() {
		this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
	},
	stopAnimation: function() {
		this.invalid = !0
	},
	setAnimationInterval: function(t) {
		this._animationInterval = t;
		this.invalid || (this.stopAnimation(), this.startAnimation())
	}
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function() {
	cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
	return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Director.prototype, _p.setProjection = function(t) {
	this._projection = t;
	cc.eventManager.dispatchEvent(this._eventProjectionChanged)
}, _p.setDepthTest = function() {}, _p.setOpenGLView = function(t) {
	this._winSizeInPoints.width = cc._canvas.width;
	this._winSizeInPoints.height = cc._canvas.height;
	this._openGLView = t || cc.view;
	cc.eventManager && cc.eventManager.setEnabled(!0)
}, _p._clear = function() {
	var t = this._openGLView.getViewPortRect();
	cc._renderContext.clearRect(-t.x, t.y, t.width, -t.height)
}, _p._createStatsLabel = function() {
	var t = 0,
		t = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
	this._FPSLabel = new cc.LabelTTF("000.0", "Arial", t);
	this._SPFLabel = new cc.LabelTTF("0.000", "Arial", t);
	this._drawsLabel = new cc.LabelTTF("0000", "Arial", t);
	t = cc.DIRECTOR_STATS_POSITION;
	this._drawsLabel.setPosition(this._drawsLabel.width / 2 + t.x, 5 * this._drawsLabel.height / 2 + t.y);
	this._SPFLabel.setPosition(this._SPFLabel.width / 2 + t.x, 3 * this._SPFLabel.height / 2 + t.y);
	this._FPSLabel.setPosition(this._FPSLabel.width / 2 + t.x, this._FPSLabel.height / 2 + t.y)
}, _p.getVisibleSize = function() {
	return this.getWinSize()
}, _p.getVisibleOrigin = function() {
	return cc.p(0, 0)
}) : (cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function() {
	cc.Director._fpsImageLoaded = !0
}), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage), cc.assert(cc.isFunction(cc._tmp.DirectorWebGL), cc._LogInfos.MissingFile, "CCDirectorWebGL.js"), cc._tmp.DirectorWebGL(), delete cc._tmp.DirectorWebGL);
cc.Camera = cc.Class.extend({
	_eyeX: null,
	_eyeY: null,
	_eyeZ: null,
	_centerX: null,
	_centerY: null,
	_centerZ: null,
	_upX: null,
	_upY: null,
	_upZ: null,
	_dirty: null,
	_lookupMatrix: null,
	ctor: function() {
		this._lookupMatrix = new cc.kmMat4;
		this.restore()
	},
	description: function() {
		return "<CCCamera | center =(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")>"
	},
	setDirty: function(t) {
		this._dirty = t
	},
	isDirty: function() {
		return this._dirty
	},
	restore: function() {
		this._eyeX = this._eyeY = 0;
		this._eyeZ = cc.Camera.getZEye();
		this._upX = this._centerX = this._centerY = this._centerZ = 0;
		this._upY = 1;
		this._upZ = 0;
		cc.kmMat4Identity(this._lookupMatrix);
		this._dirty = !1
	},
	locate: function() {
		if (this._dirty) {
			var t = new cc.kmVec3,
				e = new cc.kmVec3,
				i = new cc.kmVec3;
			cc.kmVec3Fill(t, this._eyeX, this._eyeY, this._eyeZ);
			cc.kmVec3Fill(e, this._centerX, this._centerY, this._centerZ);
			cc.kmVec3Fill(i, this._upX, this._upY, this._upZ);
			cc.kmMat4LookAt(this._lookupMatrix, t, e, i);
			this._dirty = !1
		}
		cc.kmGLMultMatrix(this._lookupMatrix)
	},
	_locateForRenderer: function(t) {
		if (this._dirty) {
			var e = new cc.kmVec3,
				i = new cc.kmVec3,
				n = new cc.kmVec3;
			cc.kmVec3Fill(e, this._eyeX, this._eyeY, this._eyeZ);
			cc.kmVec3Fill(i, this._centerX, this._centerY, this._centerZ);
			cc.kmVec3Fill(n, this._upX, this._upY, this._upZ);
			cc.kmMat4LookAt(this._lookupMatrix, e, i, n);
			this._dirty = !1
		}
		cc.kmMat4Multiply(t, t, this._lookupMatrix)
	},
	setEyeXYZ: function(t, e, i) {
		this.setEye(t, e, i)
	},
	setEye: function(t, e, i) {
		this._eyeX = t;
		this._eyeY = e;
		this._eyeZ = i;
		this._dirty = !0
	},
	setCenterXYZ: function(t, e, i) {
		this.setCenter(t, e, i)
	},
	setCenter: function(t, e, i) {
		this._centerX = t;
		this._centerY = e;
		this._centerZ = i;
		this._dirty = !0
	},
	setUpXYZ: function(t, e, i) {
		this.setUp(t, e, i)
	},
	setUp: function(t, e, i) {
		this._upX = t;
		this._upY = e;
		this._upZ = i;
		this._dirty = !0
	},
	getEyeXYZ: function(t, e, i) {
		return {
			x: this._eyeX,
			y: this._eyeY,
			z: this._eyeZ
		}
	},
	getEye: function() {
		return {
			x: this._eyeX,
			y: this._eyeY,
			z: this._eyeZ
		}
	},
	getCenterXYZ: function(t, e, i) {
		return {
			x: this._centerX,
			y: this._centerY,
			z: this._centerZ
		}
	},
	getCenter: function() {
		return {
			x: this._centerX,
			y: this._centerY,
			z: this._centerZ
		}
	},
	getUpXYZ: function(t, e, i) {
		return {
			x: this._upX,
			y: this._upY,
			z: this._upZ
		}
	},
	getUp: function() {
		return {
			x: this._upX,
			y: this._upY,
			z: this._upZ
		}
	},
	_DISALLOW_COPY_AND_ASSIGN: function(t) {}
});
cc.Camera.getZEye = function() {
	return cc.FLT_EPSILON
};
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function(t, e, i, n, r, c) {
	this.prev = t;
	this.next = e;
	this.target = i;
	this.priority = n;
	this.paused = r;
	this.markedForDeletion = c
};
cc.HashUpdateEntry = function(t, e, i, n) {
	this.list = t;
	this.entry = e;
	this.target = i;
	this.hh = n
};
cc.HashTimerEntry = function(t, e, i, n, r, c, s) {
	this.timers = t;
	this.target = e;
	this.timerIndex = i;
	this.currentTimer = n;
	this.currentTimerSalvaged = r;
	this.paused = c;
	this.hh = s
};
cc.Timer = cc.Class.extend({
	_interval: 0,
	_callback: null,
	_target: null,
	_elapsed: 0,
	_runForever: !1,
	_useDelay: !1,
	_timesExecuted: 0,
	_repeat: 0,
	_delay: 0,
	getInterval: function() {
		return this._interval
	},
	setInterval: function(t) {
		this._interval = t
	},
	getCallback: function() {
		return this._callback
	},
	ctor: function(t, e, i, n, r) {
		this._target = t;
		this._callback = e;
		this._elapsed = -1;
		this._interval = i || 0;
		this._delay = r || 0;
		this._useDelay = 0 < this._delay;
		this._repeat = null == n ? cc.REPEAT_FOREVER : n;
		this._runForever = this._repeat == cc.REPEAT_FOREVER
	},
	_doCallback: function() {
		if (cc.isString(this._callback)) this._target[this._callback](this._elapsed);
		else this._callback.call(this._target, this._elapsed)
	},
	update: function(t) {
		if (-1 == this._elapsed) this._timesExecuted = this._elapsed = 0;
		else {
			var e = this._target,
				i = this._callback;
			this._elapsed += t;
			this._runForever && !this._useDelay ? this._elapsed >= this._interval && (e && i && this._doCallback(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (e && i && this._doCallback(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (e && i && this._doCallback(), this._elapsed = 0, this._timesExecuted += 1), this._timesExecuted > this._repeat && cc.director.getScheduler().unscheduleCallbackForTarget(e, i))
		}
	}
});
cc.Scheduler = cc.Class.extend({
	_timeScale: 1,
	_updates: null,
	_hashForUpdates: null,
	_arrayForUpdates: null,
	_hashForTimers: null,
	_arrayForTimes: null,
	_currentTarget: null,
	_currentTargetSalvaged: !1,
	_updateHashLocked: !1,
	ctor: function() {
		this._timeScale = 1;
		this._updates = [
			[],
			[],
			[]
		];
		this._hashForUpdates = {};
		this._arrayForUpdates = [];
		this._hashForTimers = {};
		this._arrayForTimers = [];
		this._currentTarget = null;
		this._updateHashLocked = this._currentTargetSalvaged = !1
	},
	_removeHashElement: function(t) {
		delete this._hashForTimers[t.target.__instanceId];
		cc.arrayRemoveObject(this._arrayForTimers, t);
		t.Timer = null;
		t.target = null
	},
	_removeUpdateFromHash: function(t) {
		if (t = this._hashForUpdates[t.target.__instanceId]) cc.arrayRemoveObject(t.list, t.entry), delete this._hashForUpdates[t.target.__instanceId], cc.arrayRemoveObject(this._arrayForUpdates, t), t.entry = null, t.target = null
	},
	_priorityIn: function(t, e, i, n) {
		n = new cc.ListEntry(null, null, e, i, n, !1);
		if (t) {
			for (var r = t.length - 1, c = 0; c <= r && !(i < t[c].priority); c++);
			t.splice(c, 0, n)
		} else t = [], t.push(n);
		i = new cc.HashUpdateEntry(t, n, e, null);
		this._arrayForUpdates.push(i);
		this._hashForUpdates[e.__instanceId] = i;
		return t
	},
	_appendIn: function(t, e, i) {
		i = new cc.ListEntry(null, null, e, 0, i, !1);
		t.push(i);
		t = new cc.HashUpdateEntry(t, i, e, null);
		this._arrayForUpdates.push(t);
		this._hashForUpdates[e.__instanceId] = t
	},
	setTimeScale: function(t) {
		this._timeScale = t
	},
	getTimeScale: function() {
		return this._timeScale
	},
	update: function(t) {
		var e = this._updates,
			i = this._arrayForTimers,
			n, r, c;
		this._updateHashLocked = !0;
		1 != this._timeScale && (t *= this._timeScale);
		r = 0;
		for (c = e.length; r < c && 0 <= r; r++) for (var s = this._updates[r], o = 0, a = s.length; o < a; o++) n = s[o], !n.paused && !n.markedForDeletion && n.target.update(t);
		r = 0;
		for (c = i.length; r < c; r++) {
			n = i[r];
			if (!n) break;
			this._currentTarget = n;
			this._currentTargetSalvaged = !1;
			if (!n.paused) for (n.timerIndex = 0; n.timerIndex < n.timers.length; n.timerIndex++) n.currentTimer = n.timers[n.timerIndex], n.currentTimerSalvaged = !1, n.currentTimer.update(t), n.currentTimer = null;
			this._currentTargetSalvaged && 0 == n.timers.length && (this._removeHashElement(n), r--)
		}
		r = 0;
		for (c = e.length; r < c; r++) {
			s = this._updates[r];
			o = 0;
			for (a = s.length; o < a;) {
				n = s[o];
				if (!n) break;
				n.markedForDeletion ? this._removeUpdateFromHash(n) : o++
			}
		}
		this._updateHashLocked = !1;
		this._currentTarget = null
	},
	scheduleCallbackForTarget: function(t, e, i, n, r, c) {
		cc.assert(e, cc._LogInfos.Scheduler_scheduleCallbackForTarget_2);
		cc.assert(t, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
		i = i || 0;
		n = null == n ? cc.REPEAT_FOREVER : n;
		r = r || 0;
		c = c || !1;
		var s = this._hashForTimers[t.__instanceId];
		s || (s = new cc.HashTimerEntry(null, t, 0, null, null, c, null), this._arrayForTimers.push(s), this._hashForTimers[t.__instanceId] = s);
		if (null == s.timers) s.timers = [];
		else for (var o = 0; o < s.timers.length; o++) if (c = s.timers[o], e == c._callback) {
			cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, c.getInterval().toFixed(4), i.toFixed(4));
			c._interval = i;
			return
		}
		c = new cc.Timer(t, e, i, n, r);
		s.timers.push(c)
	},
	scheduleUpdateForTarget: function(t, e, i) {
		if (null !== t) {
			var n = this._updates,
				r = this._hashForUpdates[t.__instanceId];
			r ? r.entry.markedForDeletion = !1 : 0 == e ? this._appendIn(n[1], t, i) : 0 > e ? n[0] = this._priorityIn(n[0], t, e, i) : n[2] = this._priorityIn(n[2], t, e, i)
		}
	},
	unscheduleCallbackForTarget: function(t, e) {
		if (!(null == t || null == e)) {
			var i = this._hashForTimers[t.__instanceId];
			if (i) for (var n = i.timers, r = 0, c = n.length; r < c; r++) {
				var s = n[r];
				if (e == s._callback) {
					s == i.currentTimer && !i.currentTimerSalvaged && (i.currentTimerSalvaged = !0);
					n.splice(r, 1);
					i.timerIndex >= r && i.timerIndex--;
					0 == n.length && (this._currentTarget == i ? this._currentTargetSalvaged = !0 : this._removeHashElement(i));
					break
				}
			}
		}
	},
	unscheduleUpdateForTarget: function(t) {
		null != t && (t = this._hashForUpdates[t.__instanceId], null != t && (this._updateHashLocked ? t.entry.markedForDeletion = !0 : this._removeUpdateFromHash(t.entry)))
	},
	unscheduleAllCallbacksForTarget: function(t) {
		if (null != t) {
			var e = this._hashForTimers[t.__instanceId];
			if (e) {
				var i = e.timers;
				!e.currentTimerSalvaged && 0 <= i.indexOf(e.currentTimer) && (e.currentTimerSalvaged = !0);
				i.length = 0;
				this._currentTarget == e ? this._currentTargetSalvaged = !0 : this._removeHashElement(e)
			}
			this.unscheduleUpdateForTarget(t)
		}
	},
	unscheduleAllCallbacks: function() {
		this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
	},
	unscheduleAllCallbacksWithMinPriority: function(t) {
		for (var e = this._arrayForTimers, i = this._updates, n = 0, r = e.length; n < r; n++) this.unscheduleAllCallbacksForTarget(e[n].target);
		for (n = 2; 0 <= n; n--) if (!(1 == n && 0 < t || 0 == n && 0 <= t)) for (var e = i[n], r = 0, c = e.length; r < c; r++) this.unscheduleUpdateForTarget(e[r].target)
	},
	pauseAllTargets: function() {
		return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
	},
	pauseAllTargetsWithMinPriority: function(t) {
		t = [];
		for (var e, i = this._arrayForTimers, n = this._updates, r = 0, c = i.length; r < c; r++) if (e = i[r]) e.paused = !0, t.push(e.target);
		r = 0;
		for (c = n.length; r < c; r++) for (var i = n[r], s = 0, o = i.length; s < o; s++) if (e = i[s]) e.paused = !0, t.push(e.target);
		return t
	},
	resumeTargets: function(t) {
		if (t) for (var e = 0; e < t.length; e++) this.resumeTarget(t[e])
	},
	pauseTarget: function(t) {
		cc.assert(t, cc._LogInfos.Scheduler_pauseTarget);
		var e = this._hashForTimers[t.__instanceId];
		e && (e.paused = !0);
		if (t = this._hashForUpdates[t.__instanceId]) t.entry.paused = !0
	},
	resumeTarget: function(t) {
		cc.assert(t, cc._LogInfos.Scheduler_resumeTarget);
		var e = this._hashForTimers[t.__instanceId];
		e && (e.paused = !1);
		if (t = this._hashForUpdates[t.__instanceId]) t.entry.paused = !1
	},
	isTargetPaused: function(t) {
		cc.assert(t, cc._LogInfos.Scheduler_isTargetPaused);
		return (t = this._hashForTimers[t.__instanceId]) ? t.paused : !1
	}
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc.PI2 = 2 * Math.PI;
cc.DrawingPrimitiveCanvas = cc.Class.extend({
	_cacheArray: [],
	_renderContext: null,
	ctor: function(t) {
		this._renderContext = t
	},
	drawPoint: function(t, e) {
		e || (e = 1);
		var i = cc.view.getScaleX(),
			n = cc.view.getScaleY(),
			n = cc.p(t.x * i, t.y * n);
		this._renderContext.beginPath();
		this._renderContext.arc(n.x, -n.y, e * i, 0, 2 * Math.PI, !1);
		this._renderContext.closePath();
		this._renderContext.fill()
	},
	drawPoints: function(t, e, i) {
		if (null != t) {
			i || (i = 1);
			e = this._renderContext;
			var n = cc.view.getScaleX(),
				r = cc.view.getScaleY();
			e.beginPath();
			for (var c = 0, s = t.length; c < s; c++) e.arc(t[c].x * n, -t[c].y * r, i * n, 0, 2 * Math.PI, !1);
			e.closePath();
			e.fill()
		}
	},
	drawLine: function(t, e) {
		var i = this._renderContext,
			n = cc.view.getScaleX(),
			r = cc.view.getScaleY();
		i.beginPath();
		i.moveTo(t.x * n, -t.y * r);
		i.lineTo(e.x * n, -e.y * r);
		i.closePath();
		i.stroke()
	},
	drawRect: function(t, e) {
		this.drawLine(cc.p(t.x, t.y), cc.p(e.x, t.y));
		this.drawLine(cc.p(e.x, t.y), cc.p(e.x, e.y));
		this.drawLine(cc.p(e.x, e.y), cc.p(t.x, e.y));
		this.drawLine(cc.p(t.x, e.y), cc.p(t.x, t.y))
	},
	drawSolidRect: function(t, e, i) {
		t = [t, cc.p(e.x, t.y), e, cc.p(t.x, e.y)];
		this.drawSolidPoly(t, 4, i)
	},
	drawPoly: function(t, e, i, n) {
		n = n || !1;
		if (null != t) {
			if (3 > t.length) throw Error("Polygon's point must greater than 2");
			var r = t[0];
			e = this._renderContext;
			var c = cc.view.getScaleX(),
				s = cc.view.getScaleY();
			e.beginPath();
			e.moveTo(r.x * c, -r.y * s);
			for (var r = 1, o = t.length; r < o; r++) e.lineTo(t[r].x * c, -t[r].y * s);
			i && e.closePath();
			n ? e.fill() : e.stroke()
		}
	},
	drawSolidPoly: function(t, e, i) {
		this.setDrawColor(i.r, i.g, i.b, i.a);
		this.drawPoly(t, e, !0, !0)
	},
	drawCircle: function(t, e, i, n, r) {
		r = r || !1;
		n = this._renderContext;
		var c = cc.view.getScaleX(),
			s = cc.view.getScaleY();
		n.beginPath();
		n.arc(0 | t.x * c, 0 | -(t.y * s), e * c, -i, -(i - 2 * Math.PI), !1);
		r && n.lineTo(0 | t.x * c, 0 | -(t.y * s));
		n.stroke()
	},
	drawQuadBezier: function(t, e, i, n) {
		for (var r = this._cacheArray, c = r.length = 0, s = 0; s < n; s++) {
			var o = Math.pow(1 - c, 2) * t.x + 2 * (1 - c) * c * e.x + c * c * i.x,
				a = Math.pow(1 - c, 2) * t.y + 2 * (1 - c) * c * e.y + c * c * i.y;
			r.push(cc.p(o, a));
			c += 1 / n
		}
		r.push(cc.p(i.x, i.y));
		this.drawPoly(r, n + 1, !1, !1)
	},
	drawCubicBezier: function(t, e, i, n, r) {
		for (var c = this._cacheArray, s = c.length = 0, o = 0; o < r; o++) {
			var a = Math.pow(1 - s, 3) * t.x + 3 * Math.pow(1 - s, 2) * s * e.x + 3 * (1 - s) * s * s * i.x + s * s * s * n.x,
				h = Math.pow(1 - s, 3) * t.y + 3 * Math.pow(1 - s, 2) * s * e.y + 3 * (1 - s) * s * s * i.y + s * s * s * n.y;
			c.push(cc.p(a, h));
			s += 1 / r
		}
		c.push(cc.p(n.x, n.y));
		this.drawPoly(c, r + 1, !1, !1)
	},
	drawCatmullRom: function(t, e) {
		this.drawCardinalSpline(t, .5, e)
	},
	drawCardinalSpline: function(t, e, i) {
		cc._renderContext.strokeStyle = "rgba(255,255,255,1)";
		var n = this._cacheArray;
		n.length = 0;
		for (var r, c, s = 1 / t.length, o = 0; o < i + 1; o++) c = o / i, 1 == c ? (r = t.length - 1, c = 1) : (r = 0 | c / s, c = (c - s * r) / s), r = cc.CardinalSplineAt(cc.getControlPointAt(t, r - 1), cc.getControlPointAt(t, r - 0), cc.getControlPointAt(t, r + 1), cc.getControlPointAt(t, r + 2), e, c), n.push(r);
		this.drawPoly(n, i + 1, !1, !1)
	},
	drawImage: function(t, e, i, n, r) {
		switch (arguments.length) {
		case 2:
			this._renderContext.drawImage(t, e.x, -(e.y + t.height));
			break;
		case 3:
			this._renderContext.drawImage(t, e.x, -(e.y + i.height), i.width, i.height);
			break;
		case 5:
			this._renderContext.drawImage(t, e.x, e.y, i.width, i.height, n.x, -(n.y + r.height), r.width, r.height);
			break;
		default:
			throw Error("Argument must be non-nil")
		}
	},
	drawStar: function(t, e, i) {
		t = t || this._renderContext;
		e *= cc.view.getScaleX();
		i = "rgba(" + (0 | i.r) + "," + (0 | i.g) + "," + (0 | i.b);
		t.fillStyle = i + ",1)";
		var n = e / 10;
		t.beginPath();
		t.moveTo(-e, e);
		t.lineTo(0, n);
		t.lineTo(e, e);
		t.lineTo(n, 0);
		t.lineTo(e, -e);
		t.lineTo(0, -n);
		t.lineTo(-e, -e);
		t.lineTo(-n, 0);
		t.lineTo(-e, e);
		t.closePath();
		t.fill();
		var r = t.createRadialGradient(0, 0, n, 0, 0, e);
		r.addColorStop(0, i + ", 1)");
		r.addColorStop(.3, i + ", 0.8)");
		r.addColorStop(1, i + ", 0.0)");
		t.fillStyle = r;
		t.beginPath();
		t.arc(0, 0, e - n, 0, cc.PI2, !1);
		t.closePath();
		t.fill()
	},
	drawColorBall: function(t, e, i) {
		t = t || this._renderContext;
		e *= cc.view.getScaleX();
		i = "rgba(" + (0 | i.r) + "," + (0 | i.g) + "," + (0 | i.b);
		var n = t.createRadialGradient(0, 0, e / 10, 0, 0, e);
		n.addColorStop(0, i + ", 1)");
		n.addColorStop(.3, i + ", 0.8)");
		n.addColorStop(.6, i + ", 0.4)");
		n.addColorStop(1, i + ", 0.0)");
		t.fillStyle = n;
		t.beginPath();
		t.arc(0, 0, e, 0, cc.PI2, !1);
		t.closePath();
		t.fill()
	},
	fillText: function(t, e, i) {
		this._renderContext.fillText(t, e, -i)
	},
	setDrawColor: function(t, e, i, n) {
		this._renderContext.fillStyle = "rgba(" + t + "," + e + "," + i + "," + n / 255 + ")";
		this._renderContext.strokeStyle = "rgba(" + t + "," + e + "," + i + "," + n / 255 + ")"
	},
	setPointSize: function(t) {},
	setLineWidth: function(t) {
		this._renderContext.lineWidth = t * cc.view.getScaleX()
	}
});
cc.DrawingPrimitiveWebGL = cc.Class.extend({
	_renderContext: null,
	_initialized: !1,
	_shader: null,
	_colorLocation: -1,
	_colorArray: null,
	_pointSizeLocation: -1,
	_pointSize: -1,
	ctor: function(t) {
		null == t && (t = cc._renderContext);
		if (!t instanceof WebGLRenderingContext) throw "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
		this._renderContext = t;
		this._colorArray = new Float32Array([1, 1, 1, 1])
	},
	lazy_init: function() {
		this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR), this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
	},
	drawInit: function() {
		this._initialized = !1
	},
	drawPoint: function(t) {
		this.lazy_init();
		var e = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		e.uniform4fv(this._colorLocation, this._colorArray);
		this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
		var i = e.createBuffer();
		e.bindBuffer(e.ARRAY_BUFFER, i);
		e.bufferData(e.ARRAY_BUFFER, new Float32Array([t.x, t.y]), e.STATIC_DRAW);
		e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, e.FLOAT, !1, 0, 0);
		e.drawArrays(e.POINTS, 0, 1);
		e.deleteBuffer(i);
		cc.incrementGLDraws(1)
	},
	drawPoints: function(t, e) {
		if (t && 0 != t.length) {
			this.lazy_init();
			var i = this._renderContext;
			this._shader.use();
			this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
			i.uniform4fv(this._colorLocation, this._colorArray);
			this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
			var n = i.createBuffer();
			i.bindBuffer(i.ARRAY_BUFFER, n);
			i.bufferData(i.ARRAY_BUFFER, this._pointsToTypeArray(t), i.STATIC_DRAW);
			i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, i.FLOAT, !1, 0, 0);
			i.drawArrays(i.POINTS, 0, t.length);
			i.deleteBuffer(n);
			cc.incrementGLDraws(1)
		}
	},
	_pointsToTypeArray: function(t) {
		for (var e = new Float32Array(2 * t.length), i = 0; i < t.length; i++) e[2 * i] = t[i].x, e[2 * i + 1] = t[i].y;
		return e
	},
	drawLine: function(t, e) {
		this.lazy_init();
		var i = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		i.uniform4fv(this._colorLocation, this._colorArray);
		var n = i.createBuffer();
		i.bindBuffer(i.ARRAY_BUFFER, n);
		i.bufferData(i.ARRAY_BUFFER, this._pointsToTypeArray([t, e]), i.STATIC_DRAW);
		i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, i.FLOAT, !1, 0, 0);
		i.drawArrays(i.LINES, 0, 2);
		i.deleteBuffer(n);
		cc.incrementGLDraws(1)
	},
	drawRect: function(t, e) {
		this.drawLine(cc.p(t.x, t.y), cc.p(e.x, t.y));
		this.drawLine(cc.p(e.x, t.y), cc.p(e.x, e.y));
		this.drawLine(cc.p(e.x, e.y), cc.p(t.x, e.y));
		this.drawLine(cc.p(t.x, e.y), cc.p(t.x, t.y))
	},
	drawSolidRect: function(t, e, i) {
		t = [t, cc.p(e.x, t.y), e, cc.p(t.x, e.y)];
		this.drawSolidPoly(t, 4, i)
	},
	drawPoly: function(t, e, i) {
		this.lazy_init();
		e = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		e.uniform4fv(this._colorLocation, this._colorArray);
		var n = e.createBuffer();
		e.bindBuffer(e.ARRAY_BUFFER, n);
		e.bufferData(e.ARRAY_BUFFER, this._pointsToTypeArray(t), e.STATIC_DRAW);
		e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, e.FLOAT, !1, 0, 0);
		i ? e.drawArrays(e.LINE_LOOP, 0, t.length) : e.drawArrays(e.LINE_STRIP, 0, t.length);
		e.deleteBuffer(n);
		cc.incrementGLDraws(1)
	},
	drawSolidPoly: function(t, e, i) {
		this.lazy_init();
		i && this.setDrawColor(i.r, i.g, i.b, i.a);
		e = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		e.uniform4fv(this._colorLocation, this._colorArray);
		i = e.createBuffer();
		e.bindBuffer(e.ARRAY_BUFFER, i);
		e.bufferData(e.ARRAY_BUFFER, this._pointsToTypeArray(t), e.STATIC_DRAW);
		e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, e.FLOAT, !1, 0, 0);
		e.drawArrays(e.TRIANGLE_FAN, 0, t.length);
		e.deleteBuffer(i);
		cc.incrementGLDraws(1)
	},
	drawCircle: function(t, e, i, n, r) {
		this.lazy_init();
		var c = 1;
		r && c++;
		var s = 2 * Math.PI / n;
		if (r = new Float32Array(2 * (n + 2))) {
			for (var o = 0; o <= n; o++) {
				var a = o * s,
					h = e * Math.cos(a + i) + t.x,
					a = e * Math.sin(a + i) + t.y;
				r[2 * o] = h;
				r[2 * o + 1] = a
			}
			r[2 * (n + 1)] = t.x;
			r[2 * (n + 1) + 1] = t.y;
			t = this._renderContext;
			this._shader.use();
			this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
			t.uniform4fv(this._colorLocation, this._colorArray);
			e = t.createBuffer();
			t.bindBuffer(t.ARRAY_BUFFER, e);
			t.bufferData(t.ARRAY_BUFFER, r, t.STATIC_DRAW);
			t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0);
			t.drawArrays(t.LINE_STRIP, 0, n + c);
			t.deleteBuffer(e);
			cc.incrementGLDraws(1)
		}
	},
	drawQuadBezier: function(t, e, i, n) {
		this.lazy_init();
		for (var r = new Float32Array(2 * (n + 1)), c = 0, s = 0; s < n; s++) r[2 * s] = Math.pow(1 - c, 2) * t.x + 2 * (1 - c) * c * e.x + c * c * i.x, r[2 * s + 1] = Math.pow(1 - c, 2) * t.y + 2 * (1 - c) * c * e.y + c * c * i.y, c += 1 / n;
		r[2 * n] = i.x;
		r[2 * n + 1] = i.y;
		t = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		t.uniform4fv(this._colorLocation, this._colorArray);
		e = t.createBuffer();
		t.bindBuffer(t.ARRAY_BUFFER, e);
		t.bufferData(t.ARRAY_BUFFER, r, t.STATIC_DRAW);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0);
		t.drawArrays(t.LINE_STRIP, 0, n + 1);
		t.deleteBuffer(e);
		cc.incrementGLDraws(1)
	},
	drawCubicBezier: function(t, e, i, n, r) {
		this.lazy_init();
		for (var c = new Float32Array(2 * (r + 1)), s = 0, o = 0; o < r; o++) c[2 * o] = Math.pow(1 - s, 3) * t.x + 3 * Math.pow(1 - s, 2) * s * e.x + 3 * (1 - s) * s * s * i.x + s * s * s * n.x, c[2 * o + 1] = Math.pow(1 - s, 3) * t.y + 3 * Math.pow(1 - s, 2) * s * e.y + 3 * (1 - s) * s * s * i.y + s * s * s * n.y, s += 1 / r;
		c[2 * r] = n.x;
		c[2 * r + 1] = n.y;
		t = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		t.uniform4fv(this._colorLocation, this._colorArray);
		e = t.createBuffer();
		t.bindBuffer(t.ARRAY_BUFFER, e);
		t.bufferData(t.ARRAY_BUFFER, c, t.STATIC_DRAW);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0);
		t.drawArrays(t.LINE_STRIP, 0, r + 1);
		t.deleteBuffer(e);
		cc.incrementGLDraws(1)
	},
	drawCatmullRom: function(t, e) {
		this.drawCardinalSpline(t, .5, e)
	},
	drawCardinalSpline: function(t, e, i) {
		this.lazy_init();
		for (var n = new Float32Array(2 * (i + 1)), r, c, s = 1 / t.length, o = 0; o < i + 1; o++) c = o / i, 1 == c ? (r = t.length - 1, c = 1) : (r = 0 | c / s, c = (c - s * r) / s), r = cc.CardinalSplineAt(cc.getControlPointAt(t, r - 1), cc.getControlPointAt(t, r), cc.getControlPointAt(t, r + 1), cc.getControlPointAt(t, r + 2), e, c), n[2 * o] = r.x, n[2 * o + 1] = r.y;
		t = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		t.uniform4fv(this._colorLocation, this._colorArray);
		e = t.createBuffer();
		t.bindBuffer(t.ARRAY_BUFFER, e);
		t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0);
		t.drawArrays(t.LINE_STRIP, 0, i + 1);
		t.deleteBuffer(e);
		cc.incrementGLDraws(1)
	},
	setDrawColor: function(t, e, i, n) {
		this._colorArray[0] = t / 255;
		this._colorArray[1] = e / 255;
		this._colorArray[2] = i / 255;
		this._colorArray[3] = n / 255
	},
	setPointSize: function(t) {
		this._pointSize = t * cc.contentScaleFactor()
	},
	setLineWidth: function(t) {
		this._renderContext.lineWidth && this._renderContext.lineWidth(t)
	}
});
cc._tmp.PrototypeLabelTTF = function() {
	var t = cc.LabelTTF.prototype;
	cc.defineGetterSetter(t, "color", t.getColor, t.setColor);
	cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity);
	cc.defineGetterSetter(t, "string", t.getString, t.setString);
	cc.defineGetterSetter(t, "textAlign", t.getHorizontalAlignment, t.setHorizontalAlignment);
	cc.defineGetterSetter(t, "verticalAlign", t.getVerticalAlignment, t.setVerticalAlignment);
	cc.defineGetterSetter(t, "fontSize", t.getFontSize, t.setFontSize);
	cc.defineGetterSetter(t, "fontName", t.getFontName, t.setFontName);
	cc.defineGetterSetter(t, "font", t._getFont, t._setFont);
	cc.defineGetterSetter(t, "boundingWidth", t._getBoundingWidth, t._setBoundingWidth);
	cc.defineGetterSetter(t, "boundingHeight", t._getBoundingHeight, t._setBoundingHeight);
	cc.defineGetterSetter(t, "fillStyle", t._getFillStyle, t.setFontFillColor);
	cc.defineGetterSetter(t, "strokeStyle", t._getStrokeStyle, t._setStrokeStyle);
	cc.defineGetterSetter(t, "lineWidth", t._getLineWidth, t._setLineWidth);
	cc.defineGetterSetter(t, "shadowOffsetX", t._getShadowOffsetX, t._setShadowOffsetX);
	cc.defineGetterSetter(t, "shadowOffsetY", t._getShadowOffsetY, t._setShadowOffsetY);
	cc.defineGetterSetter(t, "shadowOpacity", t._getShadowOpacity, t._setShadowOpacity);
	cc.defineGetterSetter(t, "shadowBlur", t._getShadowBlur, t._setShadowBlur)
};
cc.LabelTTF = cc.Sprite.extend({
	_dimensions: null,
	_hAlignment: cc.TEXT_ALIGNMENT_CENTER,
	_vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
	_fontName: null,
	_fontSize: 0,
	_string: "",
	_originalText: null,
	_shadowEnabled: !1,
	_shadowOffset: null,
	_shadowOpacity: 0,
	_shadowBlur: 0,
	_shadowColor: null,
	_strokeEnabled: !1,
	_strokeColor: null,
	_strokeSize: 0,
	_textFillColor: null,
	_strokeShadowOffsetX: 0,
	_strokeShadowOffsetY: 0,
	_needUpdateTexture: !1,
	_lineWidths: null,
	_className: "LabelTTF",
	_lineHeight: 0,
	initWithString: function(t, e, i, n, r, c) {
		t = t ? t + "" : "";
		i = i || 16;
		n = n || cc.size(0, 0);
		r = r || cc.TEXT_ALIGNMENT_LEFT;
		c = c || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
		this._opacityModifyRGB = !1;
		this._dimensions = cc.size(n.width, n.height);
		this._fontName = e || "Arial";
		this._hAlignment = r;
		this._vAlignment = c;
		this._fontSize = i;
		this._renderCmd._setFontStyle(this._fontName, i);
		this.string = t;
		this._renderCmd._setColorsString();
		this._renderCmd._updateTexture();
		this._setUpdateTextureDirty();
		return !0
	},
	_setUpdateTextureDirty: function() {
		this._needUpdateTexture = !0;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.textDirty)
	},
	ctor: function(t, e, i, n, r, c) {
		cc.Sprite.prototype.ctor.call(this);
		this._dimensions = cc.size(0, 0);
		this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
		this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
		this._opacityModifyRGB = !1;
		this._fontName = "Arial";
		this._shadowEnabled = !1;
		this._shadowOffset = cc.p(0, 0);
		this._shadowBlur = this._shadowOpacity = 0;
		this._strokeEnabled = !1;
		this._strokeColor = cc.color(255, 255, 255, 255);
		this._strokeSize = 0;
		this._textFillColor = cc.color(255, 255, 255, 255);
		this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
		this._needUpdateTexture = !1;
		this._lineWidths = [];
		this._renderCmd._setColorsString();
		e && e instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(t, e) : cc.LabelTTF.prototype.initWithString.call(this, t, e, i, n, r, c)
	},
	init: function() {
		return this.initWithString(" ", this._fontName, this._fontSize)
	},
	description: function() {
		return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">"
	},
	getLineHeight: function() {
		return this._lineHeight || this._renderCmd._getFontClientHeight()
	},
	setLineHeight: function(t) {
		this._lineHeight = t
	},
	getString: function() {
		return this._string
	},
	getHorizontalAlignment: function() {
		return this._hAlignment
	},
	getVerticalAlignment: function() {
		return this._vAlignment
	},
	getDimensions: function() {
		return cc.size(this._dimensions)
	},
	getFontSize: function() {
		return this._fontSize
	},
	getFontName: function() {
		return this._fontName
	},
	initWithStringAndTextDefinition: function(t, e) {
		this._updateWithTextDefinition(e, !1);
		this.string = t;
		return !0
	},
	setTextDefinition: function(t) {
		t && this._updateWithTextDefinition(t, !0)
	},
	getTextDefinition: function() {
		return this._prepareTextDefinition(!1)
	},
	enableShadow: function(t, e, i, n) {
		null != t.r && null != t.g && null != t.b && null != t.a ? this._enableShadow(t, e, i) : this._enableShadowNoneColor(t, e, i, n)
	},
	_enableShadowNoneColor: function(t, e, i, n) {
		i = i || .5;
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		var r = this._shadowOffset;
		if (r && r.x != t || r._y != e) r.x = t, r.y = e;
		this._shadowOpacity != i && (this._shadowOpacity = i);
		this._renderCmd._setColorsString();
		this._shadowBlur != n && (this._shadowBlur = n);
		this._setUpdateTextureDirty()
	},
	_enableShadow: function(t, e, i) {
		this._shadowColor || (this._shadowColor = cc.color(255, 255, 255, 128));
		this._shadowColor.r = t.r;
		this._shadowColor.g = t.g;
		this._shadowColor.b = t.b;
		this._enableShadowNoneColor(e.width || e.x || 0, e.height || e.y || 0, null != t.a ? t.a / 255 : .5, i)
	},
	_getShadowOffsetX: function() {
		return this._shadowOffset.x
	},
	_setShadowOffsetX: function(t) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowOffset.x != t && (this._shadowOffset.x = t, this._setUpdateTextureDirty())
	},
	_getShadowOffsetY: function() {
		return this._shadowOffset._y
	},
	_setShadowOffsetY: function(t) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowOffset._y != t && (this._shadowOffset._y = t, this._setUpdateTextureDirty())
	},
	_getShadowOffset: function() {
		return cc.p(this._shadowOffset.x, this._shadowOffset.y)
	},
	_setShadowOffset: function(t) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		if (this._shadowOffset.x != t.x || this._shadowOffset.y != t.y) this._shadowOffset.x = t.x, this._shadowOffset.y = t.y, this._setUpdateTextureDirty()
	},
	_getShadowOpacity: function() {
		return this._shadowOpacity
	},
	_setShadowOpacity: function(t) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowOpacity != t && (this._shadowOpacity = t, this._renderCmd._setColorsString(), this._setUpdateTextureDirty())
	},
	_getShadowBlur: function() {
		return this._shadowBlur
	},
	_setShadowBlur: function(t) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowBlur != t && (this._shadowBlur = t, this._setUpdateTextureDirty())
	},
	disableShadow: function() {
		this._shadowEnabled && (this._shadowEnabled = !1, this._setUpdateTextureDirty())
	},
	enableStroke: function(t, e) {
		!1 === this._strokeEnabled && (this._strokeEnabled = !0);
		var i = this._strokeColor;
		if (i.r !== t.r || i.g !== t.g || i.b !== t.b) i.r = t.r, i.g = t.g, i.b = t.b, this._renderCmd._setColorsString();
		this._strokeSize !== e && (this._strokeSize = e || 0);
		this._setUpdateTextureDirty()
	},
	_getStrokeStyle: function() {
		return this._strokeColor
	},
	_setStrokeStyle: function(t) {
		!1 === this._strokeEnabled && (this._strokeEnabled = !0);
		var e = this._strokeColor;
		if (e.r !== t.r || e.g !== t.g || e.b !== t.b) e.r = t.r, e.g = t.g, e.b = t.b, this._renderCmd._setColorsString(), this._setUpdateTextureDirty()
	},
	_getLineWidth: function() {
		return this._strokeSize
	},
	_setLineWidth: function(t) {
		!1 === this._strokeEnabled && (this._strokeEnabled = !0);
		this._strokeSize !== t && (this._strokeSize = t || 0, this._setUpdateTextureDirty())
	},
	disableStroke: function() {
		this._strokeEnabled && (this._strokeEnabled = !1, this._setUpdateTextureDirty())
	},
	setFontFillColor: function(t) {
		var e = this._textFillColor;
		if (e.r != t.r || e.g != t.g || e.b != t.b) e.r = t.r, e.g = t.g, e.b = t.b, this._renderCmd._setColorsString(), this._needUpdateTexture = !0
	},
	_getFillStyle: function() {
		return this._textFillColor
	},
	_updateWithTextDefinition: function(t, e) {
		t.fontDimensions ? (this._dimensions.width = t.boundingWidth, this._dimensions.height = t.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
		this._hAlignment = t.textAlign;
		this._vAlignment = t.verticalAlign;
		this._fontName = t.fontName;
		this._fontSize = t.fontSize || 12;
		this._renderCmd._setFontStyle(this._fontName, this._fontSize);
		t.shadowEnabled && this.enableShadow(t.shadowOffsetX, t.shadowOffsetY, t.shadowOpacity, t.shadowBlur);
		t.strokeEnabled && this.enableStroke(t.strokeStyle, t.lineWidth);
		this.setFontFillColor(t.fillStyle);
		e && this._renderCmd._updateTexture();
		var i = cc.Node._dirtyFlags;
		this._renderCmd.setDirtyFlag(i.colorDirty | i.opacityDirty | i.textDirty)
	},
	_prepareTextDefinition: function(t) {
		var e = new cc.FontDefinition;
		t ? (e.fontSize = this._fontSize, e.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, e.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (e.fontSize = this._fontSize, e.boundingWidth = this._dimensions.width, e.boundingHeight = this._dimensions.height);
		e.fontName = this._fontName;
		e.textAlign = this._hAlignment;
		e.verticalAlign = this._vAlignment;
		if (this._strokeEnabled) {
			e.strokeEnabled = !0;
			var i = this._strokeColor;
			e.strokeStyle = cc.color(i.r, i.g, i.b);
			e.lineWidth = this._strokeSize
		} else e.strokeEnabled = !1;
		this._shadowEnabled ? (e.shadowEnabled = !0, e.shadowBlur = this._shadowBlur, e.shadowOpacity = this._shadowOpacity, e.shadowOffsetX = (t ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, e.shadowOffsetY = (t ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : e._shadowEnabled = !1;
		t = this._textFillColor;
		e.fillStyle = cc.color(t.r, t.g, t.b);
		return e
	},
	setString: function(t) {
		t = String(t);
		this._originalText != t && (this._originalText = t + "", this._updateString(), this._setUpdateTextureDirty(), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
	},
	_updateString: function() {
		if ((!this._string || "" === this._string) && this._string !== this._originalText) cc.renderer.childrenOrderDirty = !0;
		this._string = this._originalText
	},
	setHorizontalAlignment: function(t) {
		t !== this._hAlignment && (this._hAlignment = t, this._setUpdateTextureDirty())
	},
	setVerticalAlignment: function(t) {
		t != this._vAlignment && (this._vAlignment = t, this._setUpdateTextureDirty())
	},
	setDimensions: function(t, e) {
		var i;
		void 0 === e ? (i = t.width, e = t.height) : i = t;
		if (i != this._dimensions.width || e != this._dimensions.height) this._dimensions.width = i, this._dimensions.height = e, this._updateString(), this._setUpdateTextureDirty()
	},
	_getBoundingWidth: function() {
		return this._dimensions.width
	},
	_setBoundingWidth: function(t) {
		t != this._dimensions.width && (this._dimensions.width = t, this._updateString(), this._setUpdateTextureDirty())
	},
	_getBoundingHeight: function() {
		return this._dimensions.height
	},
	_setBoundingHeight: function(t) {
		t != this._dimensions.height && (this._dimensions.height = t, this._updateString(), this._setUpdateTextureDirty())
	},
	setFontSize: function(t) {
		this._fontSize !== t && (this._fontSize = t, this._renderCmd._setFontStyle(this._fontName, this._fontSize), this._setUpdateTextureDirty())
	},
	setFontName: function(t) {
		this._fontName && this._fontName != t && (this._fontName = t, this._renderCmd._setFontStyle(this._fontName, this._fontSize), this._setUpdateTextureDirty())
	},
	_getFont: function() {
		return this._renderCmd._getFontStyle()
	},
	_setFont: function(t) {
		if (t = cc.LabelTTF._fontStyleRE.exec(t)) this._fontSize = parseInt(t[1]), this._fontName = t[2], this._renderCmd._setFontStyle(this._fontName, this._fontSize), this._setUpdateTextureDirty()
	},
	getContentSize: function() {
		this._needUpdateTexture && this._renderCmd._updateTTF();
		return cc.Sprite.prototype.getContentSize.call(this)
	},
	_getWidth: function() {
		this._needUpdateTexture && this._renderCmd._updateTTF();
		return cc.Sprite.prototype._getWidth.call(this)
	},
	_getHeight: function() {
		this._needUpdateTexture && this._renderCmd._updateTTF();
		return cc.Sprite.prototype._getHeight.call(this)
	},
	setTextureRect: function(t, e, i) {
		cc.Sprite.prototype.setTextureRect.call(this, t, e, i, !1)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LabelTTF.CanvasRenderCmd(this) : new cc.LabelTTF.WebGLRenderCmd(this)
	}
});
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function(t, e, i, n, r, c) {
	return new cc.LabelTTF(t, e, i, n, r, c)
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = cc.newElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function() {
	this.removeEventListener("load", arguments.callee, !1);
	document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function(t, e) {
	var i = cc.LabelTTF.__fontHeightCache[t + "." + e];
	if (0 < i) return i;
	var n = cc.LabelTTF.__labelHeightDiv;
	n.innerHTML = "ajghl~!";
	n.style.fontFamily = t;
	n.style.fontSize = e + "px";
	i = n.clientHeight;
	cc.LabelTTF.__fontHeightCache[t + "." + e] = i;
	n.innerHTML = "";
	return i
};
cc.LabelTTF.__fontHeightCache = {};
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = !0;
cc.LabelTTF._wordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]/;
(function() {
	cc.LabelTTF.RenderCmd = function() {
		this._fontClientHeight = 18;
		this._fontStyleStr = "";
		this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
		this._strokeColorStr = "";
		this._fillColorStr = "rgba(255,255,255,1)";
		this._labelContext = this._labelCanvas = null;
		this._lineWidths = [];
		this._strings = [];
		this._isMultiLine = !1
	};
	var t = cc.LabelTTF.RenderCmd.prototype;
	t.constructor = cc.LabelTTF.RenderCmd;
	t.updateStatus = function() {
		var t = cc.Node._dirtyFlags,
			e = this._dirtyFlag,
			i = e & t.colorDirty,
			n = e & t.opacityDirty;
		i && this._updateDisplayColor();
		n && this._updateDisplayOpacity();
		i || n ? (this._setColorsString(), this._updateColor(), this._updateTexture()) : e & t.textDirty && this._updateTexture();
		this._dirtyFlag & t.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
	};
	t._getLabelContext = function() {
		if (this._labelContext) return this._labelContext;
		var t = this._node;
		if (!this._labelCanvas) {
			var e = cc.newElement("canvas"),
				i = new cc.Texture2D;
			i.initWithElement(e);
			t.setTexture(i);
			this._labelCanvas = e
		}
		return this._labelContext = this._labelCanvas.getContext("2d")
	};
	t._setFontStyle = function(t, e) {
		this._fontStyleStr = e + "px '" + t + "'";
		this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(t, e)
	};
	t._getFontStyle = function() {
		return this._fontStyleStr
	};
	t._getFontClientHeight = function() {
		return this._fontClientHeight
	};
	t._updateTexture = function() {
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.textDirty;
		var t = this._node,
			e = this._getLabelContext(),
			i = this._labelCanvas,
			n = t._contentSize;
		if (0 === t._string.length) return i.width = 1, i.height = n.height || 1, t._texture && t._texture.handleLoadedTexture(), t.setTextureRect(cc.rect(0, 0, 1, n.height)), !0;
		e.font = this._fontStyleStr;
		this._updateTTF();
		var r = n.width,
			n = n.height,
			c = i.width == r && i.height == n;
		i.width = r;
		i.height = n;
		c && e.clearRect(0, 0, r, n);
		this._drawTTFInCanvas(e);
		t._texture && t._texture.handleLoadedTexture();
		t.setTextureRect(cc.rect(0, 0, r, n));
		return !0
	};
	t._measureConfig = function() {
		this._getLabelContext().font = this._fontStyleStr
	};
	t._measure = function(t) {
		return this._getLabelContext().measureText(t).width
	};
	t._updateTTF = function() {
		var t = this._node,
			e = t._dimensions.width,
			i, n, r = this._lineWidths;
		r.length = 0;
		this._isMultiLine = !1;
		this._measureConfig();
		if (0 !== e) {
			this._strings = t._string.split("\n");
			for (i = 0; i < this._strings.length; i++) this._checkWarp(this._strings, i, e)
		} else {
			this._strings = t._string.split("\n");
			i = 0;
			for (n = this._strings.length; i < n; i++) r.push(this._measure(this._strings[i]))
		}
		0 < this._strings.length && (this._isMultiLine = !0);
		n = i = 0;
		t._strokeEnabled && (i = n = 2 * t._strokeSize);
		if (t._shadowEnabled) {
			var c = t._shadowOffset;
			i += 2 * Math.abs(c.x);
			n += 2 * Math.abs(c.y)
		}
		e = 0 === e ? this._isMultiLine ? cc.size(0 | Math.max.apply(Math, r) + i, 0 | this._fontClientHeight * this._strings.length + n) : cc.size(0 | this._measure(t._string) + i, 0 | this._fontClientHeight + n) : 0 === t._dimensions.height ? this._isMultiLine ? cc.size(0 | e + i, 0 | t.getLineHeight() * this._strings.length + n) : cc.size(0 | e + i, 0 | t.getLineHeight() + n) : cc.size(0 | e + i, 0 | t._dimensions.height + n);
		t.setContentSize(e);
		t._strokeShadowOffsetX = i;
		t._strokeShadowOffsetY = n;
		t = t._anchorPoint;
		this._anchorPointInPoints.x = .5 * i + (e.width - i) * t.x;
		this._anchorPointInPoints.y = .5 * n + (e.height - n) * t.y
	};
	t._drawTTFInCanvas = function(t) {
		if (t) {
			var e = this._node,
				i = e._strokeShadowOffsetX,
				n = e._strokeShadowOffsetY,
				r = e._contentSize.height - n,
				c = e._vAlignment,
				s = e._hAlignment,
				o = e._strokeSize;
			t.setTransform(1, 0, 0, 1, 0 + .5 * i, r + .5 * n);
			t.font != this._fontStyleStr && (t.font = this._fontStyleStr);
			t.fillStyle = this._fillColorStr;
			var a = n = 0,
				h = e._strokeEnabled;
			h && (t.lineWidth = 2 * o, t.strokeStyle = this._strokeColorStr);
			e._shadowEnabled && (o = e._shadowOffset, t.shadowColor = this._shadowColorStr, t.shadowOffsetX = o.x, t.shadowOffsetY = -o.y, t.shadowBlur = e._shadowBlur);
			t.textBaseline = cc.LabelTTF._textBaseline[c];
			t.textAlign = cc.LabelTTF._textAlign[s];
			var l = e._contentSize.width - i,
				i = e.getLineHeight(),
				o = (i - this._fontClientHeight) / 2,
				n = s === cc.TEXT_ALIGNMENT_RIGHT ? n + l : s === cc.TEXT_ALIGNMENT_CENTER ? n + l / 2 : n + 0;
			if (this._isMultiLine) {
				e = this._strings.length;
				c === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? a = i - 2 * o + r - i * e : c === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (a = (i - 2 * o) / 2 + (r - i * e) / 2);
				for (c = 0; c < e; c++) s = this._strings[c], l = -r + (i * c + o) + a, h && t.strokeText(s, n, l), t.fillText(s, n, l)
			} else c !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (a = c === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? a - r : a - .5 * r), h && t.strokeText(e._string, n, a), t.fillText(e._string, n, a)
		}
	};
	t._checkWarp = function(t, e, i) {
		var n = t[e],
			r = this._measure(n);
		if (r > i && 1 < n.length) {
			for (var c = n.length * (i / r) | 0, s = n.substr(c), o = r - this._measure(s), a, h = 0, l = 0; o > i && 100 > l++;) c *= i / o, c |= 0, s = n.substr(c), o = r - this._measure(s);
			for (l = 0; o < i && 100 > l++;) s && (h = (a = cc.LabelTTF._wordRex.exec(s)) ? a[0].length : 1, a = s), c += h, s = n.substr(c), o = r - this._measure(s);
			c -= h;
			0 === c && (c = 1, a = a.substr(1));
			i = n.substr(0, c);
			if (cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(a || s)) r = cc.LabelTTF._lastWordRex.exec(i), c -= r ? r[0].length : 0, a = n.substr(c), i = n.substr(0, c);
			if (cc.LabelTTF._firsrEnglish.test(a) && (r = cc.LabelTTF._lastEnglish.exec(i)) && i !== r[0]) c -= r[0].length, a = n.substr(c), i = n.substr(0, c);
			t[e] = a || s;
			t.splice(e, 0, i)
		}
	}
})();
(function() {
	cc.LabelTTF.CanvasRenderCmd = function(t) {
		cc.Sprite.CanvasRenderCmd.call(this, t);
		cc.LabelTTF.RenderCmd.call(this)
	};
	cc.LabelTTF.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
	cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CanvasRenderCmd.prototype);
	var t = cc.LabelTTF.CanvasRenderCmd.prototype;
	t.constructor = cc.LabelTTF.CanvasRenderCmd;
	t._syncStatus = function(t) {
		var e = cc.Node._dirtyFlags,
			i = this._dirtyFlag,
			n = t ? t._node : null;
		n && (n._cascadeColorEnabled && t._dirtyFlag & e.colorDirty) && (i |= e.colorDirty);
		n && (n._cascadeOpacityEnabled && t._dirtyFlag & e.opacityDirty) && (i |= e.opacityDirty);
		t && t._dirtyFlag & e.transformDirty && (i |= e.transformDirty);
		this._dirtyFlag = i;
		var n = i & e.colorDirty,
			r = i & e.opacityDirty;
		n && this._syncDisplayColor();
		r && this._syncDisplayOpacity();
		n || r ? (this._setColorsString(), this._updateColor(), this._updateTexture()) : i & e.textDirty && this._updateTexture();
		i & e.transformDirty && this.transform(t)
	};
	t._setColorsString = function() {
		var t = this._displayedColor,
			e = this._node,
			i = this._displayedOpacity,
			n = e._shadowColor || this._displayedColor,
			r = e._strokeColor,
			c = e._textFillColor;
		this._shadowColorStr = "rgba(" + (0 | .5 * n.r) + "," + (0 | .5 * n.g) + "," + (0 | .5 * n.b) + "," + e._shadowOpacity + ")";
		this._fillColorStr = "rgba(" + (0 | t.r / 255 * c.r) + "," + (0 | t.g / 255 * c.g) + "," + (0 | t.b / 255 * c.b) + ", " + i / 255 + ")";
		this._strokeColorStr = "rgba(" + (0 | t.r / 255 * r.r) + "," + (0 | t.g / 255 * r.g) + "," + (0 | t.b / 255 * r.b) + ", " + i / 255 + ")"
	};
	t._updateColor = function() {}
})();
(function() {
	cc.LabelTTF.WebGLRenderCmd = function(t) {
		cc.Sprite.WebGLRenderCmd.call(this, t);
		cc.LabelTTF.RenderCmd.call(this);
		this.setShaderProgram(cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM))
	};
	var t = cc.LabelTTF.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
	cc.inject(cc.LabelTTF.RenderCmd.prototype, t);
	t.constructor = cc.LabelTTF.WebGLRenderCmd;
	t._setColorsString = function() {
		this.setDirtyFlag(cc.Node._dirtyFlags.textDirty);
		var t = this._node,
			e = t._strokeColor,
			i = t._textFillColor;
		this._shadowColorStr = "rgba(128,128,128," + t._shadowOpacity + ")";
		this._fillColorStr = "rgba(" + (0 | i.r) + "," + (0 | i.g) + "," + (0 | i.b) + ", 1)";
		this._strokeColorStr = "rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + ", 1)"
	};
	t._syncStatus = function(t) {
		var e = cc.Node._dirtyFlags,
			i = this._dirtyFlag,
			n = t ? t._node : null;
		n && (n._cascadeColorEnabled && t._dirtyFlag & e.colorDirty) && (i |= e.colorDirty);
		n && (n._cascadeOpacityEnabled && t._dirtyFlag & e.opacityDirty) && (i |= e.opacityDirty);
		t && t._dirtyFlag & e.transformDirty && (i |= e.transformDirty);
		var n = i & e.colorDirty,
			r = i & e.opacityDirty;
		this._dirtyFlag = i;
		n && this._syncDisplayColor();
		r && this._syncDisplayOpacity();
		n || r ? (this._setColorsString(), this._updateColor(), this._updateTexture()) : i & e.textDirty && this._updateTexture();
		this.transform(t)
	}
})();
cc.HashElement = cc.Class.extend({
	actions: null,
	target: null,
	actionIndex: 0,
	currentAction: null,
	currentActionSalvaged: !1,
	paused: !1,
	hh: null,
	ctor: function() {
		this.actions = [];
		this.target = null;
		this.actionIndex = 0;
		this.currentAction = null;
		this.paused = this.currentActionSalvaged = !1;
		this.hh = null
	}
});
cc.ActionManager = cc.Class.extend({
	_hashTargets: null,
	_arrayTargets: null,
	_currentTarget: null,
	_currentTargetSalvaged: !1,
	_searchElementByTarget: function(t, e) {
		for (var i = 0; i < t.length; i++) if (e == t[i].target) return t[i];
		return null
	},
	ctor: function() {
		this._hashTargets = {};
		this._arrayTargets = [];
		this._currentTarget = null;
		this._currentTargetSalvaged = !1
	},
	addAction: function(t, e, i) {
		if (!t) throw "cc.ActionManager.addAction(): action must be non-null";
		if (!e) throw "cc.ActionManager.addAction(): action must be non-null";
		var n = this._hashTargets[e.__instanceId];
		n || (n = new cc.HashElement, n.paused = i, n.target = e, this._hashTargets[e.__instanceId] = n, this._arrayTargets.push(n));
		this._actionAllocWithHashElement(n);
		n.actions.push(t);
		t.startWithTarget(e)
	},
	removeAllActions: function() {
		for (var t = this._arrayTargets, e = 0; e < t.length; e++) {
			var i = t[e];
			i && this.removeAllActionsFromTarget(i.target, !0)
		}
	},
	removeAllActionsFromTarget: function(t, e) {
		if (null != t) {
			var i = this._hashTargets[t.__instanceId];
			i && (-1 !== i.actions.indexOf(i.currentAction) && !i.currentActionSalvaged && (i.currentActionSalvaged = !0), i.actions.length = 0, this._currentTarget == i && !e ? this._currentTargetSalvaged = !0 : this._deleteHashElement(i))
		}
	},
	removeAction: function(t) {
		if (null != t) {
			var e = t.getOriginalTarget();
			if (e = this._hashTargets[e.__instanceId]) for (var i = 0; i < e.actions.length; i++) {
				if (e.actions[i] == t) {
					e.actions.splice(i, 1);
					break
				}
			} else cc.log(cc._LogInfos.ActionManager_removeAction)
		}
	},
	removeActionByTag: function(t, e) {
		t == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction);
		cc.assert(e, cc._LogInfos.ActionManager_addAction);
		var i = this._hashTargets[e.__instanceId];
		if (i) for (var n = i.actions.length, r = 0; r < n; ++r) {
			var c = i.actions[r];
			if (c && c.getTag() === t && c.getOriginalTarget() == e) {
				this._removeActionAtIndex(r, i);
				break
			}
		}
	},
	getActionByTag: function(t, e) {
		t == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
		var i = this._hashTargets[e.__instanceId];
		if (i) {
			if (null != i.actions) for (var n = 0; n < i.actions.length; ++n) {
				var r = i.actions[n];
				if (r && r.getTag() === t) return r
			}
			cc.log(cc._LogInfos.ActionManager_getActionByTag_2, t)
		}
		return null
	},
	numberOfRunningActionsInTarget: function(t) {
		return (t = this._hashTargets[t.__instanceId]) ? t.actions ? t.actions.length : 0 : 0
	},
	pauseTarget: function(t) {
		if (t = this._hashTargets[t.__instanceId]) t.paused = !0
	},
	resumeTarget: function(t) {
		if (t = this._hashTargets[t.__instanceId]) t.paused = !1
	},
	pauseAllRunningActions: function() {
		for (var t = [], e = this._arrayTargets, i = 0; i < e.length; i++) {
			var n = e[i];
			n && !n.paused && (n.paused = !0, t.push(n.target))
		}
		return t
	},
	resumeTargets: function(t) {
		if (t) for (var e = 0; e < t.length; e++) t[e] && this.resumeTarget(t[e])
	},
	purgeSharedManager: function() {
		cc.director.getScheduler().unscheduleUpdateForTarget(this)
	},
	_removeActionAtIndex: function(t, e) {
		e.actions[t] == e.currentAction && !e.currentActionSalvaged && (e.currentActionSalvaged = !0);
		e.actions.splice(t, 1);
		e.actionIndex >= t && e.actionIndex--;
		0 == e.actions.length && (this._currentTarget == e ? this._currentTargetSalvaged = !0 : this._deleteHashElement(e))
	},
	_deleteHashElement: function(t) {
		t && (delete this._hashTargets[t.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, t), t.actions = null, t.target = null)
	},
	_actionAllocWithHashElement: function(t) {
		null == t.actions && (t.actions = [])
	},
	update: function(t) {
		for (var e = this._arrayTargets, i, n = 0; n < e.length; n++) {
			i = this._currentTarget = e[n];
			if (!i.paused) for (i.actionIndex = 0; i.actionIndex < i.actions.length; i.actionIndex++) if (i.currentAction = i.actions[i.actionIndex], i.currentAction) {
				i.currentActionSalvaged = !1;
				i.currentAction.step(t * (i.currentAction._speedMethod ? i.currentAction._speed : 1));
				if (i.currentActionSalvaged) i.currentAction = null;
				else if (i.currentAction.isDone()) {
					i.currentAction.stop();
					var r = i.currentAction;
					i.currentAction = null;
					this.removeAction(r)
				}
				i.currentAction = null
			}
			this._currentTargetSalvaged && 0 === i.actions.length && this._deleteHashElement(i)
		}
	}
});
cc.kmScalar = Number;
cc.kmBool = Number;
cc.kmEnum = Number;
cc.KM_FALSE = 0;
cc.KM_TRUE = 1;
cc.kmPI = 3.141592;
cc.kmPIOver180 = .017453;
cc.kmPIUnder180 = 57.295779;
cc.kmEpsilon = .015625;
cc.kmSQR = function(t) {
	return t * t
};
cc.kmDegreesToRadians = function(t) {
	return t * cc.kmPIOver180
};
cc.kmRadiansToDegrees = function(t) {
	return t * cc.kmPIUnder180
};
cc.kmMin = function(t, e) {
	return t < e ? t : e
};
cc.kmMax = function(t, e) {
	return t > e ? t : e
};
cc.kmAlmostEqual = function(t, e) {
	return t + cc.kmEpsilon > e && t - cc.kmEpsilon < e
};
cc.kmVec2 = function(t, e) {
	this.x = t || 0;
	this.y = e || 0
};
cc.kmVec2Fill = function(t, e, i) {
	t.x = e;
	t.y = i;
	return t
};
cc.kmVec2Length = function(t) {
	return Math.sqrt(cc.kmSQR(t.x) + cc.kmSQR(t.y))
};
cc.kmVec2LengthSq = function(t) {
	return cc.kmSQR(t.x) + cc.kmSQR(t.y)
};
cc.kmVec2Normalize = function(t, e) {
	var i = 1 / cc.kmVec2Length(e),
		n = new cc.kmVec2;
	n.x = e.x * i;
	n.y = e.y * i;
	t.x = n.x;
	t.y = n.y;
	return t
};
cc.kmVec2Add = function(t, e, i) {
	t.x = e.x + i.x;
	t.y = e.y + i.y;
	return t
};
cc.kmVec2Dot = function(t, e) {
	return t.x * e.x + t.y * e.y
};
cc.kmVec2Subtract = function(t, e, i) {
	t.x = e.x - i.x;
	t.y = e.y - i.y;
	return t
};
cc.kmVec2Transform = function(t, e, i) {
	var n = new cc.kmVec2;
	n.x = e.x * i.mat[0] + e.y * i.mat[3] + i.mat[6];
	n.y = e.x * i.mat[1] + e.y * i.mat[4] + i.mat[7];
	t.x = n.x;
	t.y = n.y;
	return t
};
cc.kmVec2TransformCoord = function(t, e, i) {
	return null
};
cc.kmVec2Scale = function(t, e, i) {
	t.x = e.x * i;
	t.y = e.y * i;
	return t
};
cc.kmVec2AreEqual = function(t, e) {
	return t.x < e.x + cc.kmEpsilon && t.x > e.x - cc.kmEpsilon && t.y < e.y + cc.kmEpsilon && t.y > e.y - cc.kmEpsilon
};
cc.kmVec3 = function(t, e, i) {
	this.x = t || 0;
	this.y = e || 0;
	this.z = i || 0
};
cc.kmVec3Fill = function(t, e, i, n) {
	if (!t) return new cc.kmVec3(e, i, n);
	t.x = e;
	t.y = i;
	t.z = n;
	return t
};
cc.kmVec3Length = function(t) {
	return Math.sqrt(cc.kmSQR(t.x) + cc.kmSQR(t.y) + cc.kmSQR(t.z))
};
cc.kmVec3LengthSq = function(t) {
	return cc.kmSQR(t.x) + cc.kmSQR(t.y) + cc.kmSQR(t.z)
};
cc.kmVec3Normalize = function(t, e) {
	var i = 1 / cc.kmVec3Length(e);
	t.x = e.x * i;
	t.y = e.y * i;
	t.z = e.z * i;
	return t
};
cc.kmVec3Cross = function(t, e, i) {
	t.x = e.y * i.z - e.z * i.y;
	t.y = e.z * i.x - e.x * i.z;
	t.z = e.x * i.y - e.y * i.x;
	return t
};
cc.kmVec3Dot = function(t, e) {
	return t.x * e.x + t.y * e.y + t.z * e.z
};
cc.kmVec3Add = function(t, e, i) {
	t.x = e.x + i.x;
	t.y = e.y + i.y;
	t.z = e.z + i.z;
	return t
};
cc.kmVec3Subtract = function(t, e, i) {
	t.x = e.x - i.x;
	t.y = e.y - i.y;
	t.z = e.z - i.z;
	return t
};
cc.kmVec3Transform = function(t, e, i) {
	t.x = e.x * i.mat[0] + e.y * i.mat[4] + e.z * i.mat[8] + i.mat[12];
	t.y = e.x * i.mat[1] + e.y * i.mat[5] + e.z * i.mat[9] + i.mat[13];
	t.z = e.x * i.mat[2] + e.y * i.mat[6] + e.z * i.mat[10] + i.mat[14];
	return t
};
cc.kmVec3TransformNormal = function(t, e, i) {
	t.x = e.x * i.mat[0] + e.y * i.mat[4] + e.z * i.mat[8];
	t.y = e.x * i.mat[1] + e.y * i.mat[5] + e.z * i.mat[9];
	t.z = e.x * i.mat[2] + e.y * i.mat[6] + e.z * i.mat[10];
	return t
};
cc.kmVec3TransformCoord = function(t, e, i) {
	var n = new cc.kmVec4,
		r = new cc.kmVec4;
	cc.kmVec4Fill(r, e.x, e.y, e.z, 1);
	cc.kmVec4Transform(n, r, i);
	t.x = n.x / n.w;
	t.y = n.y / n.w;
	t.z = n.z / n.w;
	return t
};
cc.kmVec3Scale = function(t, e, i) {
	t.x = e.x * i;
	t.y = e.y * i;
	t.z = e.z * i;
	return t
};
cc.kmVec3AreEqual = function(t, e) {
	return t.x < e.x + cc.kmEpsilon && t.x > e.x - cc.kmEpsilon && t.y < e.y + cc.kmEpsilon && t.y > e.y - cc.kmEpsilon && t.z < e.z + cc.kmEpsilon && t.z > e.z - cc.kmEpsilon ? 1 : 0
};
cc.kmVec3InverseTransform = function(t, e, i) {
	e = new cc.kmVec3(e.x - i.mat[12], e.y - i.mat[13], e.z - i.mat[14]);
	t.x = e.x * i.mat[0] + e.y * i.mat[1] + e.z * i.mat[2];
	t.y = e.x * i.mat[4] + e.y * i.mat[5] + e.z * i.mat[6];
	t.z = e.x * i.mat[8] + e.y * i.mat[9] + e.z * i.mat[10];
	return t
};
cc.kmVec3InverseTransformNormal = function(t, e, i) {
	t.x = e.x * i.mat[0] + e.y * i.mat[1] + e.z * i.mat[2];
	t.y = e.x * i.mat[4] + e.y * i.mat[5] + e.z * i.mat[6];
	t.z = e.x * i.mat[8] + e.y * i.mat[9] + e.z * i.mat[10];
	return t
};
cc.kmVec3Assign = function(t, e) {
	if (t == e) return t;
	t.x = e.x;
	t.y = e.y;
	t.z = e.z;
	return t
};
cc.kmVec3Zero = function(t) {
	t.x = 0;
	t.y = 0;
	t.z = 0;
	return t
};
cc.kmVec3ToTypeArray = function(t) {
	if (!t) return null;
	var e = new Float32Array(3);
	e[0] = t.x;
	e[1] = t.y;
	e[2] = t.z;
	return e
};
cc.kmVec4 = function(t, e, i, n) {
	this.x = t || 0;
	this.y = e || 0;
	this.z = i || 0;
	this.w = n || 0
};
cc.kmVec4Fill = function(t, e, i, n, r) {
	t.x = e;
	t.y = i;
	t.z = n;
	t.w = r;
	return t
};
cc.kmVec4Add = function(t, e, i) {
	t.x = e.x + i.x;
	t.y = e.y + i.y;
	t.z = e.z + i.z;
	t.w = e.w + i.w;
	return t
};
cc.kmVec4Dot = function(t, e) {
	return t.x * e.x + t.y * e.y + t.z * e.z + t.w * e.w
};
cc.kmVec4Length = function(t) {
	return Math.sqrt(cc.kmSQR(t.x) + cc.kmSQR(t.y) + cc.kmSQR(t.z) + cc.kmSQR(t.w))
};
cc.kmVec4LengthSq = function(t) {
	return cc.kmSQR(t.x) + cc.kmSQR(t.y) + cc.kmSQR(t.z) + cc.kmSQR(t.w)
};
cc.kmVec4Lerp = function(t, e, i, n) {
	return t
};
cc.kmVec4Normalize = function(t, e) {
	var i = 1 / cc.kmVec4Length(e);
	t.x *= i;
	t.y *= i;
	t.z *= i;
	t.w *= i;
	return t
};
cc.kmVec4Scale = function(t, e, i) {
	cc.kmVec4Normalize(t, e);
	t.x *= i;
	t.y *= i;
	t.z *= i;
	t.w *= i;
	return t
};
cc.kmVec4Subtract = function(t, e, i) {
	t.x = e.x - i.x;
	t.y = e.y - i.y;
	t.z = e.z - i.z;
	t.w = e.w - i.w;
	return t
};
cc.kmVec4Transform = function(t, e, i) {
	t.x = e.x * i.mat[0] + e.y * i.mat[4] + e.z * i.mat[8] + e.w * i.mat[12];
	t.y = e.x * i.mat[1] + e.y * i.mat[5] + e.z * i.mat[9] + e.w * i.mat[13];
	t.z = e.x * i.mat[2] + e.y * i.mat[6] + e.z * i.mat[10] + e.w * i.mat[14];
	t.w = e.x * i.mat[3] + e.y * i.mat[7] + e.z * i.mat[11] + e.w * i.mat[15];
	return t
};
cc.kmVec4TransformArray = function(t, e, i, n, r, c) {
	for (var s = 0; s < c;) cc.kmVec4Transform(t + s * e, i + s * n, r), ++s;
	return t
};
cc.kmVec4AreEqual = function(t, e) {
	return t.x < e.x + cc.kmEpsilon && t.x > e.x - cc.kmEpsilon && t.y < e.y + cc.kmEpsilon && t.y > e.y - cc.kmEpsilon && t.z < e.z + cc.kmEpsilon && t.z > e.z - cc.kmEpsilon && t.w < e.w + cc.kmEpsilon && t.w > e.w - cc.kmEpsilon
};
cc.kmVec4Assign = function(t, e) {
	if (t == e) return cc.log("destVec and srcVec are same object"), t;
	t.x = e.x;
	t.y = e.y;
	t.z = e.z;
	t.w = e.w;
	return t
};
cc.kmVec4ToTypeArray = function(t) {
	if (!t) return null;
	var e = new Float32Array(4);
	e[0] = t.x;
	e[1] = t.y;
	e[2] = t.z;
	e[3] = t.w;
	return e
};
cc.kmRay2 = function(t, e) {
	this.start = t || new cc.kmVec2;
	this.start = t || new cc.kmVec2
};
cc.kmRay2Fill = function(t, e, i, n, r) {
	t.start.x = e;
	t.start.y = i;
	t.dir.x = n;
	t.dir.y = r
};
cc.kmRay2IntersectLineSegment = function(t, e, i, n) {
	var r = t.start.x,
		c = t.start.y,
		s = t.start.x + t.dir.x;
	t = t.start.y + t.dir.y;
	var o = e.x,
		a = e.y,
		h = i.x,
		l = i.y,
		u = (l - a) * (s - r) - (h - o) * (t - c);
	if (u > -cc.kmEpsilon && u < cc.kmEpsilon) return cc.KM_FALSE;
	a = ((h - o) * (c - a) - (l - a) * (r - o)) / u;
	o = r + a * (s - r);
	a = c + a * (t - c);
	if (o < cc.kmMin(e.x, i.x) - cc.kmEpsilon || o > cc.kmMax(e.x, i.x) + cc.kmEpsilon || a < cc.kmMin(e.y, i.y) - cc.kmEpsilon || a > cc.kmMax(e.y, i.y) + cc.kmEpsilon || o < cc.kmMin(r, s) - cc.kmEpsilon || o > cc.kmMax(r, s) + cc.kmEpsilon || a < cc.kmMin(c, t) - cc.kmEpsilon || a > cc.kmMax(c, t) + cc.kmEpsilon) return cc.KM_FALSE;
	n.x = o;
	n.y = a;
	return cc.KM_TRUE
};
cc.calculate_line_normal = function(t, e, i) {
	var n = new cc.kmVec2;
	cc.kmVec2Subtract(n, e, t);
	i.x = -n.y;
	i.y = n.x;
	cc.kmVec2Normalize(i, i)
};
cc.kmRay2IntersectTriangle = function(t, e, i, n, r, c) {
	var s = new cc.kmVec2,
		o = new cc.kmVec2,
		a = new cc.kmVec2,
		h = 1e4,
		l = cc.KM_FALSE,
		u;
	cc.kmRay2IntersectLineSegment(t, e, i, s) && (u = new cc.kmVec2, l = cc.KM_TRUE, u = cc.kmVec2Length(cc.kmVec2Subtract(u, s, t.start)), u < h && (o.x = s.x, o.y = s.y, h = u, cc.calculate_line_normal(e, i, a)));
	cc.kmRay2IntersectLineSegment(t, i, n, s) && (u = new cc.kmVec2, l = cc.KM_TRUE, u = cc.kmVec2Length(cc.kmVec2Subtract(u, s, t.start)), u < h && (o.x = s.x, o.y = s.y, h = u, cc.calculate_line_normal(i, n, a)));
	cc.kmRay2IntersectLineSegment(t, n, e, s) && (u = new cc.kmVec2, l = cc.KM_TRUE, u = cc.kmVec2Length(cc.kmVec2Subtract(u, s, t.start)), u < h && (o.x = s.x, o.y = s.y, cc.calculate_line_normal(n, e, a)));
	l && (r.x = o.x, r.y = o.y, c && (c.x = a.x, c.y = a.y));
	return l
};
cc.kmRay2IntersectCircle = function(t, e, i, n) {
	cc.log("cc.kmRay2IntersectCircle() has not been implemented.")
};
var Float32Array = Float32Array || Array;
cc.kmMat3 = function() {
	this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat3Fill = function(t, e) {
	for (var i = 0; 9 > i; i++) t.mat[i] = e;
	return t
};
cc.kmMat3Adjugate = function(t, e) {
	t.mat[0] = e.mat[4] * e.mat[8] - e.mat[5] * e.mat[7];
	t.mat[1] = e.mat[2] * e.mat[7] - e.mat[1] * e.mat[8];
	t.mat[2] = e.mat[1] * e.mat[5] - e.mat[2] * e.mat[4];
	t.mat[3] = e.mat[5] * e.mat[6] - e.mat[3] * e.mat[8];
	t.mat[4] = e.mat[0] * e.mat[8] - e.mat[2] * e.mat[6];
	t.mat[5] = e.mat[2] * e.mat[3] - e.mat[0] * e.mat[5];
	t.mat[6] = e.mat[3] * e.mat[7] - e.mat[4] * e.mat[6];
	t.mat[8] = e.mat[0] * e.mat[4] - e.mat[1] * e.mat[3];
	return t
};
cc.kmMat3Identity = function(t) {
	t.mat[1] = t.mat[2] = t.mat[3] = t.mat[5] = t.mat[6] = t.mat[7] = 0;
	t.mat[0] = t.mat[4] = t.mat[8] = 1;
	return t
};
cc.kmMat3Inverse = function(t, e, i) {
	var n = new cc.kmMat3;
	if (0 === e) return null;
	e = 1 / e;
	cc.kmMat3Adjugate(n, i);
	cc.kmMat3ScalarMultiply(t, n, e);
	return t
};
cc.kmMat3._identity = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
cc.kmMat3IsIdentity = function(t) {
	for (var e = 0; 9 > e; e++) if (cc.kmMat3._identity[e] !== t.mat[e]) return !1;
	return !0
};
cc.kmMat3Transpose = function(t, e) {
	var i, n;
	for (i = 0; 3 > i; ++i) for (n = 0; 3 > n; ++n) t.mat[3 * i + n] = e.mat[3 * n + i];
	return t
};
cc.kmMat3Determinant = function(t) {
	var e;
	e = t.mat[0] * t.mat[4] * t.mat[8] + t.mat[1] * t.mat[5] * t.mat[6] + t.mat[2] * t.mat[3] * t.mat[7];
	return e -= t.mat[2] * t.mat[4] * t.mat[6] + t.mat[0] * t.mat[5] * t.mat[7] + t.mat[1] * t.mat[3] * t.mat[8]
};
cc.kmMat3Multiply = function(t, e, i) {
	e = e.mat;
	i = i.mat;
	t.mat[0] = e[0] * i[0] + e[3] * i[1] + e[6] * i[2];
	t.mat[1] = e[1] * i[0] + e[4] * i[1] + e[7] * i[2];
	t.mat[2] = e[2] * i[0] + e[5] * i[1] + e[8] * i[2];
	t.mat[3] = e[0] * i[3] + e[3] * i[4] + e[6] * i[5];
	t.mat[4] = e[1] * i[3] + e[4] * i[4] + e[7] * i[5];
	t.mat[5] = e[2] * i[3] + e[5] * i[4] + e[8] * i[5];
	t.mat[6] = e[0] * i[6] + e[3] * i[7] + e[6] * i[8];
	t.mat[7] = e[1] * i[6] + e[4] * i[7] + e[7] * i[8];
	t.mat[8] = e[2] * i[6] + e[5] * i[7] + e[8] * i[8];
	return t
};
cc.kmMat3ScalarMultiply = function(t, e, i) {
	for (var n = 0; 9 > n; n++) t.mat[n] = e.mat[n] * i;
	return t
};
cc.kmMat3RotationAxisAngle = function(t, e, i) {
	var n = Math.cos(i);
	i = Math.sin(i);
	t.mat[0] = n + e.x * e.x * (1 - n);
	t.mat[1] = e.z * i + e.y * e.x * (1 - n);
	t.mat[2] = -e.y * i + e.z * e.x * (1 - n);
	t.mat[3] = -e.z * i + e.x * e.y * (1 - n);
	t.mat[4] = n + e.y * e.y * (1 - n);
	t.mat[5] = e.x * i + e.z * e.y * (1 - n);
	t.mat[6] = e.y * i + e.x * e.z * (1 - n);
	t.mat[7] = -e.x * i + e.y * e.z * (1 - n);
	t.mat[8] = n + e.z * e.z * (1 - n);
	return t
};
cc.kmMat3Assign = function(t, e) {
	if (t == e) return cc.log("cc.kmMat3Assign(): pOut equals pIn"), t;
	for (var i = 0; 9 > i; i++) t.mat[i] = e.mat[i];
	return t
};
cc.kmMat3AreEqual = function(t, e) {
	if (t == e) return !0;
	for (var i = 0; 9 > i; ++i) if (!(t.mat[i] + cc.kmEpsilon > e.mat[i] && t.mat[i] - cc.kmEpsilon < e.mat[i])) return !1;
	return !0
};
cc.kmMat3RotationX = function(t, e) {
	t.mat[0] = 1;
	t.mat[1] = 0;
	t.mat[2] = 0;
	t.mat[3] = 0;
	t.mat[4] = Math.cos(e);
	t.mat[5] = Math.sin(e);
	t.mat[6] = 0;
	t.mat[7] = -Math.sin(e);
	t.mat[8] = Math.cos(e);
	return t
};
cc.kmMat3RotationY = function(t, e) {
	t.mat[0] = Math.cos(e);
	t.mat[1] = 0;
	t.mat[2] = -Math.sin(e);
	t.mat[3] = 0;
	t.mat[4] = 1;
	t.mat[5] = 0;
	t.mat[6] = Math.sin(e);
	t.mat[7] = 0;
	t.mat[8] = Math.cos(e);
	return t
};
cc.kmMat3RotationZ = function(t, e) {
	t.mat[0] = Math.cos(e);
	t.mat[1] = -Math.sin(e);
	t.mat[2] = 0;
	t.mat[3] = Math.sin(e);
	t.mat[4] = Math.cos(e);
	t.mat[5] = 0;
	t.mat[6] = 0;
	t.mat[7] = 0;
	t.mat[8] = 1;
	return t
};
cc.kmMat3Rotation = function(t, e) {
	t.mat[0] = Math.cos(e);
	t.mat[1] = Math.sin(e);
	t.mat[2] = 0;
	t.mat[3] = -Math.sin(e);
	t.mat[4] = Math.cos(e);
	t.mat[5] = 0;
	t.mat[6] = 0;
	t.mat[7] = 0;
	t.mat[8] = 1;
	return t
};
cc.kmMat3Scaling = function(t, e, i) {
	cc.kmMat3Identity(t);
	t.mat[0] = e;
	t.mat[4] = i;
	return t
};
cc.kmMat3Translation = function(t, e, i) {
	cc.kmMat3Identity(t);
	t.mat[6] = e;
	t.mat[7] = i;
	return t
};
cc.kmMat3RotationQuaternion = function(t, e) {
	if (!e || !t) return null;
	t.mat[0] = 1 - 2 * (e.y * e.y + e.z * e.z);
	t.mat[1] = 2 * (e.x * e.y - e.w * e.z);
	t.mat[2] = 2 * (e.x * e.z + e.w * e.y);
	t.mat[3] = 2 * (e.x * e.y + e.w * e.z);
	t.mat[4] = 1 - 2 * (e.x * e.x + e.z * e.z);
	t.mat[5] = 2 * (e.y * e.z - e.w * e.x);
	t.mat[6] = 2 * (e.x * e.z - e.w * e.y);
	t.mat[7] = 2 * (e.y * e.z + e.w * e.x);
	t.mat[8] = 1 - 2 * (e.x * e.x + e.y * e.y);
	return t
};
cc.kmMat3RotationToAxisAngle = function(t, e, i) {
	cc.kmQuaternionRotationMatrix(void 0, i);
	cc.kmQuaternionToAxisAngle(void 0, t, e);
	return t
};
cc.kmMat4 = function() {
	this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat4Fill = function(t, e) {
	t.mat[0] = t.mat[1] = t.mat[2] = t.mat[3] = t.mat[4] = t.mat[5] = t.mat[6] = t.mat[7] = t.mat[8] = t.mat[9] = t.mat[10] = t.mat[11] = t.mat[12] = t.mat[13] = t.mat[14] = t.mat[15] = e
};
cc.kmMat4Identity = function(t) {
	t.mat[1] = t.mat[2] = t.mat[3] = t.mat[4] = t.mat[6] = t.mat[7] = t.mat[8] = t.mat[9] = t.mat[11] = t.mat[12] = t.mat[13] = t.mat[14] = 0;
	t.mat[0] = t.mat[5] = t.mat[10] = t.mat[15] = 1;
	return t
};
cc.kmMat4._get = function(t, e, i) {
	return t.mat[e + 4 * i]
};
cc.kmMat4._set = function(t, e, i, n) {
	t.mat[e + 4 * i] = n
};
cc.kmMat4._swap = function(t, e, i, n, r) {
	var c = cc.kmMat4._get(t, e, i);
	cc.kmMat4._set(t, e, i, cc.kmMat4._get(t, n, r));
	cc.kmMat4._set(t, n, r, c)
};
cc.kmMat4._gaussj = function(t, e) {
	var i, n = 0,
		r = 0,
		c, s, o, a = [0, 0, 0, 0],
		h = [0, 0, 0, 0],
		l = [0, 0, 0, 0];
	for (i = 0; 4 > i; i++) {
		for (c = o = 0; 4 > c; c++) if (1 != l[c]) for (s = 0; 4 > s; s++) 0 == l[s] && Math.abs(cc.kmMat4._get(t, c, s)) >= o && (o = Math.abs(cc.kmMat4._get(t, c, s)), r = c, n = s);
		++l[n];
		if (r != n) {
			for (c = 0; 4 > c; c++) cc.kmMat4._swap(t, r, c, n, c);
			for (c = 0; 4 > c; c++) cc.kmMat4._swap(e, r, c, n, c)
		}
		h[i] = r;
		a[i] = n;
		if (0 == cc.kmMat4._get(t, n, n)) return cc.KM_FALSE;
		s = 1 / cc.kmMat4._get(t, n, n);
		cc.kmMat4._set(t, n, n, 1);
		for (c = 0; 4 > c; c++) cc.kmMat4._set(t, n, c, cc.kmMat4._get(t, n, c) * s);
		for (c = 0; 4 > c; c++) cc.kmMat4._set(e, n, c, cc.kmMat4._get(e, n, c) * s);
		for (s = 0; 4 > s; s++) if (s != n) {
			o = cc.kmMat4._get(t, s, n);
			cc.kmMat4._set(t, s, n, 0);
			for (c = 0; 4 > c; c++) cc.kmMat4._set(t, s, c, cc.kmMat4._get(t, s, c) - cc.kmMat4._get(t, n, c) * o);
			for (c = 0; 4 > c; c++) cc.kmMat4._set(e, s, c, cc.kmMat4._get(t, s, c) - cc.kmMat4._get(e, n, c) * o)
		}
	}
	for (c = 3; 0 <= c; c--) if (h[c] != a[c]) for (s = 0; 4 > s; s++) cc.kmMat4._swap(t, s, h[c], s, a[c]);
	return cc.KM_TRUE
};
cc.kmMat4._identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
cc.kmMat4Inverse = function(t, e) {
	var i = new cc.kmMat4,
		n = new cc.kmMat4;
	cc.kmMat4Assign(i, e);
	cc.kmMat4Identity(n);
	if (cc.kmMat4._gaussj(i, n) == cc.KM_FALSE) return null;
	cc.kmMat4Assign(t, i);
	return t
};
cc.kmMat4IsIdentity = function(t) {
	for (var e = 0; 16 > e; e++) if (cc.kmMat4._identity[e] != t.mat[e]) return !1;
	return !0
};
cc.kmMat4Transpose = function(t, e) {
	var i, n, r = t.mat,
		c = e.mat;
	for (n = 0; 4 > n; ++n) for (i = 0; 4 > i; ++i) r[4 * n + i] = c[4 * i + n];
	return t
};
cc.kmMat4Multiply = function(t, e, i) {
	var n = t.mat,
		r = e.mat[0],
		c = e.mat[1],
		s = e.mat[2],
		o = e.mat[3],
		a = e.mat[4],
		h = e.mat[5],
		l = e.mat[6],
		u = e.mat[7],
		d = e.mat[8],
		_ = e.mat[9],
		f = e.mat[10],
		p = e.mat[11],
		g = e.mat[12],
		m = e.mat[13],
		T = e.mat[14];
	e = e.mat[15];
	var y = i.mat[0],
		v = i.mat[1],
		A = i.mat[2],
		x = i.mat[3],
		E = i.mat[4],
		S = i.mat[5],
		C = i.mat[6],
		R = i.mat[7],
		b = i.mat[8],
		I = i.mat[9],
		P = i.mat[10],
		w = i.mat[11],
		F = i.mat[12],
		L = i.mat[13],
		O = i.mat[14];
	i = i.mat[15];
	n[0] = y * r + v * a + A * d + x * g;
	n[1] = y * c + v * h + A * _ + x * m;
	n[2] = y * s + v * l + A * f + x * T;
	n[3] = y * o + v * u + A * p + x * e;
	n[4] = E * r + S * a + C * d + R * g;
	n[5] = E * c + S * h + C * _ + R * m;
	n[6] = E * s + S * l + C * f + R * T;
	n[7] = E * o + S * u + C * p + R * e;
	n[8] = b * r + I * a + P * d + w * g;
	n[9] = b * c + I * h + P * _ + w * m;
	n[10] = b * s + I * l + P * f + w * T;
	n[11] = b * o + I * u + P * p + w * e;
	n[12] = F * r + L * a + O * d + i * g;
	n[13] = F * c + L * h + O * _ + i * m;
	n[14] = F * s + L * l + O * f + i * T;
	n[15] = F * o + L * u + O * p + i * e;
	return t
};
cc.getMat4MultiplyValue = function(t, e) {
	var i = t.mat,
		n = e.mat,
		r = new Float32Array(16);
	r[0] = i[0] * n[0] + i[4] * n[1] + i[8] * n[2] + i[12] * n[3];
	r[1] = i[1] * n[0] + i[5] * n[1] + i[9] * n[2] + i[13] * n[3];
	r[2] = i[2] * n[0] + i[6] * n[1] + i[10] * n[2] + i[14] * n[3];
	r[3] = i[3] * n[0] + i[7] * n[1] + i[11] * n[2] + i[15] * n[3];
	r[4] = i[0] * n[4] + i[4] * n[5] + i[8] * n[6] + i[12] * n[7];
	r[5] = i[1] * n[4] + i[5] * n[5] + i[9] * n[6] + i[13] * n[7];
	r[6] = i[2] * n[4] + i[6] * n[5] + i[10] * n[6] + i[14] * n[7];
	r[7] = i[3] * n[4] + i[7] * n[5] + i[11] * n[6] + i[15] * n[7];
	r[8] = i[0] * n[8] + i[4] * n[9] + i[8] * n[10] + i[12] * n[11];
	r[9] = i[1] * n[8] + i[5] * n[9] + i[9] * n[10] + i[13] * n[11];
	r[10] = i[2] * n[8] + i[6] * n[9] + i[10] * n[10] + i[14] * n[11];
	r[11] = i[3] * n[8] + i[7] * n[9] + i[11] * n[10] + i[15] * n[11];
	r[12] = i[0] * n[12] + i[4] * n[13] + i[8] * n[14] + i[12] * n[15];
	r[13] = i[1] * n[12] + i[5] * n[13] + i[9] * n[14] + i[13] * n[15];
	r[14] = i[2] * n[12] + i[6] * n[13] + i[10] * n[14] + i[14] * n[15];
	r[15] = i[3] * n[12] + i[7] * n[13] + i[11] * n[14] + i[15] * n[15];
	return r
};
cc.getMat4MultiplyWithMat4 = function(t, e, i) {
	t = t.mat;
	e = e.mat;
	var n = i.mat;
	n[0] = t[0] * e[0] + t[4] * e[1] + t[8] * e[2] + t[12] * e[3];
	n[1] = t[1] * e[0] + t[5] * e[1] + t[9] * e[2] + t[13] * e[3];
	n[2] = t[2] * e[0] + t[6] * e[1] + t[10] * e[2] + t[14] * e[3];
	n[3] = t[3] * e[0] + t[7] * e[1] + t[11] * e[2] + t[15] * e[3];
	n[4] = t[0] * e[4] + t[4] * e[5] + t[8] * e[6] + t[12] * e[7];
	n[5] = t[1] * e[4] + t[5] * e[5] + t[9] * e[6] + t[13] * e[7];
	n[6] = t[2] * e[4] + t[6] * e[5] + t[10] * e[6] + t[14] * e[7];
	n[7] = t[3] * e[4] + t[7] * e[5] + t[11] * e[6] + t[15] * e[7];
	n[8] = t[0] * e[8] + t[4] * e[9] + t[8] * e[10] + t[12] * e[11];
	n[9] = t[1] * e[8] + t[5] * e[9] + t[9] * e[10] + t[13] * e[11];
	n[10] = t[2] * e[8] + t[6] * e[9] + t[10] * e[10] + t[14] * e[11];
	n[11] = t[3] * e[8] + t[7] * e[9] + t[11] * e[10] + t[15] * e[11];
	n[12] = t[0] * e[12] + t[4] * e[13] + t[8] * e[14] + t[12] * e[15];
	n[13] = t[1] * e[12] + t[5] * e[13] + t[9] * e[14] + t[13] * e[15];
	n[14] = t[2] * e[12] + t[6] * e[13] + t[10] * e[14] + t[14] * e[15];
	n[15] = t[3] * e[12] + t[7] * e[13] + t[11] * e[14] + t[15] * e[15];
	return i.mat
};
cc.kmMat4Assign = function(t, e) {
	if (t == e) return cc.log("cc.kmMat4Assign(): pOut equals pIn"), t;
	var i = t.mat,
		n = e.mat;
	i[0] = n[0];
	i[1] = n[1];
	i[2] = n[2];
	i[3] = n[3];
	i[4] = n[4];
	i[5] = n[5];
	i[6] = n[6];
	i[7] = n[7];
	i[8] = n[8];
	i[9] = n[9];
	i[10] = n[10];
	i[11] = n[11];
	i[12] = n[12];
	i[13] = n[13];
	i[14] = n[14];
	i[15] = n[15];
	return t
};
cc.kmMat4AreEqual = function(t, e) {
	if (t == e) return cc.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
	for (var i = 0; 16 > i; i++) if (!(t.mat[i] + cc.kmEpsilon > e.mat[i] && t.mat[i] - cc.kmEpsilon < e.mat[i])) return !1;
	return !0
};
cc.kmMat4RotationX = function(t, e) {
	t.mat[0] = 1;
	t.mat[1] = 0;
	t.mat[2] = 0;
	t.mat[3] = 0;
	t.mat[4] = 0;
	t.mat[5] = Math.cos(e);
	t.mat[6] = Math.sin(e);
	t.mat[7] = 0;
	t.mat[8] = 0;
	t.mat[9] = -Math.sin(e);
	t.mat[10] = Math.cos(e);
	t.mat[11] = 0;
	t.mat[12] = 0;
	t.mat[13] = 0;
	t.mat[14] = 0;
	t.mat[15] = 1;
	return t
};
cc.kmMat4RotationY = function(t, e) {
	t.mat[0] = Math.cos(e);
	t.mat[1] = 0;
	t.mat[2] = -Math.sin(e);
	t.mat[3] = 0;
	t.mat[4] = 0;
	t.mat[5] = 1;
	t.mat[6] = 0;
	t.mat[7] = 0;
	t.mat[8] = Math.sin(e);
	t.mat[9] = 0;
	t.mat[10] = Math.cos(e);
	t.mat[11] = 0;
	t.mat[12] = 0;
	t.mat[13] = 0;
	t.mat[14] = 0;
	t.mat[15] = 1;
	return t
};
cc.kmMat4RotationZ = function(t, e) {
	t.mat[0] = Math.cos(e);
	t.mat[1] = Math.sin(e);
	t.mat[2] = 0;
	t.mat[3] = 0;
	t.mat[4] = -Math.sin(e);
	t.mat[5] = Math.cos(e);
	t.mat[6] = 0;
	t.mat[7] = 0;
	t.mat[8] = 0;
	t.mat[9] = 0;
	t.mat[10] = 1;
	t.mat[11] = 0;
	t.mat[12] = 0;
	t.mat[13] = 0;
	t.mat[14] = 0;
	t.mat[15] = 1;
	return t
};
cc.kmMat4RotationPitchYawRoll = function(t, e, i, n) {
	var r = Math.cos(e);
	e = Math.sin(e);
	var c = Math.cos(i);
	i = Math.sin(i);
	var s = Math.cos(n);
	n = Math.sin(n);
	var o = e * i,
		a = r * i;
	t.mat[0] = c * s;
	t.mat[4] = c * n;
	t.mat[8] = -i;
	t.mat[1] = o * s - r * n;
	t.mat[5] = o * n + r * s;
	t.mat[9] = e * c;
	t.mat[2] = a * s + e * n;
	t.mat[6] = a * n - e * s;
	t.mat[10] = r * c;
	t.mat[3] = t.mat[7] = t.mat[11] = 0;
	t.mat[15] = 1;
	return t
};
cc.kmMat4RotationQuaternion = function(t, e) {
	t.mat[0] = 1 - 2 * (e.y * e.y + e.z * e.z);
	t.mat[1] = 2 * (e.x * e.y + e.z * e.w);
	t.mat[2] = 2 * (e.x * e.z - e.y * e.w);
	t.mat[3] = 0;
	t.mat[4] = 2 * (e.x * e.y - e.z * e.w);
	t.mat[5] = 1 - 2 * (e.x * e.x + e.z * e.z);
	t.mat[6] = 2 * (e.z * e.y + e.x * e.w);
	t.mat[7] = 0;
	t.mat[8] = 2 * (e.x * e.z + e.y * e.w);
	t.mat[9] = 2 * (e.y * e.z - e.x * e.w);
	t.mat[10] = 1 - 2 * (e.x * e.x + e.y * e.y);
	t.mat[11] = 0;
	t.mat[12] = 0;
	t.mat[13] = 0;
	t.mat[14] = 0;
	t.mat[15] = 1;
	return t
};
cc.kmMat4RotationTranslation = function(t, e, i) {
	t.mat[0] = e.mat[0];
	t.mat[1] = e.mat[1];
	t.mat[2] = e.mat[2];
	t.mat[3] = 0;
	t.mat[4] = e.mat[3];
	t.mat[5] = e.mat[4];
	t.mat[6] = e.mat[5];
	t.mat[7] = 0;
	t.mat[8] = e.mat[6];
	t.mat[9] = e.mat[7];
	t.mat[10] = e.mat[8];
	t.mat[11] = 0;
	t.mat[12] = i.x;
	t.mat[13] = i.y;
	t.mat[14] = i.z;
	t.mat[15] = 1;
	return t
};
cc.kmMat4Scaling = function(t, e, i, n) {
	t.mat[0] = e;
	t.mat[5] = i;
	t.mat[10] = n;
	t.mat[15] = 1;
	t.mat[1] = t.mat[2] = t.mat[3] = t.mat[4] = t.mat[6] = t.mat[7] = t.mat[8] = t.mat[9] = t.mat[11] = t.mat[12] = t.mat[13] = t.mat[14] = 0;
	return t
};
cc.kmMat4Translation = function(t, e, i, n) {
	t.mat[0] = t.mat[5] = t.mat[10] = t.mat[15] = 1;
	t.mat[1] = t.mat[2] = t.mat[3] = t.mat[4] = t.mat[6] = t.mat[7] = t.mat[8] = t.mat[9] = t.mat[11] = 0;
	t.mat[12] = e;
	t.mat[13] = i;
	t.mat[14] = n;
	return t
};
cc.kmMat4GetUpVec3 = function(t, e) {
	t.x = e.mat[4];
	t.y = e.mat[5];
	t.z = e.mat[6];
	cc.kmVec3Normalize(t, t);
	return t
};
cc.kmMat4GetRightVec3 = function(t, e) {
	t.x = e.mat[0];
	t.y = e.mat[1];
	t.z = e.mat[2];
	cc.kmVec3Normalize(t, t);
	return t
};
cc.kmMat4GetForwardVec3 = function(t, e) {
	t.x = e.mat[8];
	t.y = e.mat[9];
	t.z = e.mat[10];
	cc.kmVec3Normalize(t, t);
	return t
};
cc.kmMat4PerspectiveProjection = function(t, e, i, n, r) {
	var c = cc.kmDegreesToRadians(e / 2);
	e = r - n;
	var s = Math.sin(c);
	if (0 == e || 0 == s || 0 == i) return null;
	c = Math.cos(c) / s;
	cc.kmMat4Identity(t);
	t.mat[0] = c / i;
	t.mat[5] = c;
	t.mat[10] = -(r + n) / e;
	t.mat[11] = -1;
	t.mat[14] = -2 * n * r / e;
	t.mat[15] = 0;
	return t
};
cc.kmMat4OrthographicProjection = function(t, e, i, n, r, c, s) {
	cc.kmMat4Identity(t);
	t.mat[0] = 2 / (i - e);
	t.mat[5] = 2 / (r - n);
	t.mat[10] = -2 / (s - c);
	t.mat[12] = -((i + e) / (i - e));
	t.mat[13] = -((r + n) / (r - n));
	t.mat[14] = -((s + c) / (s - c));
	return t
};
cc.kmMat4LookAt = function(t, e, i, n) {
	var r = new cc.kmVec3,
		c = new cc.kmVec3,
		s = new cc.kmVec3,
		o = new cc.kmVec3,
		a = new cc.kmMat4;
	cc.kmVec3Subtract(r, i, e);
	cc.kmVec3Normalize(r, r);
	cc.kmVec3Assign(c, n);
	cc.kmVec3Normalize(c, c);
	cc.kmVec3Cross(s, r, c);
	cc.kmVec3Normalize(s, s);
	cc.kmVec3Cross(o, s, r);
	cc.kmVec3Normalize(s, s);
	cc.kmMat4Identity(t);
	t.mat[0] = s.x;
	t.mat[4] = s.y;
	t.mat[8] = s.z;
	t.mat[1] = o.x;
	t.mat[5] = o.y;
	t.mat[9] = o.z;
	t.mat[2] = -r.x;
	t.mat[6] = -r.y;
	t.mat[10] = -r.z;
	cc.kmMat4Translation(a, -e.x, -e.y, -e.z);
	cc.kmMat4Multiply(t, t, a);
	return t
};
cc.kmMat4RotationAxisAngle = function(t, e, i) {
	var n = Math.cos(i);
	i = Math.sin(i);
	var r = new cc.kmVec3;
	cc.kmVec3Normalize(r, e);
	t.mat[0] = n + r.x * r.x * (1 - n);
	t.mat[1] = r.z * i + r.y * r.x * (1 - n);
	t.mat[2] = -r.y * i + r.z * r.x * (1 - n);
	t.mat[3] = 0;
	t.mat[4] = -r.z * i + r.x * r.y * (1 - n);
	t.mat[5] = n + r.y * r.y * (1 - n);
	t.mat[6] = r.x * i + r.z * r.y * (1 - n);
	t.mat[7] = 0;
	t.mat[8] = r.y * i + r.x * r.z * (1 - n);
	t.mat[9] = -r.x * i + r.y * r.z * (1 - n);
	t.mat[10] = n + r.z * r.z * (1 - n);
	t.mat[11] = 0;
	t.mat[12] = 0;
	t.mat[13] = 0;
	t.mat[14] = 0;
	t.mat[15] = 1;
	return t
};
cc.kmMat4ExtractRotation = function(t, e) {
	t.mat[0] = e.mat[0];
	t.mat[1] = e.mat[1];
	t.mat[2] = e.mat[2];
	t.mat[3] = e.mat[4];
	t.mat[4] = e.mat[5];
	t.mat[5] = e.mat[6];
	t.mat[6] = e.mat[8];
	t.mat[7] = e.mat[9];
	t.mat[8] = e.mat[10];
	return t
};
cc.kmMat4ExtractPlane = function(t, e, i) {
	switch (i) {
	case cc.KM_PLANE_RIGHT:
		t.a = e.mat[3] - e.mat[0];
		t.b = e.mat[7] - e.mat[4];
		t.c = e.mat[11] - e.mat[8];
		t.d = e.mat[15] - e.mat[12];
		break;
	case cc.KM_PLANE_LEFT:
		t.a = e.mat[3] + e.mat[0];
		t.b = e.mat[7] + e.mat[4];
		t.c = e.mat[11] + e.mat[8];
		t.d = e.mat[15] + e.mat[12];
		break;
	case cc.KM_PLANE_BOTTOM:
		t.a = e.mat[3] + e.mat[1];
		t.b = e.mat[7] + e.mat[5];
		t.c = e.mat[11] + e.mat[9];
		t.d = e.mat[15] + e.mat[13];
		break;
	case cc.KM_PLANE_TOP:
		t.a = e.mat[3] - e.mat[1];
		t.b = e.mat[7] - e.mat[5];
		t.c = e.mat[11] - e.mat[9];
		t.d = e.mat[15] - e.mat[13];
		break;
	case cc.KM_PLANE_FAR:
		t.a = e.mat[3] - e.mat[2];
		t.b = e.mat[7] - e.mat[6];
		t.c = e.mat[11] - e.mat[10];
		t.d = e.mat[15] - e.mat[14];
		break;
	case cc.KM_PLANE_NEAR:
		t.a = e.mat[3] + e.mat[2];
		t.b = e.mat[7] + e.mat[6];
		t.c = e.mat[11] + e.mat[10];
		t.d = e.mat[15] + e.mat[14];
		break;
	default:
		cc.log("cc.kmMat4ExtractPlane(): Invalid plane index")
	}
	e = Math.sqrt(t.a * t.a + t.b * t.b + t.c * t.c);
	t.a /= e;
	t.b /= e;
	t.c /= e;
	t.d /= e;
	return t
};
cc.kmMat4RotationToAxisAngle = function(t, e, i) {
	var n = new cc.kmQuaternion,
		r = new cc.kmMat3;
	cc.kmMat4ExtractRotation(r, i);
	cc.kmQuaternionRotationMatrix(n, r);
	cc.kmQuaternionToAxisAngle(n, t, e);
	return t
};
cc.KM_PLANE_LEFT = 0;
cc.KM_PLANE_RIGHT = 1;
cc.KM_PLANE_BOTTOM = 2;
cc.KM_PLANE_TOP = 3;
cc.KM_PLANE_NEAR = 4;
cc.KM_PLANE_FAR = 5;
cc.kmPlane = function(t, e, i, n) {
	this.a = t || 0;
	this.b = e || 0;
	this.c = i || 0;
	this.d = n || 0
};
cc.POINT_INFRONT_OF_PLANE = 0;
cc.POINT_BEHIND_PLANE = 1;
cc.POINT_ON_PLANE = 2;
cc.kmPlaneDot = function(t, e) {
	return t.a * e.x + t.b * e.y + t.c * e.z + t.d * e.w
};
cc.kmPlaneDotCoord = function(t, e) {
	return t.a * e.x + t.b * e.y + t.c * e.z + t.d
};
cc.kmPlaneDotNormal = function(t, e) {
	return t.a * e.x + t.b * e.y + t.c * e.z
};
cc.kmPlaneFromPointNormal = function(t, e, i) {
	t.a = i.x;
	t.b = i.y;
	t.c = i.z;
	t.d = -cc.kmVec3Dot(i, e);
	return t
};
cc.kmPlaneFromPoints = function(t, e, i, n) {
	var r = new cc.kmVec3,
		c = new cc.kmVec3,
		s = new cc.kmVec3;
	cc.kmVec3Subtract(c, i, e);
	cc.kmVec3Subtract(s, n, e);
	cc.kmVec3Cross(r, c, s);
	cc.kmVec3Normalize(r, r);
	t.a = r.x;
	t.b = r.y;
	t.c = r.z;
	t.d = cc.kmVec3Dot(cc.kmVec3Scale(r, r, -1), e);
	return t
};
cc.kmPlaneIntersectLine = function(t, e, i, n) {
	throw "cc.kmPlaneIntersectLine() hasn't been implemented."
};
cc.kmPlaneNormalize = function(t, e) {
	var i = new cc.kmVec3;
	i.x = e.a;
	i.y = e.b;
	i.z = e.c;
	var n = 1 / cc.kmVec3Length(i);
	cc.kmVec3Normalize(i, i);
	t.a = i.x;
	t.b = i.y;
	t.c = i.z;
	t.d = e.d * n;
	return t
};
cc.kmPlaneScale = function(t, e, i) {
	cc.log("cc.kmPlaneScale() has not been implemented.")
};
cc.kmPlaneClassifyPoint = function(t, e) {
	var i = t.a * e.x + t.b * e.y + t.c * e.z + t.d;
	return .001 < i ? cc.POINT_INFRONT_OF_PLANE : -.001 > i ? cc.POINT_BEHIND_PLANE : cc.POINT_ON_PLANE
};
cc.kmQuaternion = function(t, e, i, n) {
	this.x = t || 0;
	this.y = e || 0;
	this.z = i || 0;
	this.w = n || 0
};
cc.kmQuaternionConjugate = function(t, e) {
	t.x = -e.x;
	t.y = -e.y;
	t.z = -e.z;
	t.w = e.w;
	return t
};
cc.kmQuaternionDot = function(t, e) {
	return t.w * e.w + t.x * e.x + t.y * e.y + t.z * e.z
};
cc.kmQuaternionExp = function(t, e) {
	return t
};
cc.kmQuaternionIdentity = function(t) {
	t.x = 0;
	t.y = 0;
	t.z = 0;
	t.w = 1;
	return t
};
cc.kmQuaternionInverse = function(t, e) {
	var i = cc.kmQuaternionLength(e),
		n = new cc.kmQuaternion;
	if (Math.abs(i) > cc.kmEpsilon) return t.x = 0, t.y = 0, t.z = 0, t.w = 0, t;
	cc.kmQuaternionScale(t, cc.kmQuaternionConjugate(n, e), 1 / i);
	return t
};
cc.kmQuaternionIsIdentity = function(t) {
	return 0 == t.x && 0 == t.y && 0 == t.z && 1 == t.w
};
cc.kmQuaternionLength = function(t) {
	return Math.sqrt(cc.kmQuaternionLengthSq(t))
};
cc.kmQuaternionLengthSq = function(t) {
	return t.x * t.x + t.y * t.y + t.z * t.z + t.w * t.w
};
cc.kmQuaternionLn = function(t, e) {
	return t
};
cc.kmQuaternionMultiply = function(t, e, i) {
	t.w = e.w * i.w - e.x * i.x - e.y * i.y - e.z * i.z;
	t.x = e.w * i.x + e.x * i.w + e.y * i.z - e.z * i.y;
	t.y = e.w * i.y + e.y * i.w + e.z * i.x - e.x * i.z;
	t.z = e.w * i.z + e.z * i.w + e.x * i.y - e.y * i.x;
	return t
};
cc.kmQuaternionNormalize = function(t, e) {
	var i = cc.kmQuaternionLength(e);
	if (Math.abs(i) <= cc.kmEpsilon) throw "cc.kmQuaternionNormalize(): pIn is an invalid value";
	cc.kmQuaternionScale(t, e, 1 / i);
	return t
};
cc.kmQuaternionRotationAxis = function(t, e, i) {
	i *= .5;
	var n = Math.sin(i);
	t.w = Math.cos(i);
	t.x = e.x * n;
	t.y = e.y * n;
	t.z = e.z * n;
	return t
};
cc.kmQuaternionRotationMatrix = function(t, e) {
	var i, n, r, c;
	i = [];
	n = c = 0;
	if (!e) return null;
	i[0] = e.mat[0];
	i[1] = e.mat[3];
	i[2] = e.mat[6];
	i[4] = e.mat[1];
	i[5] = e.mat[4];
	i[6] = e.mat[7];
	i[8] = e.mat[2];
	i[9] = e.mat[5];
	i[10] = e.mat[8];
	i[15] = 1;
	var s = i[0];
	n = s[0] + s[5] + s[10] + 1;
	n > cc.kmEpsilon ? (c = 2 * Math.sqrt(n), i = (s[9] - s[6]) / c, n = (s[2] - s[8]) / c, r = (s[4] - s[1]) / c, c *= .25) : s[0] > s[5] && s[0] > s[10] ? (c = 2 * Math.sqrt(1 + s[0] - s[5] - s[10]), i = .25 * c, n = (s[4] + s[1]) / c, r = (s[2] + s[8]) / c, c = (s[9] - s[6]) / c) : s[5] > s[10] ? (c = 2 * Math.sqrt(1 + s[5] - s[0] - s[10]), i = (s[4] + s[1]) / c, n = .25 * c, r = (s[9] + s[6]) / c, c = (s[2] - s[8]) / c) : (c = 2 * Math.sqrt(1 + s[10] - s[0] - s[5]), i = (s[2] + s[8]) / c, n = (s[9] + s[6]) / c, r = .25 * c, c = (s[4] - s[1]) / c);
	t.x = i;
	t.y = n;
	t.z = r;
	t.w = c;
	return t
};
cc.kmQuaternionRotationYawPitchRoll = function(t, e, i, n) {
	var r, c, s, o, a;
	r = cc.kmDegreesToRadians(i) / 2;
	c = cc.kmDegreesToRadians(e) / 2;
	s = cc.kmDegreesToRadians(n) / 2;
	n = Math.cos(r);
	e = Math.cos(c);
	i = Math.cos(s);
	r = Math.sin(r);
	c = Math.sin(c);
	s = Math.sin(s);
	o = e * i;
	a = c * s;
	t.w = n * o + r * a;
	t.x = r * o - n * a;
	t.y = n * c * i + r * e * s;
	t.z = n * e * s - r * c * i;
	cc.kmQuaternionNormalize(t, t);
	return t
};
cc.kmQuaternionSlerp = function(t, e, i, n) {
	if (e.x == i.x && e.y == i.y && e.z == i.z && e.w == i.w) return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t;
	var r = cc.kmQuaternionDot(e, i),
		c = Math.acos(r),
		s = Math.sqrt(1 - cc.kmSQR(r)),
		r = Math.sin(n * c) / s;
	n = Math.sin((1 - n) * c) / s;
	c = new cc.kmQuaternion;
	s = new cc.kmQuaternion;
	cc.kmQuaternionScale(c, e, n);
	cc.kmQuaternionScale(s, i, r);
	cc.kmQuaternionAdd(t, c, s);
	return t
};
cc.kmQuaternionToAxisAngle = function(t, e, i) {
	Math.acos(t.w);
	i = Math.sqrt(cc.kmSQR(t.x) + cc.kmSQR(t.y) + cc.kmSQR(t.z));
	i > -cc.kmEpsilon && i < cc.kmEpsilon || i < 2 * cc.kmPI + cc.kmEpsilon && i > 2 * cc.kmPI - cc.kmEpsilon ? (e.x = 0, e.y = 0, e.z = 1) : (e.x = t.x / i, e.y = t.y / i, e.z = t.z / i, cc.kmVec3Normalize(e, e))
};
cc.kmQuaternionScale = function(t, e, i) {
	t.x = e.x * i;
	t.y = e.y * i;
	t.z = e.z * i;
	t.w = e.w * i;
	return t
};
cc.kmQuaternionAssign = function(t, e) {
	t.x = e.x;
	t.y = e.y;
	t.z = e.z;
	t.w = e.w;
	return t
};
cc.kmQuaternionAdd = function(t, e, i) {
	t.x = e.x + i.x;
	t.y = e.y + i.y;
	t.z = e.z + i.z;
	t.w = e.w + i.w;
	return t
};
cc.kmQuaternionRotationBetweenVec3 = function(t, e, i, n) {
	var r = new cc.kmVec3,
		c = new cc.kmVec3;
	cc.kmVec3Assign(r, e);
	cc.kmVec3Assign(c, i);
	cc.kmVec3Normalize(r, r);
	cc.kmVec3Normalize(c, c);
	i = cc.kmVec3Dot(r, c);
	if (1 <= i) return cc.kmQuaternionIdentity(t), t; - .999999 > i ? Math.abs(cc.kmVec3LengthSq(n)) < cc.kmEpsilon ? cc.kmQuaternionRotationAxis(t, n, cc.kmPI) : (r = new cc.kmVec3, c = new cc.kmVec3, c.x = 1, c.y = 0, c.z = 0, cc.kmVec3Cross(r, c, e), Math.abs(cc.kmVec3LengthSq(r)) < cc.kmEpsilon && (c = new cc.kmVec3, c.x = 0, c.y = 1, c.z = 0, cc.kmVec3Cross(r, c, e)), cc.kmVec3Normalize(r, r), cc.kmQuaternionRotationAxis(t, r, cc.kmPI)) : (e = Math.sqrt(2 * (1 + i)), n = 1 / e, i = new cc.kmVec3, cc.kmVec3Cross(i, r, c), t.x = i.x * n, t.y = i.y * n, t.z = i.z * n, t.w = .5 * e, cc.kmQuaternionNormalize(t, t));
	return t
};
cc.kmQuaternionMultiplyVec3 = function(t, e, i) {
	var n = new cc.kmVec3,
		r = new cc.kmVec3,
		c = new cc.kmVec3;
	c.x = e.x;
	c.y = e.y;
	c.z = e.z;
	cc.kmVec3Cross(n, c, i);
	cc.kmVec3Cross(r, c, n);
	cc.kmVec3Scale(n, n, 2 * e.w);
	cc.kmVec3Scale(r, r, 2);
	cc.kmVec3Add(t, i, n);
	cc.kmVec3Add(t, t, r);
	return t
};
cc.kmAABB = function(t, e) {
	this.min = t || new cc.kmVec3;
	this.max = e || new cc.kmVec3
};
cc.kmAABBContainsPoint = function(t, e) {
	return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y && t.z >= e.min.z && t.z <= e.max.z ? cc.KM_TRUE : cc.KM_FALSE
};
cc.kmAABBAssign = function(t, e) {
	cc.kmVec3Assign(t.min, e.min);
	cc.kmVec3Assign(t.max, e.max);
	return t
};
cc.kmAABBScale = function(t, e, i) {
	cc.log("cc.kmAABBScale hasn't been supported.")
};
cc.km_mat4_stack = function(t, e, i, n) {
	this.top = i;
	this.stack = n
};
cc.km_mat4_stack.INITIAL_SIZE = 30;
cc.km_mat4_stack_initialize = function(t) {
	t.stack = [];
	t.top = null
};
cc.km_mat4_stack_push = function(t, e) {
	t.stack.push(t.top);
	t.top = new cc.kmMat4;
	cc.kmMat4Assign(t.top, e)
};
cc.km_mat4_stack_pop = function(t, e) {
	t.top = t.stack.pop()
};
cc.km_mat4_stack_release = function(t) {
	t.stack = null;
	t.top = null
};
cc.KM_GL_MODELVIEW = 5888;
cc.KM_GL_PROJECTION = 5889;
cc.KM_GL_TEXTURE = 5890;
cc.modelview_matrix_stack = new cc.km_mat4_stack;
cc.projection_matrix_stack = new cc.km_mat4_stack;
cc.texture_matrix_stack = new cc.km_mat4_stack;
cc.current_stack = null;
cc.initialized = !1;
cc.lazyInitialize = function() {
	if (!cc.initialized) {
		var t = new cc.kmMat4;
		cc.km_mat4_stack_initialize(cc.modelview_matrix_stack);
		cc.km_mat4_stack_initialize(cc.projection_matrix_stack);
		cc.km_mat4_stack_initialize(cc.texture_matrix_stack);
		cc.current_stack = cc.modelview_matrix_stack;
		cc.initialized = !0;
		cc.kmMat4Identity(t);
		cc.km_mat4_stack_push(cc.modelview_matrix_stack, t);
		cc.km_mat4_stack_push(cc.projection_matrix_stack, t);
		cc.km_mat4_stack_push(cc.texture_matrix_stack, t)
	}
};
cc.lazyInitialize();
cc.kmGLFreeAll = function() {
	cc.km_mat4_stack_release(cc.modelview_matrix_stack);
	cc.km_mat4_stack_release(cc.projection_matrix_stack);
	cc.km_mat4_stack_release(cc.texture_matrix_stack);
	cc.initialized = !1;
	cc.current_stack = null
};
cc.kmGLPushMatrix = function() {
	cc.km_mat4_stack_push(cc.current_stack, cc.current_stack.top)
};
cc.kmGLPushMatrixWitMat4 = function(t) {
	cc.current_stack.stack.push(cc.current_stack.top);
	cc.kmMat4Assign(t, cc.current_stack.top);
	cc.current_stack.top = t
};
cc.kmGLPopMatrix = function() {
	cc.current_stack.top = cc.current_stack.stack.pop()
};
cc.kmGLMatrixMode = function(t) {
	switch (t) {
	case cc.KM_GL_MODELVIEW:
		cc.current_stack = cc.modelview_matrix_stack;
		break;
	case cc.KM_GL_PROJECTION:
		cc.current_stack = cc.projection_matrix_stack;
		break;
	case cc.KM_GL_TEXTURE:
		cc.current_stack = cc.texture_matrix_stack;
		break;
	default:
		throw "Invalid matrix mode specified"
	}
};
cc.kmGLLoadIdentity = function() {
	cc.kmMat4Identity(cc.current_stack.top)
};
cc.kmGLLoadMatrix = function(t) {
	cc.kmMat4Assign(cc.current_stack.top, t)
};
cc.kmGLMultMatrix = function(t) {
	cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, t)
};
cc.kmGLTranslatef = function(t, e, i) {
	var n = new cc.kmMat4;
	cc.kmMat4Translation(n, t, e, i);
	cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, n)
};
cc.kmGLRotatef = function(t, e, i, n) {
	e = new cc.kmVec3(e, i, n);
	i = new cc.kmMat4;
	cc.kmMat4RotationAxisAngle(i, e, cc.kmDegreesToRadians(t));
	cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, i)
};
cc.kmGLScalef = function(t, e, i) {
	var n = new cc.kmMat4;
	cc.kmMat4Scaling(n, t, e, i);
	cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, n)
};
cc.kmGLGetMatrix = function(t, e) {
	switch (t) {
	case cc.KM_GL_MODELVIEW:
		cc.kmMat4Assign(e, cc.modelview_matrix_stack.top);
		break;
	case cc.KM_GL_PROJECTION:
		cc.kmMat4Assign(e, cc.projection_matrix_stack.top);
		break;
	case cc.KM_GL_TEXTURE:
		cc.kmMat4Assign(e, cc.texture_matrix_stack.top);
		break;
	default:
		throw "Invalid matrix mode specified"
	}
};
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor = v_fragmentColor;      \n}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize = u_pointSize;          \n    v_fragmentColor = u_color;           \n}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor = v_fragmentColor; \n} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color;             \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()	\n{ \n// #if defined GL_OES_standard_derivatives	\n// gl_FragColor = v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else	\ngl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;	\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;	\nvoid main() \n{ \n     v_color = a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord = a_texcoord; \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord);   \n}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;               \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;                 \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor = texture2D(CC_Texture0, v_texCoord);  \n    if ( texColor.a <= CC_alpha_value )          \n        discard; \n    gl_FragColor = texColor * v_fragmentColor;  \n}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   = texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  = texture2D(u_mask, v_texCoord); \n    vec4 finalColor = vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    = v_fragmentColor * finalColor; \n}";
cc.shaderCache = {
	TYPE_POSITION_TEXTURECOLOR: 0,
	TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
	TYPE_POSITION_COLOR: 2,
	TYPE_POSITION_TEXTURE: 3,
	TYPE_POSITION_TEXTURE_UCOLOR: 4,
	TYPE_POSITION_TEXTURE_A8COLOR: 5,
	TYPE_POSITION_UCOLOR: 6,
	TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
	TYPE_MAX: 8,
	_programs: {},
	_init: function() {
		this.loadDefaultShaders();
		return !0
	},
	_loadDefaultShader: function(t, e) {
		switch (e) {
		case this.TYPE_POSITION_TEXTURECOLOR:
			t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
			t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
			t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
			t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_COLOR:
			t.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
			t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			break;
		case this.TYPE_POSITION_TEXTURE:
			t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
			t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_TEXTURE_UCOLOR:
			t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
			t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_TEXTURE_A8COLOR:
			t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
			t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_UCOLOR:
			t.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
			t.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
			break;
		case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
			t.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
			t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			break;
		default:
			cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
			return
		}
		t.link();
		t.updateUniforms()
	},
	loadDefaultShaders: function() {
		var t = new cc.GLProgram;
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR);
		this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = t;
		this._programs.ShaderPositionTextureColor = t;
		t = new cc.GLProgram;
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
		this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = t;
		this._programs.ShaderPositionTextureColorAlphaTest = t;
		t = new cc.GLProgram;
		this._loadDefaultShader(t, this.TYPE_POSITION_COLOR);
		this._programs[cc.SHADER_POSITION_COLOR] = t;
		this._programs.ShaderPositionColor = t;
		t = new cc.GLProgram;
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE);
		this._programs[cc.SHADER_POSITION_TEXTURE] = t;
		this._programs.ShaderPositionTexture = t;
		t = new cc.GLProgram;
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_UCOLOR);
		this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = t;
		this._programs.ShaderPositionTextureUColor = t;
		t = new cc.GLProgram;
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_A8COLOR);
		this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = t;
		this._programs.ShaderPositionTextureA8Color = t;
		t = new cc.GLProgram;
		this._loadDefaultShader(t, this.TYPE_POSITION_UCOLOR);
		this._programs[cc.SHADER_POSITION_UCOLOR] = t;
		this._programs.ShaderPositionUColor = t;
		t = new cc.GLProgram;
		this._loadDefaultShader(t, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
		this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = t;
		this._programs.ShaderPositionLengthTextureColor = t
	},
	reloadDefaultShaders: function() {
		var t = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
		t.reset();
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR);
		t = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
		t.reset();
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
		t = this.programForKey(cc.SHADER_POSITION_COLOR);
		t.reset();
		this._loadDefaultShader(t, this.TYPE_POSITION_COLOR);
		t = this.programForKey(cc.SHADER_POSITION_TEXTURE);
		t.reset();
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE);
		t = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
		t.reset();
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_UCOLOR);
		t = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
		t.reset();
		this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_A8COLOR);
		t = this.programForKey(cc.SHADER_POSITION_UCOLOR);
		t.reset();
		this._loadDefaultShader(t, this.TYPE_POSITION_UCOLOR)
	},
	programForKey: function(t) {
		return this._programs[t]
	},
	getProgram: function(t) {
		return this._programs[t]
	},
	addProgram: function(t, e) {
		this._programs[e] = t
	}
};
cc.HashUniformEntry = function(t, e, i) {
	this.value = t;
	this.location = e;
	this.hh = i || {}
};
cc.GLProgram = cc.Class.extend({
	_glContext: null,
	_programObj: null,
	_vertShader: null,
	_fragShader: null,
	_uniforms: null,
	_hashForUniforms: null,
	_usesTime: !1,
	_updateUniformLocation: function(t, e, i) {
		if (null == t) return !1;
		i = !0;
		for (var n = null, r = 0; r < this._hashForUniforms.length; r++) this._hashForUniforms[r].location == t && (n = this._hashForUniforms[r]);
		n ? n.value == e ? i = !1 : n.value = e : (n = new cc.HashUniformEntry, n.location = t, n.value = e, this._hashForUniforms.push(n));
		return i
	},
	_description: function() {
		return "<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">"
	},
	_compileShader: function(t, e, i) {
		if (!i || !t) return !1;
		this._glContext.shaderSource(t, "precision highp float;        \nuniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \nuniform sampler2D CC_Texture0;   \n//CC INCLUDES END                \n" + i);
		this._glContext.compileShader(t);
		i = this._glContext.getShaderParameter(t, this._glContext.COMPILE_STATUS);
		i || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(t)), e == this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog()));
		return 1 == i
	},
	ctor: function(t, e, i) {
		this._uniforms = [];
		this._hashForUniforms = [];
		this._glContext = i || cc._renderContext;
		t && e && this.init(t, e)
	},
	destroyProgram: function() {
		this._hashForUniforms = this._uniforms = this._fragShader = this._vertShader = null;
		this._glContext.deleteProgram(this._programObj)
	},
	initWithVertexShaderByteArray: function(t, e) {
		var i = this._glContext;
		this._programObj = i.createProgram();
		this._fragShader = this._vertShader = null;
		t && (this._vertShader = i.createShader(i.VERTEX_SHADER), this._compileShader(this._vertShader, i.VERTEX_SHADER, t) || cc.log("cocos2d: ERROR: Failed to compile vertex shader"));
		e && (this._fragShader = i.createShader(i.FRAGMENT_SHADER), this._compileShader(this._fragShader, i.FRAGMENT_SHADER, e) || cc.log("cocos2d: ERROR: Failed to compile fragment shader"));
		this._vertShader && i.attachShader(this._programObj, this._vertShader);
		cc.checkGLErrorDebug();
		this._fragShader && i.attachShader(this._programObj, this._fragShader);
		this._hashForUniforms.length = 0;
		cc.checkGLErrorDebug();
		return !0
	},
	initWithString: function(t, e) {
		return this.initWithVertexShaderByteArray(t, e)
	},
	initWithVertexShaderFilename: function(t, e) {
		var i = cc.loader.getRes(t);
		if (!i) throw "Please load the resource firset : " + t;
		var n = cc.loader.getRes(e);
		if (!n) throw "Please load the resource firset : " + e;
		return this.initWithVertexShaderByteArray(i, n)
	},
	init: function(t, e) {
		return this.initWithVertexShaderFilename(t, e)
	},
	addAttribute: function(t, e) {
		this._glContext.bindAttribLocation(this._programObj, e, t)
	},
	link: function() {
		if (!this._programObj) return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
		this._glContext.linkProgram(this._programObj);
		this._vertShader && this._glContext.deleteShader(this._vertShader);
		this._fragShader && this._glContext.deleteShader(this._fragShader);
		this._fragShader = this._vertShader = null;
		return cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0
	},
	use: function() {
		cc.glUseProgram(this._programObj)
	},
	updateUniforms: function() {
		this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
		this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
		this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
		this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
		this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
		this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
		this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME];
		this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
		this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
		this.use();
		this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0)
	},
	getUniformLocationForName: function(t) {
		if (!t) throw "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null";
		if (!this._programObj) throw "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized";
		return this._glContext.getUniformLocation(this._programObj, t)
	},
	getUniformMVPMatrix: function() {
		return this._uniforms[cc.UNIFORM_MVPMATRIX]
	},
	getUniformSampler: function() {
		return this._uniforms[cc.UNIFORM_SAMPLER]
	},
	setUniformLocationWith1i: function(t, e) {
		this._updateUniformLocation(t, e) && this._glContext.uniform1i(t, e)
	},
	setUniformLocationWith2i: function(t, e, i) {
		this._updateUniformLocation(t, [e, i]) && this._glContext.uniform2i(t, e, i)
	},
	setUniformLocationWith3i: function(t, e, i, n) {
		this._updateUniformLocation(t, [e, i, n]) && this._glContext.uniform3i(t, e, i, n)
	},
	setUniformLocationWith4i: function(t, e, i, n, r) {
		this._updateUniformLocation(t, [e, i, n, r]) && this._glContext.uniform4i(t, e, i, n, r)
	},
	setUniformLocationWith2iv: function(t, e, i) {
		this._updateUniformLocation(t, e) && this._glContext.uniform2iv(t, e)
	},
	setUniformLocationWith3iv: function(t, e, i) {
		this._updateUniformLocation(t, e) && this._glContext.uniform3iv(t, e)
	},
	setUniformLocationWith4iv: function(t, e, i) {
		this._updateUniformLocation(t, e) && this._glContext.uniform4iv(t, e)
	},
	setUniformLocationI32: function(t, e) {
		this.setUniformLocationWith1i(t, e)
	},
	setUniformLocationWith1f: function(t, e) {
		this._updateUniformLocation(t, e) && this._glContext.uniform1f(t, e)
	},
	setUniformLocationWith2f: function(t, e, i) {
		this._updateUniformLocation(t, [e, i]) && this._glContext.uniform2f(t, e, i)
	},
	setUniformLocationWith3f: function(t, e, i, n) {
		this._updateUniformLocation(t, [e, i, n]) && this._glContext.uniform3f(t, e, i, n)
	},
	setUniformLocationWith4f: function(t, e, i, n, r) {
		this._updateUniformLocation(t, [e, i, n, r]) && this._glContext.uniform4f(t, e, i, n, r)
	},
	setUniformLocationWith2fv: function(t, e, i) {
		this._updateUniformLocation(t, e) && this._glContext.uniform2fv(t, e)
	},
	setUniformLocationWith3fv: function(t, e, i) {
		this._updateUniformLocation(t, e) && this._glContext.uniform3fv(t, e)
	},
	setUniformLocationWith4fv: function(t, e, i) {
		this._updateUniformLocation(t, e) && this._glContext.uniform4fv(t, e)
	},
	setUniformLocationWithMatrix4fv: function(t, e, i) {
		this._updateUniformLocation(t, e) && this._glContext.uniformMatrix4fv(t, !1, e)
	},
	setUniformLocationF32: function() {
		if (!(2 > arguments.length)) switch (arguments.length) {
		case 2:
			this.setUniformLocationWith1f(arguments[0], arguments[1]);
			break;
		case 3:
			this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
			break;
		case 4:
			this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
			break;
		case 5:
			this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
		}
	},
	setUniformsForBuiltins: function() {
		var t = new cc.kmMat4,
			e = new cc.kmMat4,
			i = new cc.kmMat4;
		cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, t);
		cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, e);
		cc.kmMat4Multiply(i, t, e);
		this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], t.mat, 1);
		this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], e.mat, 1);
		this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], i.mat, 1);
		this._usesTime && (t = cc.director, t = t.getTotalFrames() * t.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], t / 10, t, 2 * t, 4 * t), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], t / 8, t / 4, t / 2, Math.sin(t)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], t / 8, t / 4, t / 2, Math.cos(t))); - 1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
	},
	_setUniformsForBuiltinsForRenderer: function(t) {
		if (t && t._renderCmd) {
			var e = new cc.kmMat4,
				i = new cc.kmMat4;
			cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, e);
			cc.kmMat4Multiply(i, e, t._renderCmd._stackMatrix);
			this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], e.mat, 1);
			this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], t._renderCmd._stackMatrix.mat, 1);
			this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], i.mat, 1);
			this._usesTime && (t = cc.director, t = t.getTotalFrames() * t.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], t / 10, t, 2 * t, 4 * t), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], t / 8, t / 4, t / 2, Math.sin(t)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], t / 8, t / 4, t / 2, Math.cos(t))); - 1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
		}
	},
	setUniformForModelViewProjectionMatrix: function() {
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
	},
	setUniformForModelViewProjectionMatrixWithMat4: function(t) {
		cc.kmMat4Multiply(t, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, t.mat)
	},
	setUniformForModelViewAndProjectionMatrixWithMat4: function() {
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat);
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
	},
	_setUniformForMVPMatrixWithMat4: function(t) {
		if (!t) throw "modelView matrix is undefined.";
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, t.mat);
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
	},
	vertexShaderLog: function() {
		return this._glContext.getShaderInfoLog(this._vertShader)
	},
	getVertexShaderLog: function() {
		return this._glContext.getShaderInfoLog(this._vertShader)
	},
	getFragmentShaderLog: function() {
		return this._glContext.getShaderInfoLog(this._vertShader)
	},
	fragmentShaderLog: function() {
		return this._glContext.getShaderInfoLog(this._fragShader)
	},
	programLog: function() {
		return this._glContext.getProgramInfoLog(this._programObj)
	},
	getProgramLog: function() {
		return this._glContext.getProgramInfoLog(this._programObj)
	},
	reset: function() {
		this._fragShader = this._vertShader = null;
		this._uniforms.length = 0;
		this._glContext.deleteProgram(this._programObj);
		this._programObj = null;
		for (var t = 0; t < this._hashForUniforms.length; t++) this._hashForUniforms[t].value = null, this._hashForUniforms[t] = null;
		this._hashForUniforms.length = 0
	},
	getProgram: function() {
		return this._programObj
	},
	retain: function() {},
	release: function() {}
});
cc.GLProgram.create = function(t, e) {
	return new cc.GLProgram(t, e)
};
cc.setProgram = function(t, e) {
	t.shaderProgram = e;
	var i = t.children;
	if (i) for (var n = 0; n < i.length; n++) cc.setProgram(i[n], e)
};
cc._currentProjectionMatrix = -1;
cc._vertexAttribPosition = !1;
cc._vertexAttribColor = !1;
cc._vertexAttribTexCoords = !1;
cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0));
cc.glInvalidateStateCache = function() {
	cc.kmGLFreeAll();
	cc._currentProjectionMatrix = -1;
	cc._vertexAttribPosition = !1;
	cc._vertexAttribColor = !1;
	cc._vertexAttribTexCoords = !1;
	if (cc.ENABLE_GL_STATE_CACHE) {
		cc._currentShaderProgram = -1;
		for (var t = 0; t < cc.MAX_ACTIVETEXTURE; t++) cc._currentBoundTexture[t] = -1;
		cc._blendingSource = -1;
		cc._blendingDest = -1;
		cc._GLServerState = 0
	}
};
cc.glUseProgram = function(t) {
	t !== cc._currentShaderProgram && (cc._currentShaderProgram = t, cc._renderContext.useProgram(t))
};
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(t) {
	cc._renderContext.useProgram(t)
});
cc.glDeleteProgram = function(t) {
	cc.ENABLE_GL_STATE_CACHE && t === cc._currentShaderProgram && (cc._currentShaderProgram = -1);
	gl.deleteProgram(t)
};
cc.glBlendFunc = function(t, e) {
	if (t !== cc._blendingSource || e !== cc._blendingDest) cc._blendingSource = t, cc._blendingDest = e, cc.setBlending(t, e)
};
cc.setBlending = function(t, e) {
	var i = cc._renderContext;
	t === i.ONE && e === i.ZERO ? i.disable(i.BLEND) : (i.enable(i.BLEND), cc._renderContext.blendFunc(t, e))
};
cc.glBlendFuncForParticle = function(t, e) {
	if (t !== cc._blendingSource || e !== cc._blendingDest) {
		cc._blendingSource = t;
		cc._blendingDest = e;
		var i = cc._renderContext;
		t === i.ONE && e === i.ZERO ? i.disable(i.BLEND) : (i.enable(i.BLEND), i.blendFuncSeparate(i.SRC_ALPHA, e, t, e))
	}
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending);
cc.glBlendResetToCache = function() {
	var t = cc._renderContext;
	t.blendEquation(t.FUNC_ADD);
	cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(t.BLEND_SRC, t.BLEND_DST)
};
cc.setProjectionMatrixDirty = function() {
	cc._currentProjectionMatrix = -1
};
cc.glEnableVertexAttribs = function(t) {
	var e = cc._renderContext,
		i = t & cc.VERTEX_ATTRIB_FLAG_POSITION;
	i !== cc._vertexAttribPosition && (i ? e.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : e.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = i);
	i = t & cc.VERTEX_ATTRIB_FLAG_COLOR;
	i !== cc._vertexAttribColor && (i ? e.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : e.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = i);
	t &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
	t !== cc._vertexAttribTexCoords && (t ? e.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : e.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = t)
};
cc.glBindTexture2D = function(t) {
	cc.glBindTexture2DN(0, t)
};
cc.glBindTexture2DN = function(t, e) {
	if (cc._currentBoundTexture[t] != e) {
		cc._currentBoundTexture[t] = e;
		var i = cc._renderContext;
		i.activeTexture(i.TEXTURE0 + t);
		e ? i.bindTexture(i.TEXTURE_2D, e._webTextureObj) : i.bindTexture(i.TEXTURE_2D, null)
	}
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(t, e) {
	var i = cc._renderContext;
	i.activeTexture(i.TEXTURE0 + t);
	e ? i.bindTexture(i.TEXTURE_2D, e._webTextureObj) : i.bindTexture(i.TEXTURE_2D, null)
});
cc.glDeleteTexture = function(t) {
	cc.glDeleteTextureN(0, t)
};
cc.glDeleteTextureN = function(t, e) {
	cc.ENABLE_GL_STATE_CACHE && e == cc._currentBoundTexture[t] && (cc._currentBoundTexture[t] = -1);
	cc._renderContext.deleteTexture(e)
};
cc.glBindVAO = function(t) {
	cc.TEXTURE_ATLAS_USE_VAO && (cc.ENABLE_GL_STATE_CACHE && cc._uVAO != t) && (cc._uVAO = t)
};
cc.glEnable = function(t) {};
cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 9;
cc.NextPOT = function(t) {
	t -= 1;
	t |= t >> 1;
	t |= t >> 2;
	t |= t >> 4;
	t |= t >> 8;
	return (t | t >> 16) + 1
};
cc.RenderTexture = cc.Node.extend({
	sprite: null,
	clearFlags: 0,
	clearDepthVal: 0,
	autoDraw: !1,
	_texture: null,
	_pixelFormat: cc.Texture2D.PIXEL_FORMAT_RGBA8888,
	clearStencilVal: 0,
	_clearColor: null,
	_className: "RenderTexture",
	ctor: function(t, e, i, n) {
		cc.Node.prototype.ctor.call(this);
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
		this._clearColor = new cc.Color(0, 0, 0, 255);
		void 0 !== t && void 0 !== e && (i = i || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(t, e, i, n || 0));
		this.setAnchorPoint(0, 0)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.RenderTexture.CanvasRenderCmd(this) : new cc.RenderTexture.WebGLRenderCmd(this)
	},
	cleanup: function() {
		cc.Node.prototype.onExit.call(this);
		this._renderCmd.cleanup()
	},
	getSprite: function() {
		return this.sprite
	},
	setSprite: function(t) {
		this.sprite = t
	},
	initWithWidthAndHeight: function(t, e, i, n) {
		return this._renderCmd.initWithWidthAndHeight(t, e, i, n)
	},
	begin: function() {
		cc.renderer._turnToCacheMode(this.__instanceId);
		this._renderCmd.begin()
	},
	beginWithClear: function(t, e, i, n, r, c) {
		var s = cc._renderContext;
		r = r || s.COLOR_BUFFER_BIT;
		c = c || s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT;
		this._beginWithClear(t, e, i, n, r, c, s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT | s.STENCIL_BUFFER_BIT)
	},
	_beginWithClear: function(t, e, i, n, r, c, s) {
		this.begin();
		this._renderCmd._beginWithClear(t, e, i, n, r, c, s)
	},
	end: function() {
		this._renderCmd.end()
	},
	clear: function(t, e, i, n) {
		this.beginWithClear(t, e, i, n);
		this.end()
	},
	clearRect: function(t, e, i, n) {
		this._renderCmd.clearRect(t, e, i, n)
	},
	clearDepth: function(t) {
		this._renderCmd.clearDepth(t)
	},
	clearStencil: function(t) {
		this._renderCmd.clearStencil(t)
	},
	getClearFlags: function() {
		return this.clearFlags
	},
	setClearFlags: function(t) {
		this.clearFlags = t
	},
	getClearColor: function() {
		return this._clearColor
	},
	setClearColor: function(t) {
		var e = this._clearColor;
		e.r = t.r;
		e.g = t.g;
		e.b = t.b;
		e.a = t.a;
		this._renderCmd.updateClearColor(t)
	},
	getClearDepth: function() {
		return this.clearDepthVal
	},
	setClearDepth: function(t) {
		this.clearDepthVal = t
	},
	getClearStencil: function() {
		return this.clearStencilVal
	},
	setClearStencil: function(t) {
		this.clearStencilVal = t
	},
	isAutoDraw: function() {
		return this.autoDraw
	},
	setAutoDraw: function(t) {
		this.autoDraw = t
	},
	saveToFile: function(t, e) {
		cc.log("saveToFile isn't supported on Cocos2d-Html5")
	},
	newCCImage: function(t) {
		cc.log("saveToFile isn't supported on cocos2d-html5");
		return null
	},
	listenToBackground: function(t) {},
	listenToForeground: function(t) {}
});
_p = cc.RenderTexture.prototype;
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
cc.RenderTexture.create = function(t, e, i, n) {
	return new cc.RenderTexture(t, e, i, n)
};
(function() {
	cc.RenderTexture.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._needDraw = !0;
		this._clearColorStr = "rgba(255,255,255,1)";
		this._cacheCanvas = cc.newElement("canvas");
		this._cacheContext = this._cacheCanvas.getContext("2d")
	};
	var t = cc.RenderTexture.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.RenderTexture.CanvasRenderCmd;
	t.cleanup = function() {
		this._cacheCanvas = this._cacheContext = null
	};
	t.clearStencil = function(t) {};
	t.updateClearColor = function(t) {
		this._clearColorStr = "rgba(" + (0 | t.r) + "," + (0 | t.g) + "," + (0 | t.b) + "," + t.a / 255 + ")"
	};
	t.initWithWidthAndHeight = function(t, e, i, n) {
		i = this._node;
		n = this._cacheCanvas;
		var r = cc.contentScaleFactor();
		n.width = 0 | t * r;
		n.height = 0 | e * r;
		this._cacheContext.translate(0, n.height);
		t = new cc.Texture2D;
		t.initWithElement(n);
		t.handleLoadedTexture();
		t = i.sprite = new cc.Sprite(t);
		t.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
		i.autoDraw = !1;
		i.addChild(t);
		return !0
	};
	t.begin = function() {};
	t._beginWithClear = function(t, e, i, n, r, c, s) {
		t = t || 0;
		e = e || 0;
		i = i || 0;
		n = isNaN(n) ? 1 : n;
		r = this._cacheContext;
		c = this._cacheCanvas;
		r.save();
		r.fillStyle = "rgba(" + (0 | t) + "," + (0 | e) + "," + (0 | i) + "," + n / 255 + ")";
		r.clearRect(0, 0, c.width, -c.height);
		r.fillRect(0, 0, c.width, -c.height);
		r.restore()
	};
	t.end = function() {
		var t = this._node,
			e = cc.contentScaleFactor();
		cc.renderer._renderingToCacheCanvas(this._cacheContext, t.__instanceId, e, e)
	};
	t.clearRect = function(t, e, i, n) {
		this._cacheContext.clearRect(t, e, i, -n)
	};
	t.clearDepth = function(t) {
		cc.log("clearDepth isn't supported on Cocos2d-Html5")
	};
	t.visit = function(t) {
		var e = this._node;
		this._syncStatus(t);
		e.sprite.visit(this);
		this._dirtyFlag = 0
	};
	t.draw = function() {
		var t = this._node;
		if (t.clearFlags) {
			var e = this._cacheCanvas;
			ctx.save();
			ctx.fillStyle = this._clearColorStr;
			ctx.clearRect(0, 0, e.width, -e.height);
			ctx.fillRect(0, 0, e.width, -e.height);
			ctx.restore()
		}
		t.sortAllChildren();
		for (var e = t._children, i = e.length, n = t.sprite, r = 0; r < i; r++) {
			var c = e[r];
			c != n && c.visit(this)
		}
		t.end()
	}
})();
(function() {
	cc.RenderTexture.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !0;
		this._depthRenderBuffer = this._textureCopy = this._oldFBO = this._fBO = null
	};
	var t = cc.RenderTexture.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	t.constructor = cc.RenderTexture.WebGLRenderCmd;
	t.rendering = function(t) {
		var e = t || cc._renderContext;
		t = this._node;
		if (t.autoDraw) {
			t.begin();
			var i = t.clearFlags;
			if (i) {
				var n = [0, 0, 0, 0],
					r = 0,
					c = 0;
				i & e.COLOR_BUFFER_BIT && (n = e.getParameter(e.COLOR_CLEAR_VALUE), e.clearColor(t._clearColor.r / 255, t._clearColor.g / 255, t._clearColor.b / 255, t._clearColor.a / 255));
				i & e.DEPTH_BUFFER_BIT && (r = e.getParameter(e.DEPTH_CLEAR_VALUE), e.clearDepth(t.clearDepthVal));
				i & e.STENCIL_BUFFER_BIT && (c = e.getParameter(e.STENCIL_CLEAR_VALUE), e.clearStencil(t.clearStencilVal));
				e.clear(i);
				i & e.COLOR_BUFFER_BIT && e.clearColor(n[0], n[1], n[2], n[3]);
				i & e.DEPTH_BUFFER_BIT && e.clearDepth(r);
				i & e.STENCIL_BUFFER_BIT && e.clearStencil(c)
			}
			t.sortAllChildren();
			e = t._children;
			for (i = 0; i < e.length; i++) n = e[i], n != t.sprite && n._renderCmd.visit(t.sprite._renderCmd);
			t.end()
		}
	};
	t.clearStencil = function(t) {
		var e = cc._renderContext,
			i = e.getParameter(e.STENCIL_CLEAR_VALUE);
		e.clearStencil(t);
		e.clear(e.STENCIL_BUFFER_BIT);
		e.clearStencil(i)
	};
	t.cleanup = function() {
		this._textureCopy = null;
		var t = cc._renderContext;
		t.deleteFramebuffer(this._fBO);
		this._depthRenderBuffer && t.deleteRenderbuffer(this._depthRenderBuffer)
	};
	t.updateClearColor = function(t) {};
	t.initWithWidthAndHeight = function(t, e, i, n) {
		var r = this._node;
		i == cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
		var c = cc._renderContext,
			s = cc.contentScaleFactor();
		t = 0 | t * s;
		e = 0 | e * s;
		this._oldFBO = c.getParameter(c.FRAMEBUFFER_BINDING);
		var o;
		cc.configuration.supportsNPOT() ? (s = t, o = e) : (s = cc.NextPOT(t), o = cc.NextPOT(e));
		for (var a = new Uint8Array(4 * s * o), h = 0; h < 4 * s * o; h++) a[h] = 0;
		this._pixelFormat = i;
		h = r._texture = new cc.Texture2D;
		if (!r._texture) return !1;
		h.initWithData(a, r._pixelFormat, s, o, cc.size(t, e));
		i = c.getParameter(c.RENDERBUFFER_BINDING);
		if (cc.configuration.checkForGLExtension("GL_QCOM")) {
			this._textureCopy = new cc.Texture2D;
			if (!this._textureCopy) return !1;
			this._textureCopy.initWithData(a, r._pixelFormat, s, o, cc.size(t, e))
		}
		this._fBO = c.createFramebuffer();
		c.bindFramebuffer(c.FRAMEBUFFER, this._fBO);
		c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, h._webTextureObj, 0);
		0 != n && (this._depthRenderBuffer = c.createRenderbuffer(), c.bindRenderbuffer(c.RENDERBUFFER, this._depthRenderBuffer), c.renderbufferStorage(c.RENDERBUFFER, n, s, o), n === c.DEPTH_STENCIL ? c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_STENCIL_ATTACHMENT, c.RENDERBUFFER, this._depthRenderBuffer) : n === c.STENCIL_INDEX || n === c.STENCIL_INDEX8 ? c.framebufferRenderbuffer(c.FRAMEBUFFER, c.STENCIL_ATTACHMENT, c.RENDERBUFFER, this._depthRenderBuffer) : n === c.DEPTH_COMPONENT16 && c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_ATTACHMENT, c.RENDERBUFFER, this._depthRenderBuffer));
		c.checkFramebufferStatus(c.FRAMEBUFFER) !== c.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer");
		h.setAliasTexParameters();
		t = r.sprite = new cc.Sprite(h);
		t.scaleY = -1;
		t.setBlendFunc(c.ONE, c.ONE_MINUS_SRC_ALPHA);
		c.bindRenderbuffer(c.RENDERBUFFER, i);
		c.bindFramebuffer(c.FRAMEBUFFER, this._oldFBO);
		r.autoDraw = !1;
		r.addChild(t);
		return !0
	};
	t.begin = function() {
		var t = this._node;
		cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
		cc.kmGLPushMatrix();
		cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
		cc.kmGLPushMatrix();
		var e = cc.director;
		e.setProjection(e.getProjection());
		var i = t._texture.getContentSizeInPixels(),
			n = cc.director.getWinSizeInPixels(),
			e = n.width / i.width,
			n = n.height / i.height,
			r = cc._renderContext;
		r.viewport(0, 0, i.width, i.height);
		i = new cc.kmMat4;
		cc.kmMat4OrthographicProjection(i, -1 / e, 1 / e, -1 / n, 1 / n, -1, 1);
		cc.kmGLMultMatrix(i);
		this._oldFBO = r.getParameter(r.FRAMEBUFFER_BINDING);
		r.bindFramebuffer(r.FRAMEBUFFER, this._fBO);
		cc.configuration.checkForGLExtension("GL_QCOM") && (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, this._textureCopy._webTextureObj, 0), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, t._texture._webTextureObj, 0))
	};
	t._beginWithClear = function(t, e, i, n, r, c, s) {
		t /= 255;
		e /= 255;
		i /= 255;
		n /= 255;
		var o = cc._renderContext,
			a = [0, 0, 0, 0],
			h = 0,
			l = 0;
		s & o.COLOR_BUFFER_BIT && (a = o.getParameter(o.COLOR_CLEAR_VALUE), o.clearColor(t, e, i, n));
		s & o.DEPTH_BUFFER_BIT && (h = o.getParameter(o.DEPTH_CLEAR_VALUE), o.clearDepth(r));
		s & o.STENCIL_BUFFER_BIT && (l = o.getParameter(o.STENCIL_CLEAR_VALUE), o.clearStencil(c));
		o.clear(s);
		s & o.COLOR_BUFFER_BIT && o.clearColor(a[0], a[1], a[2], a[3]);
		s & o.DEPTH_BUFFER_BIT && o.clearDepth(h);
		s & o.STENCIL_BUFFER_BIT && o.clearStencil(l)
	};
	t.end = function() {
		cc.renderer._renderingToBuffer(this._node.__instanceId);
		var t = cc._renderContext,
			e = cc.director;
		t.bindFramebuffer(t.FRAMEBUFFER, this._oldFBO);
		e.setViewport();
		cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
		cc.kmGLPopMatrix();
		cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
		cc.kmGLPopMatrix()
	};
	t.clearRect = function(t, e, i, n) {};
	t.clearDepth = function(t) {
		var e = this._node;
		e.begin();
		var i = cc._renderContext,
			n = i.getParameter(i.DEPTH_CLEAR_VALUE);
		i.clearDepth(t);
		i.clear(i.DEPTH_BUFFER_BIT);
		i.clearDepth(n);
		e.end()
	};
	t.visit = function(t) {
		var e = this._node;
		e._visible && (cc.kmGLPushMatrix(), this._syncStatus(t), cc.renderer.pushRenderCommand(this), e.sprite.visit(this), this._dirtyFlag = 0, cc.kmGLPopMatrix())
	}
})();
cc.LabelAtlas = cc.AtlasNode.extend({
	_string: null,
	_mapStartChar: null,
	_textureLoaded: !1,
	_className: "LabelAtlas",
	ctor: function(t, e, i, n, r) {
		cc.AtlasNode.prototype.ctor.call(this);
		this._renderCmd.setCascade();
		e && cc.LabelAtlas.prototype.initWithString.call(this, t, e, i, n, r)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelAtlas.WebGLRenderCmd(this) : new cc.LabelAtlas.CanvasRenderCmd(this)
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(t, e) {
		this.addEventListener("load", t, e)
	},
	initWithString: function(t, e, i, n, r) {
		var c = t + "",
			s, o;
		if (void 0 === i) {
			i = cc.loader.getRes(e);
			if (1 !== parseInt(i.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
			e = cc.path.changeBasename(e, i.textureFilename);
			n = cc.contentScaleFactor();
			s = parseInt(i.itemWidth, 10) / n;
			o = parseInt(i.itemHeight, 10) / n;
			i = String.fromCharCode(parseInt(i.firstChar, 10))
		} else s = i || 0, o = n || 0, i = r || " ";
		var a = null,
			a = e instanceof cc.Texture2D ? e : cc.textureCache.addImage(e);
		(this._textureLoaded = e = a.isLoaded()) || a.addEventListener("load", function(t) {
			this.initWithTexture(a, s, o, c.length);
			this.string = c;
			this.dispatchEvent("load")
		}, this);
		return this.initWithTexture(a, s, o, c.length) ? (this._mapStartChar = i, this.string = c, !0) : !1
	},
	setColor: function(t) {
		cc.AtlasNode.prototype.setColor.call(this, t);
		this._renderCmd.updateAtlasValues()
	},
	getString: function() {
		return this._string
	},
	addChild: function(t, e, i) {
		this._renderCmd._addChild(t);
		cc.Node.prototype.addChild.call(this, t, e, i)
	},
	updateAtlasValues: function() {
		this._renderCmd.updateAtlasValues()
	},
	setString: function(t) {
		t = String(t);
		var e = t.length;
		this._string = t;
		this.setContentSize(e * this._itemWidth, this._itemHeight);
		this._renderCmd.setString(t);
		this._renderCmd.updateAtlasValues();
		this.quadsToDraw = e
	}
});
(function() {
	var t = cc.LabelAtlas.prototype;
	cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity);
	cc.defineGetterSetter(t, "color", t.getColor, t.setColor);
	cc.defineGetterSetter(t, "string", t.getString, t.setString)
})();
cc.LabelAtlas.create = function(t, e, i, n, r) {
	return new cc.LabelAtlas(t, e, i, n, r)
};
(function() {
	cc.LabelAtlas.CanvasRenderCmd = function(t) {
		cc.AtlasNode.CanvasRenderCmd.call(this, t);
		this._needDraw = !1
	};
	var t = cc.LabelAtlas.CanvasRenderCmd.prototype = Object.create(cc.AtlasNode.CanvasRenderCmd.prototype);
	t.constructor = cc.LabelAtlas.CanvasRenderCmd;
	t.setCascade = function() {
		var t = this._node;
		t._cascadeOpacityEnabled = !0;
		t._cascadeColorEnabled = !1
	};
	t.updateAtlasValues = function() {
		for (var t = this._node, e = t._string || "", i = e.length, n = this._texture, r = t._itemWidth, c = t._itemHeight, s = 0; s < i; s++) {
			var o = e.charCodeAt(s) - t._mapStartChar.charCodeAt(0),
				a = parseInt(o % t._itemsPerRow, 10),
				o = parseInt(o / t._itemsPerRow, 10),
				a = cc.rect(a * r, o * c, r, c),
				o = e.charCodeAt(s),
				h = t.getChildByTag(s);
			h ? 32 == o ? (h.init(), h.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (h.initWithTexture(n, a), h.visible = !0) : (h = new cc.Sprite, 32 == o ? (h.init(), h.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : h.initWithTexture(n, a), cc.Node.prototype.addChild.call(t, h, 0, s));
			h.setPosition(s * r + r / 2, c / 2)
		}
	};
	t.setString = function(t) {
		t = this._node;
		if (t._children) {
			t = t._children;
			for (var e = t.length, i = 0; i < e; i++) {
				var n = t[i];
				n && !n._lateChild && (n.visible = !1)
			}
		}
	};
	t._addChild = function() {
		child._lateChild = !0
	}
})();
(function() {
	cc.LabelAtlas.WebGLRenderCmd = function(t) {
		cc.AtlasNode.WebGLRenderCmd.call(this, t);
		this._needDraw = !0
	};
	var t = cc.LabelAtlas.WebGLRenderCmd.prototype = Object.create(cc.AtlasNode.WebGLRenderCmd.prototype);
	t.constructor = cc.LabelAtlas.WebGLRenderCmd;
	t.setCascade = function() {
		var t = this._node;
		t._cascadeOpacityEnabled = !0;
		t._cascadeColorEnabled = !0
	};
	t.rendering = function(t) {
		cc.AtlasNode.WebGLRenderCmd.prototype.rendering.call(this, t);
		cc.LABELATLAS_DEBUG_DRAW && (t = this._node.getContentSize(), t = [cc.p(0, 0), cc.p(t.width, 0), cc.p(t.width, t.height), cc.p(0, t.height)], cc._drawingUtil.drawPoly(t, 4, !0))
	};
	t.updateAtlasValues = function() {
		var t = this._node,
			e = t._string,
			i = e.length,
			n = this._textureAtlas,
			r = n.texture,
			c = r.pixelsWidth,
			r = r.pixelsHeight,
			s = t._itemWidth,
			o = t._itemHeight;
		t._ignoreContentScaleFactor || (s = t._itemWidth * cc.contentScaleFactor(), o = t._itemHeight * cc.contentScaleFactor());
		i > n.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
		for (var a = n.quads, h = this._displayedColor, h = {
			r: h.r,
			g: h.g,
			b: h.b,
			a: t._displayedOpacity
		}, l = t._itemWidth, u = 0; u < i; u++) {
			var d = e.charCodeAt(u) - t._mapStartChar.charCodeAt(0),
				_ = d % t._itemsPerRow,
				f = 0 | d / t._itemsPerRow,
				p;
			cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (_ = (2 * _ * s + 1) / (2 * c), d = _ + (2 * s - 2) / (2 * c), f = (2 * f * o + 1) / (2 * r), p = f + (2 * o - 2) / (2 * r)) : (_ = _ * s / c, d = _ + s / c, f = f * o / r, p = f + o / r);
			var g = a[u],
				m = g.tl,
				T = g.tr,
				y = g.bl,
				g = g.br;
			m.texCoords.u = _;
			m.texCoords.v = f;
			T.texCoords.u = d;
			T.texCoords.v = f;
			y.texCoords.u = _;
			y.texCoords.v = p;
			g.texCoords.u = d;
			g.texCoords.v = p;
			y.vertices.x = u * l;
			y.vertices.y = 0;
			y.vertices.z = 0;
			g.vertices.x = u * l + l;
			g.vertices.y = 0;
			g.vertices.z = 0;
			m.vertices.x = u * l;
			m.vertices.y = t._itemHeight;
			m.vertices.z = 0;
			T.vertices.x = u * l + l;
			T.vertices.y = t._itemHeight;
			T.vertices.z = 0;
			m.colors = h;
			T.colors = h;
			y.colors = h;
			g.colors = h
		}
		0 < i && (n.dirty = !0, t = n.totalQuads, i > t && n.increaseTotalQuadsWith(i - t))
	};
	t.setString = function(t) {
		t = t.length;
		t > this._textureAtlas.totalQuads && this._textureAtlas.resizeCapacity(t)
	};
	t._addChild = function() {}
})();
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({
	_opacityModifyRGB: !1,
	_string: "",
	_config: null,
	_fntFile: "",
	_initialString: "",
	_alignment: cc.TEXT_ALIGNMENT_CENTER,
	_width: -1,
	_lineBreakWithoutSpaces: !1,
	_imageOffset: null,
	_reusedChar: null,
	_textureLoaded: !1,
	_className: "LabelBMFont",
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelBMFont.WebGLRenderCmd(this) : new cc.LabelBMFont.CanvasRenderCmd(this)
	},
	_setString: function(t, e) {
		e ? this._initialString = t : this._string = t;
		var i = this._children;
		if (i) for (var n = 0; n < i.length; n++) {
			var r = i[n];
			r && r.setVisible(!1)
		}
		this._textureLoaded && (this.createFontChars(), e && this.updateLabel())
	},
	ctor: function(t, e, i, n, r) {
		cc.SpriteBatchNode.prototype.ctor.call(this);
		this._imageOffset = cc.p(0, 0);
		this._reusedChar = [];
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
		this.initWithString(t, e, i, n, r)
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(t, e) {
		this.addEventListener("load", t, e)
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	setOpacityModifyRGB: function(t) {
		this._opacityModifyRGB = t;
		if (t = this._children) for (var e = 0; e < t.length; e++) {
			var i = t[e];
			i && (i.opacityModifyRGB = this._opacityModifyRGB)
		}
	},
	_changeTextureColor: function() {
		this._renderCmd._changeTextureColor()
	},
	init: function() {
		return this.initWithString(null, null, null, null, null)
	},
	initWithString: function(t, e, i, n, r) {
		t = t || "";
		this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
		if (e) {
			var c = cc.loader.getRes(e);
			if (!c) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
			this._config = c;
			this._fntFile = e;
			e = cc.textureCache.addImage(c.atlasName);
			(this._textureLoaded = c = e.isLoaded()) || e.addEventListener("load", function(t) {
				this._textureLoaded = !0;
				this.initWithTexture(t, this._initialString.length);
				this.setString(this._initialString, !0);
				this.dispatchEvent("load")
			}, this)
		} else e = new cc.Texture2D, c = new Image, e.initWithElement(c), this._textureLoaded = !1;
		return this.initWithTexture(e, t.length) ? (this._alignment = n || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = r || cc.p(0, 0), this._width = null == i ? -1 : i, this._realOpacity = 255, this._realColor = cc.color(255, 255, 255, 255), this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(.5, .5), this._renderCmd._initBatchTexture(), this.setString(t, !0), !0) : !1
	},
	createFontChars: function() {
		var t = this._renderCmd._texture || this.textureAtlas.texture,
			e = 0,
			i = cc.size(0, 0),
			n = 0,
			r = 1,
			c = this._string,
			s = c ? c.length : 0;
		if (0 !== s) {
			var o, a = this._config,
				h = a.kerningDict,
				l = a.commonHeight,
				u = a.fontDefDictionary;
			for (o = 0; o < s - 1; o++) 10 == c.charCodeAt(o) && r++;
			var d = l * r,
				r = -(l - l * r),
				_ = -1;
			for (o = 0; o < s; o++) if (l = c.charCodeAt(o), 0 != l) if (10 === l) e = 0, r -= a.commonHeight;
			else {
				var f = h[_ << 16 | l & 65535] || 0,
					p = u[l];
				if (p) {
					var g = cc.rect(p.rect.x, p.rect.y, p.rect.width, p.rect.height),
						g = cc.rectPixelsToPoints(g);
					g.x += this._imageOffset.x;
					g.y += this._imageOffset.y;
					(_ = this.getChildByTag(o)) ? this._renderCmd._updateCharTexture(_, g, l) : (_ = new cc.Sprite, _.initWithTexture(t, g, !1), _._newTextureWhenChangeColor = !0, this.addChild(_, 0, o));
					_.opacityModifyRGB = this._opacityModifyRGB;
					this._renderCmd._updateCharColorAndOpacity(_);
					g = cc.p(e + p.xOffset + .5 * p.rect.width + f, r + (a.commonHeight - p.yOffset) - .5 * g.height * cc.contentScaleFactor());
					_.setPosition(cc.pointPixelsToPoints(g));
					e += p.xAdvance + f;
					_ = l;
					n < e && (n = e)
				} else cc.log("cocos2d: LabelBMFont: character not found " + c[o])
			}
			i.width = p && p.xAdvance < p.rect.width ? n - p.xAdvance + p.rect.width : n;
			i.height = d;
			this.setContentSize(cc.sizePixelsToPoints(i))
		}
	},
	updateString: function(t) {
		var e = this._children;
		if (e) for (var i = 0, n = e.length; i < n; i++) {
			var r = e[i];
			r && (r.visible = !1)
		}
		this._config && this.createFontChars();
		t || this.updateLabel()
	},
	getString: function() {
		return this._initialString
	},
	setString: function(t, e) {
		t = String(t);
		null == e && (e = !0);
		if (null == t || !cc.isString(t)) t += "";
		this._initialString = t;
		this._setString(t, e)
	},
	_setStringForSetter: function(t) {
		this.setString(t, !1)
	},
	setCString: function(t) {
		this.setString(t, !0)
	},
	updateLabel: function() {
		this.string = this._initialString;
		if (0 < this._width) {
			for (var t = this._string.length, e = [], i = [], n = 1, r = 0, c = !1, s = !1, o = -1, a = -1, h = 0, l, u = 0, d = this._children.length; u < d; u++) {
				for (var _ = 0; !(l = this.getChildByTag(u + h + _));) _++;
				h += _;
				if (r >= t) break;
				var f = this._string[r];
				s || (a = this._getLetterPosXLeft(l), s = !0);
				c || (o = a, c = !0);
				if (10 == f.charCodeAt(0)) {
					i.push("\n");
					e = e.concat(i);
					i.length = 0;
					c = s = !1;
					o = a = -1;
					u--;
					h -= _;
					n++;
					if (r >= t) break;
					a || (a = this._getLetterPosXLeft(l), s = !0);
					o || (o = a, c = !0);
					r++
				} else if (this._isspace_unicode(f)) i.push(f), e = e.concat(i), i.length = 0, s = !1, a = -1, r++;
				else if (this._getLetterPosXRight(l) - o > this._width) if (this._lineBreakWithoutSpaces) {
					this._utf8_trim_ws(i);
					i.push("\n");
					e = e.concat(i);
					i.length = 0;
					c = s = !1;
					o = a = -1;
					n++;
					if (r >= t) break;
					a || (a = this._getLetterPosXLeft(l), s = !0);
					o || (o = a, c = !0);
					u--
				} else i.push(f), -1 != e.lastIndexOf(" ") ? this._utf8_trim_ws(e) : e = [], 0 < e.length && e.push("\n"), n++, c = !1, o = -1, r++;
				else i.push(f), r++
			}
			e = e.concat(i);
			u = e.length;
			l = "";
			for (r = 0; r < u; ++r) l += e[r];
			l += String.fromCharCode(0);
			this._setString(l, !1)
		}
		if (this._alignment != cc.TEXT_ALIGNMENT_LEFT) {
			e = r = 0;
			t = this._string.length;
			i = [];
			for (n = 0; n < t; n++) if (10 == this._string[n].charCodeAt(0) || 0 == this._string[n].charCodeAt(0)) if (u = 0, c = i.length, 0 == c) e++;
			else {
				if (l = r + c - 1 + e, !(0 > l) && (u = this.getChildByTag(l), null != u)) {
					u = u.getPositionX() + u._getWidth() / 2;
					s = 0;
					switch (this._alignment) {
					case cc.TEXT_ALIGNMENT_CENTER:
						s = this.width / 2 - u / 2;
						break;
					case cc.TEXT_ALIGNMENT_RIGHT:
						s = this.width - u
					}
					if (0 != s) for (u = 0; u < c; u++) if (l = r + u + e, !(0 > l) && (l = this.getChildByTag(l))) l.x += s;
					r += c;
					e++;
					i.length = 0
				}
			} else i.push(this._string[r])
		}
	},
	setAlignment: function(t) {
		this._alignment = t;
		this.updateLabel()
	},
	_getAlignment: function() {
		return this._alignment
	},
	setBoundingWidth: function(t) {
		this._width = t;
		this.updateLabel()
	},
	_getBoundingWidth: function() {
		return this._width
	},
	setLineBreakWithoutSpace: function(t) {
		this._lineBreakWithoutSpaces = t;
		this.updateLabel()
	},
	setScale: function(t, e) {
		cc.Node.prototype.setScale.call(this, t, e);
		this.updateLabel()
	},
	setScaleX: function(t) {
		cc.Node.prototype.setScaleX.call(this, t);
		this.updateLabel()
	},
	setScaleY: function(t) {
		cc.Node.prototype.setScaleY.call(this, t);
		this.updateLabel()
	},
	setFntFile: function(t) {
		if (null != t && t != this._fntFile) {
			var e = cc.loader.getRes(t);
			e ? (this._fntFile = t, this._config = e, t = cc.textureCache.addImage(e.atlasName), this._textureLoaded = e = t.isLoaded(), this.texture = t, this._renderCmd._updateFntFileTexture(), e ? this.createFontChars() : t.addEventListener("load", function(t) {
				this._textureLoaded = !0;
				this.texture = t;
				this.createFontChars();
				this._changeTextureColor();
				this.updateLabel();
				this.dispatchEvent("load")
			}, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
		}
	},
	getFntFile: function() {
		return this._fntFile
	},
	setTexture: function(t) {
		this._renderCmd.setTexture(t)
	},
	setAnchorPoint: function(t, e) {
		cc.Node.prototype.setAnchorPoint.call(this, t, e);
		this.updateLabel()
	},
	_setAnchorX: function(t) {
		cc.Node.prototype._setAnchorX.call(this, t);
		this.updateLabel()
	},
	_setAnchorY: function(t) {
		cc.Node.prototype._setAnchorY.call(this, t);
		this.updateLabel()
	},
	_atlasNameFromFntFile: function(t) {},
	_kerningAmountForFirst: function(t, e) {
		var i = 0;
		if (this._configuration.kerningDictionary) {
			var n = this._configuration.kerningDictionary[(t << 16 | e & 65535).toString()];
			n && (i = n.amount)
		}
		return i
	},
	_getLetterPosXLeft: function(t) {
		return t.getPositionX() * this._scaleX - t._getWidth() * this._scaleX * t._getAnchorX()
	},
	_getLetterPosXRight: function(t) {
		return t.getPositionX() * this._scaleX + t._getWidth() * this._scaleX * t._getAnchorX()
	},
	_isspace_unicode: function(t) {
		t = t.charCodeAt(0);
		return 9 <= t && 13 >= t || 32 == t || 133 == t || 160 == t || 5760 == t || 8192 <= t && 8202 >= t || 8232 == t || 8233 == t || 8239 == t || 8287 == t || 12288 == t
	},
	_utf8_trim_ws: function(t) {
		var e = t.length;
		if (!(0 >= e) && (e -= 1, this._isspace_unicode(t[e]))) {
			for (var i = e - 1; 0 <= i; --i) if (this._isspace_unicode(t[i])) e = i;
			else break;
			this._utf8_trim_from(t, e)
		}
	},
	_utf8_trim_from: function(t, e) {
		var i = t.length;
		e >= i || 0 > e || t.splice(e, i)
	}
});
(function() {
	var t = cc.LabelBMFont.prototype;
	cc.EventHelper.prototype.apply(t);
	cc.defineGetterSetter(t, "string", t.getString, t._setStringForSetter);
	cc.defineGetterSetter(t, "boundingWidth", t._getBoundingWidth, t.setBoundingWidth);
	cc.defineGetterSetter(t, "textAlign", t._getAlignment, t.setAlignment)
})();
cc.LabelBMFont.create = function(t, e, i, n, r) {
	return new cc.LabelBMFont(t, e, i, n, r)
};
cc._fntLoader = {
	INFO_EXP: /info [^\n]*(\n|$)/gi,
	COMMON_EXP: /common [^\n]*(\n|$)/gi,
	PAGE_EXP: /page [^\n]*(\n|$)/gi,
	CHAR_EXP: /char [^\n]*(\n|$)/gi,
	KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
	ITEM_EXP: /\w+=[^ \r\n]+/gi,
	INT_EXP: /^[\-]?\d+$/,
	_parseStrToObj: function(t) {
		t = t.match(this.ITEM_EXP);
		var e = {};
		if (t) for (var i = 0, n = t.length; i < n; i++) {
			var r = t[i],
				c = r.indexOf("="),
				s = r.substring(0, c),
				r = r.substring(c + 1);
			r.match(this.INT_EXP) ? r = parseInt(r) : '"' == r[0] && (r = r.substring(1, r.length - 1));
			e[s] = r
		}
		return e
	},
	parseFnt: function(t, e) {
		var i = {},
			n = this._parseStrToObj(t.match(this.INFO_EXP)[0]).padding.split(",");
		parseInt(n[0]);
		parseInt(n[1]);
		parseInt(n[2]);
		parseInt(n[3]);
		n = this._parseStrToObj(t.match(this.COMMON_EXP)[0]);
		i.commonHeight = n.lineHeight;
		if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
			var r = cc.configuration.getMaxTextureSize();
			(n.scaleW > r.width || n.scaleH > r.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
		}
		1 !== n.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
		n = this._parseStrToObj(t.match(this.PAGE_EXP)[0]);
		0 !== n.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
		i.atlasName = cc.path.changeBasename(e, n.file);
		for (var c = t.match(this.CHAR_EXP), s = i.fontDefDictionary = {}, n = 0, r = c.length; n < r; n++) {
			var o = this._parseStrToObj(c[n]);
			s[o.id] = {
				rect: {
					x: o.x,
					y: o.y,
					width: o.width,
					height: o.height
				},
				xOffset: o.xoffset,
				yOffset: o.yoffset,
				xAdvance: o.xadvance
			}
		}
		c = i.kerningDict = {};
		if (s = t.match(this.KERNING_EXP)) {
			n = 0;
			for (r = s.length; n < r; n++) o = this._parseStrToObj(s[n]), c[o.first << 16 | o.second & 65535] = o.amount
		}
		return i
	},
	load: function(t, e, i, n) {
		var r = this;
		cc.loader.loadTxt(t, function(t, i) {
			if (t) return n(t);
			n(null, r.parseFnt(i, e))
		})
	}
};
cc.loader.register(["fnt"], cc._fntLoader);
(function() {
	cc.LabelBMFont.CanvasRenderCmd = function(t) {
		cc.SpriteBatchNode.CanvasRenderCmd.call(this, t);
		this._needDraw = !0
	};
	var t = cc.LabelBMFont.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
	t.constructor = cc.LabelBMFont.CanvasRenderCmd;
	t.rendering = function() {
		void 0
	};
	t._updateCharTexture = function(t, e, i) {
		32 === i ? t.setTextureRect(e, !1, cc.size(0, 0)) : (t.setTextureRect(e, !1), t.visible = !0)
	};
	t._updateCharColorAndOpacity = function(t) {
		t._displayedColor = this._displayedColor;
		t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
		t._displayedOpacity = this._displayedOpacity;
		t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	};
	t._updateFntFileTexture = function() {
		var t = this._node;
		t._originalTexture = t.texture
	};
	t.setTexture = function(t) {
		for (var e = this._node, i = e._children, e = e._displayedColor, n = 0; n < i.length; n++) {
			var r = i[n],
				c = r._renderCmd,
				s = c._displayedColor;
			this._texture != c._texture && (s.r !== e.r || s.g !== e.g || s.b !== e.b) || (r.texture = t)
		}
		this._texture = t
	};
	t._changeTextureColor = cc.sys._supportCanvasNewBlendModes ?
	function() {
		var t = this._node,
			e = t.getTexture();
		if (e && 0 < e.getContentSize().width) {
			var i = this._originalTexture.getHtmlElementObj();
			if (i) {
				var n = e.getHtmlElementObj(),
					r = cc.rect(0, 0, i.width, i.height);
				n instanceof HTMLCanvasElement && !t._rectRotated ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(i, this._displayedColor, r, n) : (n = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(i, this._displayedColor, r), e = new cc.Texture2D, e.initWithElement(n), e.handleLoadedTexture());
				t.setTexture(e)
			}
		}
	} : function() {
		var t = this._node,
			e, i = t.getTexture();
		if (i && 0 < i.getContentSize().width && (e = i.getHtmlElementObj())) {
			var n = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
			n && (e instanceof HTMLCanvasElement && !this._rectRotated ? (cc.Sprite.CanvasRenderCmd._generateTintImage(e, n, this._displayedColor, null, e), this.setTexture(i)) : (e = cc.Sprite.CanvasRenderCmd._generateTintImage(e, n, this._displayedColor), i = new cc.Texture2D, i.initWithElement(e), i.handleLoadedTexture(), t.setTexture(i)))
		}
	};
	t._updateChildrenDisplayedOpacity = function(t) {
		cc.Node.prototype.updateDisplayedOpacity.call(t, this._displayedOpacity)
	};
	t._updateChildrenDisplayedColor = function(t) {
		cc.Node.prototype.updateDisplayedColor.call(t, this._displayedColor)
	};
	t._initBatchTexture = function() {}
})();
(function() {
	cc.LabelBMFont.WebGLRenderCmd = function(t) {
		cc.SpriteBatchNode.WebGLRenderCmd.call(this, t);
		this._needDraw = !0
	};
	var t = cc.LabelBMFont.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
	t.constructor = cc.LabelBMFont.WebGLRenderCmd;
	t._updateCharTexture = function(t, e, i) {
		t.setTextureRect(e, !1);
		t.visible = !0
	};
	t._updateFntFileTexture = function() {};
	t._changeTextureColor = function() {};
	t._updateChildrenDisplayedOpacity = function(t) {
		t.updateDisplayedOpacity(this._displayedOpacity)
	};
	t._updateChildrenDisplayedColor = function(t) {
		t.updateDisplayedColor(this._displayedColor)
	};
	t._initBatchTexture = function() {
		var t = this._node,
			e = t.textureAtlas.texture;
		t._opacityModifyRGB = e.hasPremultipliedAlpha();
		var i = t._reusedChar = new cc.Sprite;
		i.initWithTexture(e, cc.rect(0, 0, 0, 0), !1);
		i.batchNode = t
	};
	t.rendering = function(t) {
		cc.SpriteBatchNode.WebGLRenderCmd.prototype.rendering.call(this, t);
		t = this._node;
		if (cc.LABELBMFONT_DEBUG_DRAW) {
			t = t.getContentSize();
			var e = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
			t = [cc.p(e.x, e.y), cc.p(e.x + t.width, e.y), cc.p(e.x + t.width, e.y + t.height), cc.p(e.x, e.y + t.height)];
			cc._drawingUtil.setDrawColor(0, 255, 0, 255);
			cc._drawingUtil.drawPoly(t, 4, !0)
		}
	};
	t._updateCharColorAndOpacity = function() {}
})();
cc.MotionStreak = cc.Node.extend({
	texture: null,
	fastMode: !1,
	startingPositionInitialized: !1,
	_blendFunc: null,
	_stroke: 0,
	_fadeDelta: 0,
	_minSeg: 0,
	_maxPoints: 0,
	_nuPoints: 0,
	_previousNuPoints: 0,
	_pointVertexes: null,
	_pointState: null,
	_vertices: null,
	_colorPointer: null,
	_texCoords: null,
	_verticesBuffer: null,
	_colorPointerBuffer: null,
	_texCoordsBuffer: null,
	_className: "MotionStreak",
	ctor: function(t, e, i, n, r) {
		cc.Node.prototype.ctor.call(this);
		this._positionR = cc.p(0, 0);
		this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
		this.startingPositionInitialized = this.fastMode = !1;
		this.texture = null;
		this._previousNuPoints = this._nuPoints = this._maxPoints = this._minSeg = this._fadeDelta = this._stroke = 0;
		this._texCoordsBuffer = this._colorPointerBuffer = this._verticesBuffer = this._texCoords = this._colorPointer = this._vertices = this._pointState = this._pointVertexes = null;
		void 0 !== r && this.initWithFade(t, e, i, n, r)
	},
	getTexture: function() {
		return this.texture
	},
	setTexture: function(t) {
		this.texture != t && (this.texture = t)
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(t, e) {
		void 0 === e ? this._blendFunc = t : (this._blendFunc.src = t, this._blendFunc.dst = e)
	},
	getOpacity: function() {
		cc.log("cc.MotionStreak.getOpacity has not been supported.");
		return 0
	},
	setOpacity: function(t) {
		cc.log("cc.MotionStreak.setOpacity has not been supported.")
	},
	setOpacityModifyRGB: function(t) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	isFastMode: function() {
		return this.fastMode
	},
	setFastMode: function(t) {
		this.fastMode = t
	},
	isStartingPositionInitialized: function() {
		return this.startingPositionInitialized
	},
	setStartingPositionInitialized: function(t) {
		this.startingPositionInitialized = t
	},
	initWithFade: function(t, e, i, n, r) {
		if (!r) throw "cc.MotionStreak.initWithFade(): Invalid filename or texture";
		cc.isString(r) && (r = cc.textureCache.addImage(r));
		cc.Node.prototype.setPosition.call(this, cc.p(0, 0));
		this.anchorY = this.anchorX = 0;
		this.ignoreAnchor = !0;
		this.startingPositionInitialized = !1;
		this.fastMode = !0;
		this._minSeg = -1 === e ? i / 5 : e;
		this._minSeg *= this._minSeg;
		this._stroke = i;
		this._fadeDelta = 1 / t;
		this._maxPoints = t = (0 | 60 * t) + 2;
		this._nuPoints = 0;
		this._pointState = new Float32Array(t);
		this._pointVertexes = new Float32Array(2 * t);
		this._vertices = new Float32Array(4 * t);
		this._texCoords = new Float32Array(4 * t);
		this._colorPointer = new Uint8Array(8 * t);
		this._verticesBuffer = gl.createBuffer();
		this._texCoordsBuffer = gl.createBuffer();
		this._colorPointerBuffer = gl.createBuffer();
		this._blendFunc.src = gl.SRC_ALPHA;
		this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
		this.texture = r;
		this.color = n;
		this.scheduleUpdate();
		gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW);
		return !0
	},
	tintWithColor: function(t) {
		this.color = t;
		for (var e = this._colorPointer, i = 0, n = 2 * this._nuPoints; i < n; i++) e[4 * i] = t.r, e[4 * i + 1] = t.g, e[4 * i + 2] = t.b
	},
	reset: function() {
		this._nuPoints = 0
	},
	setPosition: function(t, e) {
		this.startingPositionInitialized = !0;
		void 0 === e ? (this._positionR.x = t.x, this._positionR.y = t.y) : (this._positionR.x = t, this._positionR.y = e)
	},
	getPositionX: function() {
		return this._positionR.x
	},
	setPositionX: function(t) {
		this._positionR.x = t;
		this.startingPositionInitialized || (this.startingPositionInitialized = !0)
	},
	getPositionY: function() {
		return this._positionR.y
	},
	setPositionY: function(t) {
		this._positionR.y = t;
		this.startingPositionInitialized || (this.startingPositionInitialized = !0)
	},
	update: function(t) {
		if (this.startingPositionInitialized) {
			this._renderCmd._updateDisplayColor();
			t *= this._fadeDelta;
			var e, i, n, r, c = 0,
				s = this._nuPoints,
				o = this._pointState,
				a = this._pointVertexes,
				h = this._vertices,
				l = this._colorPointer;
			for (n = 0; n < s; n++) o[n] -= t, 0 >= o[n] ? c++ : (e = n - c, 0 < c ? (o[e] = o[n], a[2 * e] = a[2 * n], a[2 * e + 1] = a[2 * n + 1], r = 2 * n, i = 2 * e, h[2 * i] = h[2 * r], h[2 * i + 1] = h[2 * r + 1], h[2 * (i + 1)] = h[2 * (r + 1)], h[2 * (i + 1) + 1] = h[2 * (r + 1) + 1], r *= 4, i *= 4, l[i + 0] = l[r + 0], l[i + 1] = l[r + 1], l[i + 2] = l[r + 2], l[i + 4] = l[r + 4], l[i + 5] = l[r + 5], l[i + 6] = l[r + 6]) : i = 8 * e, e = 255 * o[e], l[i + 3] = e, l[i + 7] = e);
			s -= c;
			n = !0;
			if (s >= this._maxPoints) n = !1;
			else if (0 < s && (t = cc.pDistanceSQ(cc.p(a[2 * (s - 1)], a[2 * (s - 1) + 1]), this._positionR) < this._minSeg, i = 1 == s ? !1 : cc.pDistanceSQ(cc.p(a[2 * (s - 2)], a[2 * (s - 2) + 1]), this._positionR) < 2 * this._minSeg, t || i)) n = !1;
			n && (a[2 * s] = this._positionR.x, a[2 * s + 1] = this._positionR.y, o[s] = 1, o = 8 * s, n = this.getDisplayedColor(), l[o] = n.r, l[o + 1] = n.g, l[o + 2] = n.b, l[o + 4] = n.r, l[o + 5] = n.g, l[o + 6] = n.b, l[o + 3] = 255, l[o + 7] = 255, 0 < s && this.fastMode && (1 < s ? cc.vertexLineToPolygon(a, this._stroke, this._vertices, s, 1) : cc.vertexLineToPolygon(a, this._stroke, this._vertices, 0, 2)), s++);
			this.fastMode || cc.vertexLineToPolygon(a, this._stroke, this._vertices, 0, s);
			if (s && this._previousNuPoints != s) {
				a = 1 / s;
				l = this._texCoords;
				for (n = 0; n < s; n++) l[4 * n] = 0, l[4 * n + 1] = a * n, l[2 * (2 * n + 1)] = 1, l[2 * (2 * n + 1) + 1] = a * n;
				this._previousNuPoints = s
			}
			this._nuPoints = s
		}
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.MotionStreak.WebGLRenderCmd(this) : null
	}
});
cc.MotionStreak.create = function(t, e, i, n, r) {
	return new cc.MotionStreak(t, e, i, n, r)
};
cc.MotionStreak.WebGLRenderCmd = function(t) {
	cc.Node.WebGLRenderCmd.call(this, t);
	this._needDraw = !0;
	this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
};
cc.MotionStreak.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
cc.MotionStreak.WebGLRenderCmd.prototype.constructor = cc.Sprite.WebGLRenderCmd;
cc.MotionStreak.WebGLRenderCmd.prototype.rendering = function(t) {
	var e = this._node;
	!(1 >= e._nuPoints) && (e.texture && e.texture.isLoaded()) && (t = t || cc._renderContext, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst), cc.glBindTexture2D(e.texture), t.bindBuffer(t.ARRAY_BUFFER, e._verticesBuffer), t.bufferData(t.ARRAY_BUFFER, e._vertices, t.DYNAMIC_DRAW), t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0), t.bindBuffer(t.ARRAY_BUFFER, e._texCoordsBuffer), t.bufferData(t.ARRAY_BUFFER, e._texCoords, t.DYNAMIC_DRAW), t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, 0, 0), t.bindBuffer(t.ARRAY_BUFFER, e._colorPointerBuffer), t.bufferData(t.ARRAY_BUFFER, e._colorPointer, t.DYNAMIC_DRAW), t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 0, 0), t.drawArrays(t.TRIANGLE_STRIP, 0, 2 * e._nuPoints), cc.g_NumberOfDraws++)
};
cc.NodeGrid = cc.Node.extend({
	grid: null,
	_target: null,
	getGrid: function() {
		return this.grid
	},
	setGrid: function(t) {
		this.grid = t
	},
	setTarget: function(t) {
		this._target = t
	},
	_transformForWebGL: function() {
		var t = this._transform4x4,
			e = cc.current_stack.top,
			i = this.getNodeToParentTransform(),
			n = t.mat;
		n[0] = i.a;
		n[4] = i.c;
		n[12] = i.tx;
		n[1] = i.b;
		n[5] = i.d;
		n[13] = i.ty;
		n[14] = this._vertexZ;
		cc.kmMat4Multiply(e, e, t);
		if (null != this._camera && (!this.grid || !this.grid.isActive())) t = this._anchorPointInPoints.x, e = this._anchorPointInPoints.y, 0 !== t || 0 !== e ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (t |= 0, e |= 0), cc.kmGLTranslatef(t, e, 0), this._camera.locate(), cc.kmGLTranslatef(-t, -e, 0)) : this._camera.locate()
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.NodeGrid.WebGLRenderCmd(this) : new cc.Node.CanvasRenderCmd(this)
	}
});
_p = cc.NodeGrid.prototype;
cc.defineGetterSetter(_p, "target", null, _p.setTarget);
cc.NodeGrid.create = function() {
	return new cc.NodeGrid
};
(function() {
	cc.NodeGrid.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !1;
		this._gridBeginCommand = new cc.CustomRenderCmd(this, this.onGridBeginDraw);
		this._gridEndCommand = new cc.CustomRenderCmd(this, this.onGridEndDraw)
	};
	var t = cc.NodeGrid.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	t.constructor = cc.NodeGrid.WebGLRenderCmd;
	t.visit = function(t) {
		var e = this._node;
		if (e._visible) {
			t = t || this.getParentRenderCmd();
			e._parent && e._parent._renderCmd && (this._curLevel = e._parent._renderCmd._curLevel + 1);
			var i = cc.current_stack;
			i.stack.push(i.top);
			this._syncStatus(t);
			i.top = this._stackMatrix;
			cc.renderer.pushRenderCommand(this._gridBeginCommand);
			e._target && e._target.visit();
			if ((t = e._children) && 0 < t.length) {
				var n = t.length;
				e.sortAllChildren();
				for (e = 0; e < n; e++) {
					var r = t[e];
					r && r.visit()
				}
			}
			cc.renderer.pushRenderCommand(this._gridEndCommand);
			this._dirtyFlag = 0;
			i.top = i.stack.pop()
		}
	};
	t.onGridBeginDraw = function() {
		var t = this._node.grid;
		t && t._active && t.beforeDraw()
	};
	t.onGridEndDraw = function() {
		var t = this._node.grid;
		t && t._active && t.afterDraw(this._node)
	}
})();
cc.v2fzero = function() {
	return {
		x: 0,
		y: 0
	}
};
cc.v2f = function(t, e) {
	return {
		x: t,
		y: e
	}
};
cc.v2fadd = function(t, e) {
	return cc.v2f(t.x + e.x, t.y + e.y)
};
cc.v2fsub = function(t, e) {
	return cc.v2f(t.x - e.x, t.y - e.y)
};
cc.v2fmult = function(t, e) {
	return cc.v2f(t.x * e, t.y * e)
};
cc.v2fperp = function(t) {
	return cc.v2f(-t.y, t.x)
};
cc.v2fneg = function(t) {
	return cc.v2f(-t.x, -t.y)
};
cc.v2fdot = function(t, e) {
	return t.x * e.x + t.y * e.y
};
cc.v2fforangle = function(t) {
	return cc.v2f(Math.cos(t), Math.sin(t))
};
cc.v2fnormalize = function(t) {
	t = cc.pNormalize(cc.p(t.x, t.y));
	return cc.v2f(t.x, t.y)
};
cc.__v2f = function(t) {
	return cc.v2f(t.x, t.y)
};
cc.__t = function(t) {
	return {
		u: t.x,
		v: t.y
	}
};
cc.DrawNodeCanvas = cc.Node.extend({
	_buffer: null,
	_blendFunc: null,
	_lineWidth: 1,
	_drawColor: null,
	_className: "DrawNodeCanvas",
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		var t = this._renderCmd;
		t._buffer = this._buffer = [];
		t._drawColor = this._drawColor = cc.color(255, 255, 255, 255);
		t._blendFunc = this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
		this.init()
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(t, e) {
		void 0 === e ? (this._blendFunc.src = t.src, this._blendFunc.dst = t.dst) : (this._blendFunc.src = t, this._blendFunc.dst = e)
	},
	setLineWidth: function(t) {
		this._lineWidth = t
	},
	getLineWidth: function() {
		return this._lineWidth
	},
	setDrawColor: function(t) {
		var e = this._drawColor;
		e.r = t.r;
		e.g = t.g;
		e.b = t.b;
		e.a = null == t.a ? 255 : t.a
	},
	getDrawColor: function() {
		return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
	},
	drawRect: function(t, e, i, n, r) {
		n = n || this._lineWidth;
		r = r || this.getDrawColor();
		null == r.a && (r.a = 255);
		t = [t, cc.p(e.x, t.y), e, cc.p(t.x, e.y)];
		e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		e.verts = t;
		e.lineWidth = n;
		e.lineColor = r;
		e.isClosePolygon = !0;
		e.isStroke = !0;
		e.lineCap = "butt";
		if (e.fillColor = i) null == i.a && (i.a = 255), e.isFill = !0;
		this._buffer.push(e)
	},
	drawCircle: function(t, e, i, n, r, c, s) {
		c = c || this._lineWidth;
		s = s || this.getDrawColor();
		null == s.a && (s.a = 255);
		for (var o = 2 * Math.PI / n, a = [], h = 0; h <= n; h++) {
			var l = h * o,
				u = e * Math.cos(l + i) + t.x,
				l = e * Math.sin(l + i) + t.y;
			a.push(cc.p(u, l))
		}
		r && a.push(cc.p(t.x, t.y));
		t = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		t.verts = a;
		t.lineWidth = c;
		t.lineColor = s;
		t.isClosePolygon = !0;
		t.isStroke = !0;
		this._buffer.push(t)
	},
	drawQuadBezier: function(t, e, i, n, r, c) {
		r = r || this._lineWidth;
		c = c || this.getDrawColor();
		null == c.a && (c.a = 255);
		for (var s = [], o = 0, a = 0; a < n; a++) {
			var h = Math.pow(1 - o, 2) * t.x + 2 * (1 - o) * o * e.x + o * o * i.x,
				l = Math.pow(1 - o, 2) * t.y + 2 * (1 - o) * o * e.y + o * o * i.y;
			s.push(cc.p(h, l));
			o += 1 / n
		}
		s.push(cc.p(i.x, i.y));
		t = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		t.verts = s;
		t.lineWidth = r;
		t.lineColor = c;
		t.isStroke = !0;
		t.lineCap = "round";
		this._buffer.push(t)
	},
	drawCubicBezier: function(t, e, i, n, r, c, s) {
		c = c || this._lineWidth;
		s = s || this.getDrawColor();
		null == s.a && (s.a = 255);
		for (var o = [], a = 0, h = 0; h < r; h++) {
			var l = Math.pow(1 - a, 3) * t.x + 3 * Math.pow(1 - a, 2) * a * e.x + 3 * (1 - a) * a * a * i.x + a * a * a * n.x,
				u = Math.pow(1 - a, 3) * t.y + 3 * Math.pow(1 - a, 2) * a * e.y + 3 * (1 - a) * a * a * i.y + a * a * a * n.y;
			o.push(cc.p(l, u));
			a += 1 / r
		}
		o.push(cc.p(n.x, n.y));
		t = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		t.verts = o;
		t.lineWidth = c;
		t.lineColor = s;
		t.isStroke = !0;
		t.lineCap = "round";
		this._buffer.push(t)
	},
	drawCatmullRom: function(t, e, i, n) {
		this.drawCardinalSpline(t, .5, e, i, n)
	},
	drawCardinalSpline: function(t, e, i, n, r) {
		n = n || this._lineWidth;
		r = r || this.getDrawColor();
		null == r.a && (r.a = 255);
		for (var c = [], s, o, a = 1 / t.length, h = 0; h < i + 1; h++) o = h / i, 1 == o ? (s = t.length - 1, o = 1) : (s = 0 | o / a, o = (o - a * s) / a), s = cc.cardinalSplineAt(cc.getControlPointAt(t, s - 1), cc.getControlPointAt(t, s - 0), cc.getControlPointAt(t, s + 1), cc.getControlPointAt(t, s + 2), e, o), c.push(s);
		t = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		t.verts = c;
		t.lineWidth = n;
		t.lineColor = r;
		t.isStroke = !0;
		t.lineCap = "round";
		this._buffer.push(t)
	},
	drawDot: function(t, e, i) {
		i = i || this.getDrawColor();
		null == i.a && (i.a = 255);
		var n = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
		n.verts = [t];
		n.lineWidth = e;
		n.fillColor = i;
		this._buffer.push(n)
	},
	drawDots: function(t, e, i) {
		if (t && 0 != t.length) {
			i = i || this.getDrawColor();
			null == i.a && (i.a = 255);
			for (var n = 0, r = t.length; n < r; n++) this.drawDot(t[n], e, i)
		}
	},
	drawSegment: function(t, e, i, n) {
		i = i || this._lineWidth;
		n = n || this.getDrawColor();
		null == n.a && (n.a = 255);
		var r = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		r.verts = [t, e];
		r.lineWidth = 2 * i;
		r.lineColor = n;
		r.isStroke = !0;
		r.lineCap = "round";
		this._buffer.push(r)
	},
	drawPoly_: function(t, e, i, n) {
		i = i || this._lineWidth;
		n = n || this.getDrawColor();
		null == n.a && (n.a = 255);
		var r = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		r.verts = t;
		r.fillColor = e;
		r.lineWidth = i;
		r.lineColor = n;
		r.isClosePolygon = !0;
		r.isStroke = !0;
		r.lineCap = "round";
		e && (r.isFill = !0);
		this._buffer.push(r)
	},
	drawPoly: function(t, e, i, n) {
		for (var r = [], c = 0; c < t.length; c++) r.push(cc.p(t[c].x, t[c].y));
		return this.drawPoly_(r, e, i, n)
	},
	draw: function(t) {
		t = t || cc._renderContext;
		this._blendFunc && (this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE) && (t.globalCompositeOperation = "lighter");
		for (var e = 0; e < this._buffer.length; e++) {
			var i = this._buffer[e];
			switch (i.type) {
			case cc.DrawNode.TYPE_DOT:
				this._drawDot(t, i);
				break;
			case cc.DrawNode.TYPE_SEGMENT:
				this._drawSegment(t, i);
				break;
			case cc.DrawNode.TYPE_POLY:
				this._drawPoly(t, i)
			}
		}
	},
	_drawDot: function(t, e) {
		var i = e.fillColor,
			n = e.verts[0],
			r = e.lineWidth,
			c = cc.view.getScaleX(),
			s = cc.view.getScaleY();
		t.fillStyle = "rgba(" + (0 | i.r) + "," + (0 | i.g) + "," + (0 | i.b) + "," + i.a / 255 + ")";
		t.beginPath();
		t.arc(n.x * c, -n.y * s, r * c, 0, 2 * Math.PI, !1);
		t.closePath();
		t.fill()
	},
	_drawSegment: function(t, e) {
		var i = e.lineColor,
			n = e.verts[0],
			r = e.verts[1],
			c = e.lineWidth,
			s = e.lineCap,
			o = cc.view.getScaleX(),
			a = cc.view.getScaleY();
		t.strokeStyle = "rgba(" + (0 | i.r) + "," + (0 | i.g) + "," + (0 | i.b) + "," + i.a / 255 + ")";
		t.lineWidth = c * o;
		t.beginPath();
		t.lineCap = s;
		t.moveTo(n.x * o, -n.y * a);
		t.lineTo(r.x * o, -r.y * a);
		t.stroke()
	},
	_drawPoly: function(t, e) {
		var i = e.verts,
			n = e.lineCap,
			r = e.fillColor,
			c = e.lineWidth,
			s = e.lineColor,
			o = e.isClosePolygon,
			a = e.isFill,
			h = e.isStroke;
		if (null != i) {
			var l = i[0],
				u = cc.view.getScaleX(),
				d = cc.view.getScaleY();
			t.lineCap = n;
			r && (t.fillStyle = "rgba(" + (0 | r.r) + "," + (0 | r.g) + "," + (0 | r.b) + "," + r.a / 255 + ")");
			c && (t.lineWidth = c * u);
			s && (t.strokeStyle = "rgba(" + (0 | s.r) + "," + (0 | s.g) + "," + (0 | s.b) + "," + s.a / 255 + ")");
			t.beginPath();
			t.moveTo(l.x * u, -l.y * d);
			n = 1;
			for (r = i.length; n < r; n++) t.lineTo(i[n].x * u, -i[n].y * d);
			o && t.closePath();
			a && t.fill();
			h && t.stroke()
		}
	},
	clear: function() {
		this._buffer.length = 0
	},
	_createRenderCmd: function() {
		return new cc.DrawNode.CanvasRenderCmd(this)
	}
});
cc.DrawNodeWebGL = cc.Node.extend({
	_bufferCapacity: 0,
	_buffer: null,
	_trianglesArrayBuffer: null,
	_trianglesWebBuffer: null,
	_trianglesReader: null,
	_lineWidth: 1,
	_drawColor: null,
	_blendFunc: null,
	_dirty: !1,
	_className: "DrawNodeWebGL",
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(t, e) {
		void 0 === e ? (this._blendFunc.src = t.src, this._blendFunc.dst = t.dst) : (this._blendFunc.src = t, this._blendFunc.dst = e)
	},
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		this._buffer = [];
		this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
		this._drawColor = cc.color(255, 255, 255, 255);
		this.init()
	},
	init: function() {
		return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(64), this._trianglesWebBuffer = cc._renderContext.createBuffer(), this._dirty = !0) : !1
	},
	setLineWidth: function(t) {
		this._lineWidth = t
	},
	getLineWidth: function() {
		return this._lineWidth
	},
	setDrawColor: function(t) {
		var e = this._drawColor;
		e.r = t.r;
		e.g = t.g;
		e.b = t.b;
		e.a = t.a
	},
	getDrawColor: function() {
		return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
	},
	drawRect: function(t, e, i, n, r) {
		n = n || this._lineWidth;
		r = r || this.getDrawColor();
		null == r.a && (r.a = 255);
		t = [t, cc.p(e.x, t.y), e, cc.p(t.x, e.y)];
		null == i ? this._drawSegments(t, n, r, !0) : this.drawPoly(t, i, n, r)
	},
	drawCircle: function(t, e, i, n, r, c, s) {
		c = c || this._lineWidth;
		s = s || this.getDrawColor();
		null == s.a && (s.a = 255);
		var o = 2 * Math.PI / n,
			a = [],
			h;
		for (h = 0; h <= n; h++) {
			var l = h * o,
				u = e * Math.cos(l + i) + t.x,
				l = e * Math.sin(l + i) + t.y;
			a.push(cc.p(u, l))
		}
		r && a.push(cc.p(t.x, t.y));
		c *= .5;
		h = 0;
		for (t = a.length; h < t - 1; h++) this.drawSegment(a[h], a[h + 1], c, s)
	},
	drawQuadBezier: function(t, e, i, n, r, c) {
		r = r || this._lineWidth;
		c = c || this.getDrawColor();
		null == c.a && (c.a = 255);
		for (var s = [], o = 0, a = 0; a < n; a++) {
			var h = Math.pow(1 - o, 2) * t.x + 2 * (1 - o) * o * e.x + o * o * i.x,
				l = Math.pow(1 - o, 2) * t.y + 2 * (1 - o) * o * e.y + o * o * i.y;
			s.push(cc.p(h, l));
			o += 1 / n
		}
		s.push(cc.p(i.x, i.y));
		this._drawSegments(s, r, c, !1)
	},
	drawCubicBezier: function(t, e, i, n, r, c, s) {
		c = c || this._lineWidth;
		s = s || this.getDrawColor();
		null == s.a && (s.a = 255);
		for (var o = [], a = 0, h = 0; h < r; h++) {
			var l = Math.pow(1 - a, 3) * t.x + 3 * Math.pow(1 - a, 2) * a * e.x + 3 * (1 - a) * a * a * i.x + a * a * a * n.x,
				u = Math.pow(1 - a, 3) * t.y + 3 * Math.pow(1 - a, 2) * a * e.y + 3 * (1 - a) * a * a * i.y + a * a * a * n.y;
			o.push(cc.p(l, u));
			a += 1 / r
		}
		o.push(cc.p(n.x, n.y));
		this._drawSegments(o, c, s, !1)
	},
	drawCatmullRom: function(t, e, i, n) {
		this.drawCardinalSpline(t, .5, e, i, n)
	},
	drawCardinalSpline: function(t, e, i, n, r) {
		n = n || this._lineWidth;
		r = r || this.getDrawColor();
		null == r.a && (r.a = 255);
		for (var c = [], s, o, a = 1 / t.length, h = 0; h < i + 1; h++) o = h / i, 1 == o ? (s = t.length - 1, o = 1) : (s = 0 | o / a, o = (o - a * s) / a), s = cc.cardinalSplineAt(cc.getControlPointAt(t, s - 1), cc.getControlPointAt(t, s - 0), cc.getControlPointAt(t, s + 1), cc.getControlPointAt(t, s + 2), e, o), c.push(s);
		n *= .5;
		t = 0;
		for (e = c.length; t < e - 1; t++) this.drawSegment(c[t], c[t + 1], n, r)
	},
	_render: function() {
		var t = cc._renderContext;
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
		t.bindBuffer(t.ARRAY_BUFFER, this._trianglesWebBuffer);
		this._dirty && (t.bufferData(t.ARRAY_BUFFER, this._trianglesArrayBuffer, t.STREAM_DRAW), this._dirty = !1);
		var e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, e, 0);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, e, 8);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, e, 12);
		t.drawArrays(t.TRIANGLES, 0, 3 * this._buffer.length);
		cc.incrementGLDraws(1)
	},
	_ensureCapacity: function(t) {
		var e = this._buffer;
		if (e.length + t > this._bufferCapacity) {
			var i = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
			this._bufferCapacity += Math.max(this._bufferCapacity, t);
			if (null == e || 0 === e.length) this._buffer = [], this._trianglesArrayBuffer = new ArrayBuffer(i * this._bufferCapacity), this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer);
			else {
				t = [];
				for (var n = new ArrayBuffer(i * this._bufferCapacity), r = 0; r < e.length; r++) t[r] = new cc.V2F_C4B_T2F_Triangle(e[r].a, e[r].b, e[r].c, n, r * i);
				this._trianglesReader = new Uint8Array(n);
				this._trianglesArrayBuffer = n;
				this._buffer = t
			}
		}
	},
	drawDot: function(t, e, i) {
		i = i || this.getDrawColor();
		null == i.a && (i.a = 255);
		var n = {
			r: 0 | i.r,
			g: 0 | i.g,
			b: 0 | i.b,
			a: 0 | i.a
		};
		i = {
			vertices: {
				x: t.x - e,
				y: t.y - e
			},
			colors: n,
			texCoords: {
				u: -1,
				v: -1
			}
		};
		var r = {
			vertices: {
				x: t.x - e,
				y: t.y + e
			},
			colors: n,
			texCoords: {
				u: -1,
				v: 1
			}
		},
			c = {
				vertices: {
					x: t.x + e,
					y: t.y + e
				},
				colors: n,
				texCoords: {
					u: 1,
					v: 1
				}
			};
		t = {
			vertices: {
				x: t.x + e,
				y: t.y - e
			},
			colors: n,
			texCoords: {
				u: 1,
				v: -1
			}
		};
		this._ensureCapacity(6);
		this._buffer.push(new cc.V2F_C4B_T2F_Triangle(i, r, c, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
		this._buffer.push(new cc.V2F_C4B_T2F_Triangle(i, c, t, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
		this._dirty = !0
	},
	drawDots: function(t, e, i) {
		if (t && 0 != t.length) {
			i = i || this.getDrawColor();
			null == i.a && (i.a = 255);
			for (var n = 0, r = t.length; n < r; n++) this.drawDot(t[n], e, i)
		}
	},
	drawSegment: function(t, e, i, n) {
		n = n || this.getDrawColor();
		null == n.a && (n.a = 255);
		i = i || .5 * this._lineWidth;
		this._ensureCapacity(18);
		n = {
			r: 0 | n.r,
			g: 0 | n.g,
			b: 0 | n.b,
			a: 0 | n.a
		};
		var r = cc.__v2f(t),
			c = cc.__v2f(e);
		e = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(c, r)));
		t = cc.v2fperp(e);
		var s = cc.v2fmult(e, i),
			o = cc.v2fmult(t, i);
		i = cc.v2fsub(c, cc.v2fadd(s, o));
		var a = cc.v2fadd(c, cc.v2fsub(s, o)),
			h = cc.v2fsub(c, s),
			c = cc.v2fadd(c, s),
			l = cc.v2fsub(r, s),
			u = cc.v2fadd(r, s),
			d = cc.v2fsub(r, cc.v2fsub(s, o)),
			r = cc.v2fadd(r, cc.v2fadd(s, o)),
			s = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
			o = this._trianglesArrayBuffer,
			_ = this._buffer;
		_.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: i,
			colors: n,
			texCoords: cc.__t(cc.v2fneg(cc.v2fadd(e, t)))
		}, {
			vertices: a,
			colors: n,
			texCoords: cc.__t(cc.v2fsub(e, t))
		}, {
			vertices: h,
			colors: n,
			texCoords: cc.__t(cc.v2fneg(e))
		}, o, _.length * s));
		_.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: c,
			colors: n,
			texCoords: cc.__t(e)
		}, {
			vertices: a,
			colors: n,
			texCoords: cc.__t(cc.v2fsub(e, t))
		}, {
			vertices: h,
			colors: n,
			texCoords: cc.__t(cc.v2fneg(e))
		}, o, _.length * s));
		_.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: c,
			colors: n,
			texCoords: cc.__t(e)
		}, {
			vertices: l,
			colors: n,
			texCoords: cc.__t(cc.v2fneg(e))
		}, {
			vertices: h,
			colors: n,
			texCoords: cc.__t(cc.v2fneg(e))
		}, o, _.length * s));
		_.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: c,
			colors: n,
			texCoords: cc.__t(e)
		}, {
			vertices: l,
			colors: n,
			texCoords: cc.__t(cc.v2fneg(e))
		}, {
			vertices: u,
			colors: n,
			texCoords: cc.__t(e)
		}, o, _.length * s));
		_.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: d,
			colors: n,
			texCoords: cc.__t(cc.v2fsub(t, e))
		}, {
			vertices: l,
			colors: n,
			texCoords: cc.__t(cc.v2fneg(e))
		}, {
			vertices: u,
			colors: n,
			texCoords: cc.__t(e)
		}, o, _.length * s));
		_.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: d,
			colors: n,
			texCoords: cc.__t(cc.v2fsub(t, e))
		}, {
			vertices: r,
			colors: n,
			texCoords: cc.__t(cc.v2fadd(e, t))
		}, {
			vertices: u,
			colors: n,
			texCoords: cc.__t(e)
		}, o, _.length * s));
		this._dirty = !0
	},
	drawPoly: function(t, e, i, n) {
		if (null == e) this._drawSegments(t, i, n, !0);
		else {
			null == e.a && (e.a = 255);
			null == n.a && (n.a = 255);
			i = i || this._lineWidth;
			i *= .5;
			e = {
				r: 0 | e.r,
				g: 0 | e.g,
				b: 0 | e.b,
				a: 0 | e.a
			};
			n = {
				r: 0 | n.r,
				g: 0 | n.g,
				b: 0 | n.b,
				a: 0 | n.a
			};
			var r = [],
				c, s, o, a, h = t.length;
			for (c = 0; c < h; c++) {
				s = cc.__v2f(t[(c - 1 + h) % h]);
				o = cc.__v2f(t[c]);
				a = cc.__v2f(t[(c + 1) % h]);
				var l = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(o, s)));
				o = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(a, o)));
				l = cc.v2fmult(cc.v2fadd(l, o), 1 / (cc.v2fdot(l, o) + 1));
				r[c] = {
					offset: l,
					n: o
				}
			}
			l = 0 < i;
			this._ensureCapacity(3 * (3 * h - 2));
			var u = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
				d = this._trianglesArrayBuffer,
				_ = this._buffer,
				f = !1 == l ? .5 : 0;
			for (c = 0; c < h - 2; c++) s = cc.v2fsub(cc.__v2f(t[0]), cc.v2fmult(r[0].offset, f)), o = cc.v2fsub(cc.__v2f(t[c + 1]), cc.v2fmult(r[c + 1].offset, f)), a = cc.v2fsub(cc.__v2f(t[c + 2]), cc.v2fmult(r[c + 2].offset, f)), _.push(new cc.V2F_C4B_T2F_Triangle({
				vertices: s,
				colors: e,
				texCoords: cc.__t(cc.v2fzero())
			}, {
				vertices: o,
				colors: e,
				texCoords: cc.__t(cc.v2fzero())
			}, {
				vertices: a,
				colors: e,
				texCoords: cc.__t(cc.v2fzero())
			}, d, _.length * u));
			for (c = 0; c < h; c++) {
				f = (c + 1) % h;
				s = cc.__v2f(t[c]);
				o = cc.__v2f(t[f]);
				a = r[c].n;
				var p = r[c].offset,
					g = r[f].offset,
					f = l ? cc.v2fsub(s, cc.v2fmult(p, i)) : cc.v2fsub(s, cc.v2fmult(p, .5)),
					m = l ? cc.v2fsub(o, cc.v2fmult(g, i)) : cc.v2fsub(o, cc.v2fmult(g, .5));
				s = l ? cc.v2fadd(s, cc.v2fmult(p, i)) : cc.v2fadd(s, cc.v2fmult(p, .5));
				o = l ? cc.v2fadd(o, cc.v2fmult(g, i)) : cc.v2fadd(o, cc.v2fmult(g, .5));
				l ? (_.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: f,
					colors: n,
					texCoords: cc.__t(cc.v2fneg(a))
				}, {
					vertices: m,
					colors: n,
					texCoords: cc.__t(cc.v2fneg(a))
				}, {
					vertices: o,
					colors: n,
					texCoords: cc.__t(a)
				}, d, _.length * u)), _.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: f,
					colors: n,
					texCoords: cc.__t(cc.v2fneg(a))
				}, {
					vertices: s,
					colors: n,
					texCoords: cc.__t(a)
				}, {
					vertices: o,
					colors: n,
					texCoords: cc.__t(a)
				}, d, _.length * u))) : (_.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: f,
					colors: e,
					texCoords: cc.__t(cc.v2fzero())
				}, {
					vertices: m,
					colors: e,
					texCoords: cc.__t(cc.v2fzero())
				}, {
					vertices: o,
					colors: e,
					texCoords: cc.__t(a)
				}, d, _.length * u)), _.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: f,
					colors: e,
					texCoords: cc.__t(cc.v2fzero())
				}, {
					vertices: s,
					colors: e,
					texCoords: cc.__t(a)
				}, {
					vertices: o,
					colors: e,
					texCoords: cc.__t(a)
				}, d, _.length * u)))
			}
			this._dirty = !0
		}
	},
	_drawSegments: function(t, e, i, n) {
		e = e || this._lineWidth;
		i = i || this._drawColor;
		null == i.a && (i.a = 255);
		e *= .5;
		if (!(0 >= e)) {
			i = {
				r: 0 | i.r,
				g: 0 | i.g,
				b: 0 | i.b,
				a: 0 | i.a
			};
			var r = [],
				c, s, o, a, h = t.length;
			for (c = 0; c < h; c++) {
				s = cc.__v2f(t[(c - 1 + h) % h]);
				o = cc.__v2f(t[c]);
				a = cc.__v2f(t[(c + 1) % h]);
				var l = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(o, s)));
				o = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(a, o)));
				a = cc.v2fmult(cc.v2fadd(l, o), 1 / (cc.v2fdot(l, o) + 1));
				r[c] = {
					offset: a,
					n: o
				}
			}
			this._ensureCapacity(3 * (3 * h - 2));
			a = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
			var l = this._trianglesArrayBuffer,
				u = this._buffer;
			n = n ? h : h - 1;
			for (c = 0; c < n; c++) {
				var d = (c + 1) % h;
				s = cc.__v2f(t[c]);
				o = cc.__v2f(t[d]);
				var _ = r[c].n,
					f = r[c].offset,
					p = r[d].offset,
					d = cc.v2fsub(s, cc.v2fmult(f, e)),
					g = cc.v2fsub(o, cc.v2fmult(p, e));
				s = cc.v2fadd(s, cc.v2fmult(f, e));
				o = cc.v2fadd(o, cc.v2fmult(p, e));
				u.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: d,
					colors: i,
					texCoords: cc.__t(cc.v2fneg(_))
				}, {
					vertices: g,
					colors: i,
					texCoords: cc.__t(cc.v2fneg(_))
				}, {
					vertices: o,
					colors: i,
					texCoords: cc.__t(_)
				}, l, u.length * a));
				u.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: d,
					colors: i,
					texCoords: cc.__t(cc.v2fneg(_))
				}, {
					vertices: s,
					colors: i,
					texCoords: cc.__t(_)
				}, {
					vertices: o,
					colors: i,
					texCoords: cc.__t(_)
				}, l, u.length * a))
			}
			this._dirty = !0
		}
	},
	clear: function() {
		this._buffer.length = 0;
		this._dirty = !0
	},
	_createRenderCmd: function() {
		return new cc.DrawNode.WebGLRenderCmd(this)
	}
});
cc.DrawNode = cc._renderType == cc._RENDER_TYPE_WEBGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas;
cc.DrawNode.create = function() {
	return new cc.DrawNode
};
cc._DrawNodeElement = function(t, e, i, n, r, c, s, o, a) {
	this.type = t;
	this.verts = e || null;
	this.fillColor = i || null;
	this.lineWidth = n || 0;
	this.lineColor = r || null;
	this.lineCap = c || "butt";
	this.isClosePolygon = s || !1;
	this.isFill = o || !1;
	this.isStroke = a || !1
};
cc.DrawNode.TYPE_DOT = 0;
cc.DrawNode.TYPE_SEGMENT = 1;
cc.DrawNode.TYPE_POLY = 2;
(function() {
	cc.DrawNode.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._needDraw = !0;
		this._blendFunc = this._drawColor = this._buffer = null
	};
	cc.DrawNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	cc.DrawNode.CanvasRenderCmd.prototype.constructor = cc.DrawNode.CanvasRenderCmd;
	cc.DrawNode.CanvasRenderCmd.prototype.rendering = function(t, e, i) {
		var n = t || cc._renderContext,
			r = this._node._displayedOpacity / 255;
		if (0 !== r) {
			n.globalAlpha = r;
			r = this._worldTransform;
			n.save();
			t.transform(r.a, r.c, r.b, r.d, r.tx * e, -r.ty * i);
			this._blendFunc && (this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE) && (n.globalCompositeOperation = "lighter");
			t = this._buffer;
			for (var r = 0, c = t.length; r < c; r++) {
				var s = t[r];
				switch (s.type) {
				case cc.DrawNode.TYPE_DOT:
					this._drawDot(n, s, e, i);
					break;
				case cc.DrawNode.TYPE_SEGMENT:
					this._drawSegment(n, s, e, i);
					break;
				case cc.DrawNode.TYPE_POLY:
					this._drawPoly(n, s, e, i)
				}
			}
			n.restore()
		}
	};
	cc.DrawNode.CanvasRenderCmd.prototype._drawDot = function(t, e, i, n) {
		var r = e.fillColor,
			c = e.verts[0];
		e = e.lineWidth;
		t.fillStyle = "rgba(" + (0 | r.r) + "," + (0 | r.g) + "," + (0 | r.b) + "," + r.a / 255 + ")";
		t.beginPath();
		t.arc(c.x * i, -c.y * n, e * i, 0, 2 * Math.PI, !1);
		t.closePath();
		t.fill()
	};
	cc.DrawNode.CanvasRenderCmd.prototype._drawSegment = function(t, e, i, n) {
		var r = e.lineColor,
			c = e.verts[0],
			s = e.verts[1],
			o = e.lineWidth;
		e = e.lineCap;
		t.strokeStyle = "rgba(" + (0 | r.r) + "," + (0 | r.g) + "," + (0 | r.b) + "," + r.a / 255 + ")";
		t.lineWidth = o * i;
		t.beginPath();
		t.lineCap = e;
		t.moveTo(c.x * i, -c.y * n);
		t.lineTo(s.x * i, -s.y * n);
		t.stroke()
	};
	cc.DrawNode.CanvasRenderCmd.prototype._drawPoly = function(t, e, i, n) {
		var r = e.verts,
			c = e.lineCap,
			s = e.fillColor,
			o = e.lineWidth,
			a = e.lineColor,
			h = e.isClosePolygon,
			l = e.isFill;
		e = e.isStroke;
		if (null != r) {
			var u = r[0];
			t.lineCap = c;
			s && (t.fillStyle = "rgba(" + (0 | s.r) + "," + (0 | s.g) + "," + (0 | s.b) + "," + s.a / 255 + ")");
			o && (t.lineWidth = o * i);
			a && (t.strokeStyle = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")");
			t.beginPath();
			t.moveTo(u.x * i, -u.y * n);
			c = 1;
			for (s = r.length; c < s; c++) t.lineTo(r[c].x * i, -r[c].y * n);
			h && t.closePath();
			l && t.fill();
			e && t.stroke()
		}
	}
})();
(function() {
	cc.DrawNode.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !0
	};
	cc.DrawNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd;
	cc.DrawNode.WebGLRenderCmd.prototype.rendering = function(t) {
		t = this._node;
		cc.glBlendFunc(t._blendFunc.src, t._blendFunc.dst);
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		t._render()
	}
})();
cc.stencilBits = -1;
cc.ClippingNode = cc.Node.extend({
	alphaThreshold: 0,
	inverted: !1,
	_stencil: null,
	_className: "ClippingNode",
	ctor: function(t) {
		t = t || null;
		cc.Node.prototype.ctor.call(this);
		this._stencil = t;
		this.alphaThreshold = 1;
		this.inverted = !1;
		this._renderCmd.initStencilBits()
	},
	init: function(t) {
		this._stencil = t;
		this.alphaThreshold = 1;
		this.inverted = !1;
		this._renderCmd.initStencilBits();
		return !0
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this._stencil.onEnter()
	},
	onEnterTransitionDidFinish: function() {
		cc.Node.prototype.onEnterTransitionDidFinish.call(this);
		this._stencil.onEnterTransitionDidFinish()
	},
	onExitTransitionDidStart: function() {
		this._stencil.onExitTransitionDidStart();
		cc.Node.prototype.onExitTransitionDidStart.call(this)
	},
	onExit: function() {
		this._stencil.onExit();
		cc.Node.prototype.onExit.call(this)
	},
	getAlphaThreshold: function() {
		return this.alphaThreshold
	},
	setAlphaThreshold: function(t) {
		this.alphaThreshold = t
	},
	isInverted: function() {
		return this.inverted
	},
	setInverted: function(t) {
		this.inverted = t
	},
	getStencil: function() {
		return this._stencil
	},
	setStencil: function(t) {
		this._stencil != t && this._renderCmd.setStencil(t)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this)
	}
});
_p = cc.ClippingNode.prototype;
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
cc.ClippingNode.create = function(t) {
	return new cc.ClippingNode(t)
};
(function() {
	cc.ClippingNode.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._godhelpme = this._needDraw = !1;
		this._clipElemType = null;
		this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._saveCmdCallback);
		this._rendererClipCmd = new cc.CustomRenderCmd(this, this._clipCmdCallback);
		this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback)
	};
	var t = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.ClippingNode.CanvasRenderCmd;
	t.initStencilBits = function() {};
	t.setStencil = function(t) {
		if (null != t && (this._node._stencil = t, t instanceof cc.DrawNode)) {
			if (t._buffer) for (var e = 0; e < t._buffer.length; e++) t._buffer[e].isFill = !1, t._buffer[e].isStroke = !1;
			t._renderCmd.rendering = function(e, i, n) {
				i = i || cc.view.getScaleX();
				n = n || cc.view.getScaleY();
				e = e || cc._renderContext;
				var r = this._worldTransform;
				e.save();
				e.transform(r.a, r.b, r.c, r.d, r.tx * i, -r.ty * n);
				e.beginPath();
				for (r = 0; r < t._buffer.length; r++) {
					var c = t._buffer[r].verts,
						s = c[0];
					e.moveTo(s.x * i, -s.y * n);
					for (var s = 1, o = c.length; s < o; s++) e.lineTo(c[s].x * i, -c[s].y * n)
				}
				e.restore()
			}
		}
	};
	t._saveCmdCallback = function(t, e, i) {
		t = t || cc._renderContext;
		if (this._clipElemType) e = cc.ClippingNode.CanvasRenderCmd._getSharedCache(), i = t.canvas, e.width = i.width, e.height = i.height, e.getContext("2d").drawImage(i, 0, 0), t.save();
		else {
			this._syncStatus(this.getParentRenderCmd());
			var n = this._worldTransform;
			t.save();
			t.save();
			t.transform(n.a, n.c, n.b, n.d, n.tx * e, -n.ty * i)
		}
	};
	t._clipCmdCallback = function(t, e, i) {
		var n = this._node;
		t = t || cc._renderContext;
		this._clipElemType ? (t.globalCompositeOperation = n.inverted ? "destination-out" : "destination-in", n = this._worldTransform, t.transform(n.a, n.c, n.b, n.d, n.tx * e, -n.ty * i)) : (t.restore(), n.inverted && (e = t.canvas, t.save(), t.setTransform(1, 0, 0, 1, 0, 0), t.moveTo(0, 0), t.lineTo(0, e.height), t.lineTo(e.width, e.height), t.lineTo(e.width, 0), t.lineTo(0, 0), t.restore()), t.clip())
	};
	t._restoreCmdCallback = function(t) {
		var e = cc.ClippingNode.CanvasRenderCmd._getSharedCache();
		t = t || cc._renderContext;
		this._clipElemType ? (t.restore(), t.save(), t.setTransform(1, 0, 0, 1, 0, 0), t.globalCompositeOperation = "destination-over", t.drawImage(e, 0, 0), t.restore(), this._dirtyFlag = 0) : t.restore()
	};
	t.transform = function(t, e) {
		cc.Node.CanvasRenderCmd.prototype.transform.call(this, t, e);
		this._stencil && this._stencil._renderCmd.transform(t, e)
	};
	t._cangodhelpme = function(t) {
		if (!0 === t || !1 === t) cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme = t;
		return cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme
	};
	t.visit = function(t) {
		cc.renderer.pushRenderCommand(this);
		var e = this._node,
			i = e._stencil instanceof cc.Sprite ? this : null;
		if (e._visible) {
			if (t = t || this.getParentRenderCmd()) this._curLevel = t._curLevel + 1;
			this._clipElemType = this._cangodhelpme() || e._stencil instanceof cc.Sprite;
			var n = e._children;
			if (!e._stencil || !e._stencil.visible) this.inverted && cc.Node.CanvasRenderCmd.prototype.visit.call(this, t);
			else {
				cc.renderer.pushRenderCommand(this._rendererSaveCmd);
				this._clipElemType ? cc.Node.CanvasRenderCmd.prototype.visit.call(this, t) : e._stencil.visit(i);
				cc.renderer.pushRenderCommand(this._rendererClipCmd);
				this._syncStatus(t);
				if (this._clipElemType) e._stencil.visit(i);
				else {
					this._cangodhelpme(!0);
					t = n.length;
					if (0 < t) {
						e.sortAllChildren();
						for (e = 0; e < t; e++) n[e]._renderCmd.visit(this)
					}
					this._cangodhelpme(!1)
				}
				cc.renderer.pushRenderCommand(this._rendererRestoreCmd);
				this._dirtyFlag = 0
			}
		}
	};
	cc.ClippingNode.CanvasRenderCmd._sharedCache = null;
	cc.ClippingNode.CanvasRenderCmd._getSharedCache = function() {
		return cc.ClippingNode.CanvasRenderCmd._sharedCache || (cc.ClippingNode.CanvasRenderCmd._sharedCache = document.createElement("canvas"))
	}
})();
(function() {
	cc.ClippingNode.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !1;
		this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
		this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
		this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
		this._mask_layer_le = this._currentDepthWriteMask = this._currentStencilEnabled = this._currentStencilWriteMask = this._currentStencilPassDepthPass = this._currentStencilPassDepthFail = this._currentStencilFail = this._currentStencilValueMask = this._currentStencilRef = this._currentStencilFunc = null
	};
	var t = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.ClippingNode.WebGLRenderCmd;
	cc.ClippingNode.WebGLRenderCmd._init_once = null;
	cc.ClippingNode.WebGLRenderCmd._visit_once = null;
	cc.ClippingNode.WebGLRenderCmd._layer = -1;
	t.initStencilBits = function() {
		cc.ClippingNode.WebGLRenderCmd._init_once = !0;
		cc.ClippingNode.WebGLRenderCmd._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), 0 >= cc.stencilBits && cc.log("Stencil buffer is not enabled."), cc.ClippingNode.WebGLRenderCmd._init_once = !1)
	};
	t.transform = function(t, e) {
		var i = this._node;
		cc.Node.WebGLRenderCmd.prototype.transform.call(this, t, e);
		i._stencil && i._stencil._renderCmd.transform(this, e)
	};
	t.visit = function(t) {
		var e = this._node;
		if (e._visible) if (e._parent && e._parent._renderCmd && (this._curLevel = e._parent._renderCmd._curLevel + 1), 1 > cc.stencilBits) cc.Node.WebGLRenderCmd.prototype.visit.call(this, t);
		else if (!e._stencil || !e._stencil.visible) e.inverted && cc.Node.WebGLRenderCmd.prototype.visit.call(this, t);
		else if (cc.ClippingNode.WebGLRenderCmd._layer + 1 == cc.stencilBits) cc.ClippingNode.WebGLRenderCmd._visit_once = !0, cc.ClippingNode.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its children."), cc.ClippingNode.WebGLRenderCmd._visit_once = !1), cc.Node.WebGLRenderCmd.prototype.visit.call(this, t);
		else {
			cc.renderer.pushRenderCommand(this._beforeVisitCmd);
			var i = cc.current_stack;
			i.stack.push(i.top);
			this._syncStatus(t);
			i.top = this._stackMatrix;
			e._stencil._renderCmd.visit(this);
			cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
			if ((t = e._children) && 0 < t.length) {
				var n = t.length;
				e.sortAllChildren();
				for (e = 0; e < n; e++) t[e]._renderCmd.visit(this)
			}
			cc.renderer.pushRenderCommand(this._afterVisitCmd);
			this._dirtyFlag = 0;
			i.top = i.stack.pop()
		}
	};
	t.setStencil = function(t) {
		var e = this._node;
		e._stencil && (e._stencil._parent = null);
		e._stencil = t;
		e._stencil && (e._stencil._parent = e)
	};
	t._drawFullScreenQuadClearStencil = function() {
		cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
		cc.kmGLPushMatrix();
		cc.kmGLLoadIdentity();
		cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
		cc.kmGLPushMatrix();
		cc.kmGLLoadIdentity();
		cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
		cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
		cc.kmGLPopMatrix();
		cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
		cc.kmGLPopMatrix()
	};
	t._onBeforeVisit = function(t) {
		var e = t || cc._renderContext;
		t = this._node;
		cc.ClippingNode.WebGLRenderCmd._layer++;
		var i = 1 << cc.ClippingNode.WebGLRenderCmd._layer;
		this._mask_layer_le = i | i - 1;
		this._currentStencilEnabled = e.isEnabled(e.STENCIL_TEST);
		this._currentStencilWriteMask = e.getParameter(e.STENCIL_WRITEMASK);
		this._currentStencilFunc = e.getParameter(e.STENCIL_FUNC);
		this._currentStencilRef = e.getParameter(e.STENCIL_REF);
		this._currentStencilValueMask = e.getParameter(e.STENCIL_VALUE_MASK);
		this._currentStencilFail = e.getParameter(e.STENCIL_FAIL);
		this._currentStencilPassDepthFail = e.getParameter(e.STENCIL_PASS_DEPTH_FAIL);
		this._currentStencilPassDepthPass = e.getParameter(e.STENCIL_PASS_DEPTH_PASS);
		e.enable(e.STENCIL_TEST);
		e.stencilMask(i);
		this._currentDepthWriteMask = e.getParameter(e.DEPTH_WRITEMASK);
		e.depthMask(!1);
		e.stencilFunc(e.NEVER, i, i);
		e.stencilOp(!t.inverted ? e.ZERO : e.REPLACE, e.KEEP, e.KEEP);
		this._drawFullScreenQuadClearStencil();
		e.stencilFunc(e.NEVER, i, i);
		e.stencilOp(!t.inverted ? e.REPLACE : e.ZERO, e.KEEP, e.KEEP);
		1 > t.alphaThreshold && (i = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), e = e.getUniformLocation(i.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), cc.glUseProgram(i.getProgram()), i.setUniformLocationWith1f(e, t.alphaThreshold), cc.setProgram(t._stencil, i))
	};
	t._onAfterDrawStencil = function(t) {
		t = t || cc._renderContext;
		t.depthMask(this._currentDepthWriteMask);
		t.stencilFunc(t.EQUAL, this._mask_layer_le, this._mask_layer_le);
		t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
	};
	t._onAfterVisit = function(t) {
		t = t || cc._renderContext;
		t.stencilFunc(this._currentStencilFunc, this._currentStencilRef, this._currentStencilValueMask);
		t.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass);
		t.stencilMask(this._currentStencilWriteMask);
		this._currentStencilEnabled || t.disable(t.STENCIL_TEST);
		cc.ClippingNode.WebGLRenderCmd._layer--
	}
})();
cc.GridBase = cc.Class.extend({
	_active: !1,
	_reuseGrid: 0,
	_gridSize: null,
	_texture: null,
	_step: null,
	_grabber: null,
	_isTextureFlipped: !1,
	_shaderProgram: null,
	_directorProjection: 0,
	_dirty: !1,
	ctor: function(t, e, i) {
		cc._checkWebGLRenderMode();
		this._active = !1;
		this._reuseGrid = 0;
		this._texture = this._gridSize = null;
		this._step = cc.p(0, 0);
		this._grabber = null;
		this._isTextureFlipped = !1;
		this._shaderProgram = null;
		this._directorProjection = 0;
		this._dirty = !1;
		void 0 !== t && this.initWithSize(t, e, i)
	},
	isActive: function() {
		return this._active
	},
	setActive: function(t) {
		this._active = t;
		if (!t) {
			t = cc.director;
			var e = t.getProjection();
			t.setProjection(e)
		}
	},
	getReuseGrid: function() {
		return this._reuseGrid
	},
	setReuseGrid: function(t) {
		this._reuseGrid = t
	},
	getGridSize: function() {
		return cc.size(this._gridSize.width, this._gridSize.height)
	},
	setGridSize: function(t) {
		this._gridSize.width = parseInt(t.width);
		this._gridSize.height = parseInt(t.height)
	},
	getStep: function() {
		return cc.p(this._step.x, this._step.y)
	},
	setStep: function(t) {
		this._step.x = t.x;
		this._step.y = t.y
	},
	isTextureFlipped: function() {
		return this._isTextureFlipped
	},
	setTextureFlipped: function(t) {
		this._isTextureFlipped != t && (this._isTextureFlipped = t, this.calculateVertexPoints())
	},
	initWithSize: function(t, e, i) {
		if (!e) {
			var n = cc.director.getWinSizeInPixels(),
				r = cc.NextPOT(n.width),
				c = cc.NextPOT(n.height),
				s = new Uint8Array(4 * r * c);
			if (!s) return cc.log("cocos2d: CCGrid: not enough memory."), !1;
			e = new cc.Texture2D;
			e.initWithData(s, cc.Texture2D.PIXEL_FORMAT_RGBA8888, r, c, n);
			if (!e) return cc.log("cocos2d: CCGrid: error creating texture"), !1
		}
		this._active = !1;
		this._reuseGrid = 0;
		this._gridSize = t;
		this._texture = e;
		this._isTextureFlipped = i || !1;
		this._step.x = this._texture.width / t.width;
		this._step.y = this._texture.height / t.height;
		this._grabber = new cc.Grabber;
		if (!this._grabber) return !1;
		this._grabber.grab(this._texture);
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
		this.calculateVertexPoints();
		return !0
	},
	beforeDraw: function() {
		this._directorProjection = cc.director.getProjection();
		this._grabber.beforeRender(this._texture)
	},
	afterDraw: function(t) {
		this._grabber.afterRender(this._texture);
		if (t && t.getCamera().isDirty()) {
			var e = t.getAnchorPointInPoints(),
				i = t._renderCmd._stackMatrix,
				n = new cc.kmMat4;
			cc.kmMat4Translation(n, e.x, e.y, 0);
			cc.kmMat4Multiply(i, i, n);
			t._camera._locateForRenderer(i);
			cc.kmMat4Translation(n, -e.x, -e.y, 0);
			cc.kmMat4Multiply(i, i, n)
		}
		cc.glBindTexture2D(this._texture);
		this.blit(t)
	},
	blit: function() {
		cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
	},
	reuse: function() {
		cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
	},
	calculateVertexPoints: function() {
		cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
	},
	set2DProjection: function() {
		var t = cc.director.getWinSizeInPixels();
		cc._renderContext.viewport(0, 0, t.width, t.height);
		cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
		cc.kmGLLoadIdentity();
		var e = new cc.kmMat4;
		cc.kmMat4OrthographicProjection(e, 0, t.width, 0, t.height, -1, 1);
		cc.kmGLMultMatrix(e);
		cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
		cc.kmGLLoadIdentity();
		cc.setProjectionMatrixDirty()
	}
});
cc.GridBase.create = function(t, e, i) {
	return new cc.GridBase(t, e, i)
};
cc.Grid3D = cc.GridBase.extend({
	_texCoordinates: null,
	_vertices: null,
	_originalVertices: null,
	_indices: null,
	_texCoordinateBuffer: null,
	_verticesBuffer: null,
	_indicesBuffer: null,
	ctor: function(t, e, i) {
		cc.GridBase.prototype.ctor.call(this);
		this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
		void 0 !== t && this.initWithSize(t, e, i)
	},
	vertex: function(t) {
		(t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.Grid3D.vertex() : Numbers must be integers");
		t = 0 | 3 * (t.x * (this._gridSize.height + 1) + t.y);
		var e = this._vertices;
		return new cc.Vertex3F(e[t], e[t + 1], e[t + 2])
	},
	originalVertex: function(t) {
		(t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
		t = 0 | 3 * (t.x * (this._gridSize.height + 1) + t.y);
		var e = this._originalVertices;
		return new cc.Vertex3F(e[t], e[t + 1], e[t + 2])
	},
	setVertex: function(t, e) {
		(t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
		var i = 0 | 3 * (t.x * (this._gridSize.height + 1) + t.y),
			n = this._vertices;
		n[i] = e.x;
		n[i + 1] = e.y;
		n[i + 2] = e.z;
		this._dirty = !0
	},
	blit: function(t) {
		var e = this._gridSize.width * this._gridSize.height;
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(t._renderCmd._stackMatrix);
		t = cc._renderContext;
		var i = this._dirty;
		t.bindBuffer(t.ARRAY_BUFFER, this._verticesBuffer);
		i && t.bufferData(t.ARRAY_BUFFER, this._vertices, t.DYNAMIC_DRAW);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, t.FLOAT, !1, 0, 0);
		t.bindBuffer(t.ARRAY_BUFFER, this._texCoordinateBuffer);
		i && t.bufferData(t.ARRAY_BUFFER, this._texCoordinates, t.DYNAMIC_DRAW);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, 0, 0);
		t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
		i && t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW);
		t.drawElements(t.TRIANGLES, 6 * e, t.UNSIGNED_SHORT, 0);
		i && (this._dirty = !1);
		cc.incrementGLDraws(1)
	},
	reuse: function() {
		if (0 < this._reuseGrid) {
			for (var t = this._originalVertices, e = this._vertices, i = 0, n = this._vertices.length; i < n; i++) t[i] = e[i];
			--this._reuseGrid
		}
	},
	calculateVertexPoints: function() {
		var t = cc._renderContext,
			e = this._texture.pixelsWidth,
			i = this._texture.pixelsHeight,
			n = this._texture.getContentSizeInPixels().height,
			r = this._gridSize,
			c = (r.width + 1) * (r.height + 1);
		this._vertices = new Float32Array(3 * c);
		this._texCoordinates = new Float32Array(2 * c);
		this._indices = new Uint16Array(6 * r.width * r.height);
		this._verticesBuffer && t.deleteBuffer(this._verticesBuffer);
		this._verticesBuffer = t.createBuffer();
		this._texCoordinateBuffer && t.deleteBuffer(this._texCoordinateBuffer);
		this._texCoordinateBuffer = t.createBuffer();
		this._indicesBuffer && t.deleteBuffer(this._indicesBuffer);
		this._indicesBuffer = t.createBuffer();
		for (var s, o, a = this._indices, h = this._texCoordinates, l = this._isTextureFlipped, u = this._vertices, c = 0; c < r.width; ++c) for (s = 0; s < r.height; ++s) {
			var d = s * r.width + c;
			o = c * this._step.x;
			var _ = o + this._step.x,
				f = s * this._step.y,
				p = f + this._step.y,
				g = c * (r.height + 1) + s,
				m = (c + 1) * (r.height + 1) + s,
				T = (c + 1) * (r.height + 1) + (s + 1),
				y = c * (r.height + 1) + (s + 1);
			a[6 * d] = g;
			a[6 * d + 1] = m;
			a[6 * d + 2] = y;
			a[6 * d + 3] = m;
			a[6 * d + 4] = T;
			a[6 * d + 5] = y;
			var d = [3 * g, 3 * m, 3 * T, 3 * y],
				v = [{
					x: o,
					y: f,
					z: 0
				}, {
					x: _,
					y: f,
					z: 0
				}, {
					x: _,
					y: p,
					z: 0
				}, {
					x: o,
					y: p,
					z: 0
				}],
				g = [2 * g, 2 * m, 2 * T, 2 * y],
				_ = [cc.p(o, f), cc.p(_, f), cc.p(_, p), cc.p(o, p)];
			for (o = 0; 4 > o; ++o) u[d[o]] = v[o].x, u[d[o] + 1] = v[o].y, u[d[o] + 2] = v[o].z, h[g[o]] = _[o].x / e, h[g[o] + 1] = l ? (n - _[o].y) / i : _[o].y / i
		}
		this._originalVertices = new Float32Array(this._vertices);
		t.bindBuffer(t.ARRAY_BUFFER, this._verticesBuffer);
		t.bufferData(t.ARRAY_BUFFER, this._vertices, t.DYNAMIC_DRAW);
		t.bindBuffer(t.ARRAY_BUFFER, this._texCoordinateBuffer);
		t.bufferData(t.ARRAY_BUFFER, this._texCoordinates, t.DYNAMIC_DRAW);
		t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
		t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW);
		this._dirty = !0
	}
});
cc.Grid3D.create = function(t, e, i) {
	return new cc.Grid3D(t, e, i)
};
cc.TiledGrid3D = cc.GridBase.extend({
	_texCoordinates: null,
	_vertices: null,
	_originalVertices: null,
	_indices: null,
	_texCoordinateBuffer: null,
	_verticesBuffer: null,
	_indicesBuffer: null,
	ctor: function(t, e, i) {
		cc.GridBase.prototype.ctor.call(this);
		this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
		void 0 !== t && this.initWithSize(t, e, i)
	},
	tile: function(t) {
		(t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
		t = 12 * (this._gridSize.height * t.x + t.y);
		var e = this._vertices;
		return new cc.Quad3(new cc.Vertex3F(e[t], e[t + 1], e[t + 2]), new cc.Vertex3F(e[t + 3], e[t + 4], e[t + 5]), new cc.Vertex3F(e[t + 6], e[t + 7], e[t + 8]), new cc.Vertex3F(e[t + 9], e[t + 10], e[t + 11]))
	},
	originalTile: function(t) {
		(t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
		t = 12 * (this._gridSize.height * t.x + t.y);
		var e = this._originalVertices;
		return new cc.Quad3(new cc.Vertex3F(e[t], e[t + 1], e[t + 2]), new cc.Vertex3F(e[t + 3], e[t + 4], e[t + 5]), new cc.Vertex3F(e[t + 6], e[t + 7], e[t + 8]), new cc.Vertex3F(e[t + 9], e[t + 10], e[t + 11]))
	},
	setTile: function(t, e) {
		(t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
		var i = 12 * (this._gridSize.height * t.x + t.y),
			n = this._vertices;
		n[i] = e.bl.x;
		n[i + 1] = e.bl.y;
		n[i + 2] = e.bl.z;
		n[i + 3] = e.br.x;
		n[i + 4] = e.br.y;
		n[i + 5] = e.br.z;
		n[i + 6] = e.tl.x;
		n[i + 7] = e.tl.y;
		n[i + 8] = e.tl.z;
		n[i + 9] = e.tr.x;
		n[i + 10] = e.tr.y;
		n[i + 11] = e.tr.z;
		this._dirty = !0
	},
	blit: function(t) {
		var e = this._gridSize.width * this._gridSize.height;
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(t._renderCmd._stackMatrix);
		t = cc._renderContext;
		var i = this._dirty;
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
		t.bindBuffer(t.ARRAY_BUFFER, this._verticesBuffer);
		i && t.bufferData(t.ARRAY_BUFFER, this._vertices, t.DYNAMIC_DRAW);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, t.FLOAT, !1, 0, this._vertices);
		t.bindBuffer(t.ARRAY_BUFFER, this._texCoordinateBuffer);
		i && t.bufferData(t.ARRAY_BUFFER, this._texCoordinates, t.DYNAMIC_DRAW);
		t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, 0, this._texCoordinates);
		t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
		i && t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW);
		t.drawElements(t.TRIANGLES, 6 * e, t.UNSIGNED_SHORT, 0);
		i && (this._dirty = !1);
		cc.incrementGLDraws(1)
	},
	reuse: function() {
		if (0 < this._reuseGrid) {
			for (var t = this._vertices, e = this._originalVertices, i = 0; i < t.length; i++) e[i] = t[i];
			--this._reuseGrid
		}
	},
	calculateVertexPoints: function() {
		var t = this._texture.pixelsWidth,
			e = this._texture.pixelsHeight,
			i = this._texture.getContentSizeInPixels().height,
			n = this._gridSize,
			r = n.width * n.height;
		this._vertices = new Float32Array(12 * r);
		this._texCoordinates = new Float32Array(8 * r);
		this._indices = new Uint16Array(6 * r);
		var c = cc._renderContext;
		this._verticesBuffer && c.deleteBuffer(this._verticesBuffer);
		this._verticesBuffer = c.createBuffer();
		this._texCoordinateBuffer && c.deleteBuffer(this._texCoordinateBuffer);
		this._texCoordinateBuffer = c.createBuffer();
		this._indicesBuffer && c.deleteBuffer(this._indicesBuffer);
		this._indicesBuffer = c.createBuffer();
		var s, o, a = 0,
			h = this._step,
			l = this._vertices,
			u = this._texCoordinates,
			d = this._isTextureFlipped;
		for (s = 0; s < n.width; s++) for (o = 0; o < n.height; o++) {
			var _ = s * h.x,
				f = _ + h.x,
				p = o * h.y,
				g = p + h.y;
			l[12 * a] = _;
			l[12 * a + 1] = p;
			l[12 * a + 2] = 0;
			l[12 * a + 3] = f;
			l[12 * a + 4] = p;
			l[12 * a + 5] = 0;
			l[12 * a + 6] = _;
			l[12 * a + 7] = g;
			l[12 * a + 8] = 0;
			l[12 * a + 9] = f;
			l[12 * a + 10] = g;
			l[12 * a + 11] = 0;
			var m = p,
				T = g;
			d && (m = i - p, T = i - g);
			u[8 * a] = _ / t;
			u[8 * a + 1] = m / e;
			u[8 * a + 2] = f / t;
			u[8 * a + 3] = m / e;
			u[8 * a + 4] = _ / t;
			u[8 * a + 5] = T / e;
			u[8 * a + 6] = f / t;
			u[8 * a + 7] = T / e;
			a++
		}
		t = this._indices;
		for (s = 0; s < r; s++) t[6 * s + 0] = 4 * s + 0, t[6 * s + 1] = 4 * s + 1, t[6 * s + 2] = 4 * s + 2, t[6 * s + 3] = 4 * s + 1, t[6 * s + 4] = 4 * s + 2, t[6 * s + 5] = 4 * s + 3;
		this._originalVertices = new Float32Array(this._vertices);
		c.bindBuffer(c.ARRAY_BUFFER, this._verticesBuffer);
		c.bufferData(c.ARRAY_BUFFER, this._vertices, c.DYNAMIC_DRAW);
		c.bindBuffer(c.ARRAY_BUFFER, this._texCoordinateBuffer);
		c.bufferData(c.ARRAY_BUFFER, this._texCoordinates, c.DYNAMIC_DRAW);
		c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
		c.bufferData(c.ELEMENT_ARRAY_BUFFER, this._indices, c.DYNAMIC_DRAW);
		this._dirty = !0
	}
});
cc.TiledGrid3D.create = function(t, e, i) {
	return new cc.TiledGrid3D(t, e, i)
};
cc.Grabber = cc.Class.extend({
	_FBO: null,
	_oldFBO: null,
	_oldClearColor: null,
	_gl: null,
	ctor: function() {
		cc._checkWebGLRenderMode();
		this._gl = cc._renderContext;
		this._oldClearColor = [0, 0, 0, 0];
		this._oldFBO = null;
		this._FBO = this._gl.createFramebuffer()
	},
	grab: function(t) {
		var e = this._gl;
		this._oldFBO = e.getParameter(e.FRAMEBUFFER_BINDING);
		e.bindFramebuffer(e.FRAMEBUFFER, this._FBO);
		e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t._webTextureObj, 0);
		e.checkFramebufferStatus(e.FRAMEBUFFER) != e.FRAMEBUFFER_COMPLETE && cc.log("Frame Grabber: could not attach texture to frmaebuffer");
		e.bindFramebuffer(e.FRAMEBUFFER, this._oldFBO)
	},
	beforeRender: function(t) {
		t = this._gl;
		this._oldFBO = t.getParameter(t.FRAMEBUFFER_BINDING);
		t.bindFramebuffer(t.FRAMEBUFFER, this._FBO);
		this._oldClearColor = t.getParameter(t.COLOR_CLEAR_VALUE);
		t.clearColor(0, 0, 0, 0);
		t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT)
	},
	afterRender: function(t) {
		t = this._gl;
		t.bindFramebuffer(t.FRAMEBUFFER, this._oldFBO);
		t.colorMask(!0, !0, !0, !0)
	},
	destroy: function() {
		this._gl.deleteFramebuffer(this._FBO)
	}
});
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
	originalTarget: null,
	target: null,
	tag: cc.ACTION_TAG_INVALID,
	ctor: function() {
		this.target = this.originalTarget = null;
		this.tag = cc.ACTION_TAG_INVALID
	},
	copy: function() {
		cc.log("copy is deprecated. Please use clone instead.");
		return this.clone()
	},
	clone: function() {
		var t = new cc.Action;
		t.originalTarget = null;
		t.target = null;
		t.tag = this.tag;
		return t
	},
	isDone: function() {
		return !0
	},
	startWithTarget: function(t) {
		this.target = this.originalTarget = t
	},
	stop: function() {
		this.target = null
	},
	step: function(t) {
		cc.log("[Action step]. override me")
	},
	update: function(t) {
		cc.log("[Action update]. override me")
	},
	getTarget: function() {
		return this.target
	},
	setTarget: function(t) {
		this.target = t
	},
	getOriginalTarget: function() {
		return this.originalTarget
	},
	setOriginalTarget: function(t) {
		this.originalTarget = t
	},
	getTag: function() {
		return this.tag
	},
	setTag: function(t) {
		this.tag = t
	},
	retain: function() {},
	release: function() {}
});
cc.action = function() {
	return new cc.Action
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
	_duration: 0,
	ctor: function() {
		cc.Action.prototype.ctor.call(this);
		this._duration = 0
	},
	getDuration: function() {
		return this._duration * (this._times || 1)
	},
	setDuration: function(t) {
		this._duration = t
	},
	reverse: function() {
		cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
		return null
	},
	clone: function() {
		return new cc.FiniteTimeAction
	}
});
cc.Speed = cc.Action.extend({
	_speed: 0,
	_innerAction: null,
	ctor: function(t, e) {
		cc.Action.prototype.ctor.call(this);
		this._speed = 0;
		this._innerAction = null;
		t && this.initWithAction(t, e)
	},
	getSpeed: function() {
		return this._speed
	},
	setSpeed: function(t) {
		this._speed = t
	},
	initWithAction: function(t, e) {
		if (!t) throw "cc.Speed.initWithAction(): action must be non nil";
		this._innerAction = t;
		this._speed = e;
		return !0
	},
	clone: function() {
		var t = new cc.Speed;
		t.initWithAction(this._innerAction.clone(), this._speed);
		return t
	},
	startWithTarget: function(t) {
		cc.Action.prototype.startWithTarget.call(this, t);
		this._innerAction.startWithTarget(t)
	},
	stop: function() {
		this._innerAction.stop();
		cc.Action.prototype.stop.call(this)
	},
	step: function(t) {
		this._innerAction.step(t * this._speed)
	},
	isDone: function() {
		return this._innerAction.isDone()
	},
	reverse: function() {
		return new cc.Speed(this._innerAction.reverse(), this._speed)
	},
	setInnerAction: function(t) {
		this._innerAction != t && (this._innerAction = t)
	},
	getInnerAction: function() {
		return this._innerAction
	}
});
cc.speed = function(t, e) {
	return new cc.Speed(t, e)
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
	_followedNode: null,
	_boundarySet: !1,
	_boundaryFullyCovered: !1,
	_halfScreenSize: null,
	_fullScreenSize: null,
	_worldRect: null,
	leftBoundary: 0,
	rightBoundary: 0,
	topBoundary: 0,
	bottomBoundary: 0,
	ctor: function(t, e) {
		cc.Action.prototype.ctor.call(this);
		this._followedNode = null;
		this._boundaryFullyCovered = this._boundarySet = !1;
		this._fullScreenSize = this._halfScreenSize = null;
		this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
		this._worldRect = cc.rect(0, 0, 0, 0);
		t && (e ? this.initWithTarget(t, e) : this.initWithTarget(t))
	},
	clone: function() {
		var t = new cc.Follow,
			e = this._worldRect,
			e = new cc.Rect(e.x, e.y, e.width, e.height);
		t.initWithTarget(this._followedNode, e);
		return t
	},
	isBoundarySet: function() {
		return this._boundarySet
	},
	setBoudarySet: function(t) {
		this._boundarySet = t
	},
	initWithTarget: function(t, e) {
		if (!t) throw "cc.Follow.initWithAction(): followedNode must be non nil";
		e = e || cc.rect(0, 0, 0, 0);
		this._followedNode = t;
		this._worldRect = e;
		this._boundarySet = !cc._rectEqualToZero(e);
		this._boundaryFullyCovered = !1;
		var i = cc.director.getWinSize();
		this._fullScreenSize = cc.p(i.width, i.height);
		this._halfScreenSize = cc.pMult(this._fullScreenSize, .5);
		this._boundarySet && (this.leftBoundary = -(e.x + e.width - this._fullScreenSize.x), this.rightBoundary = -e.x, this.topBoundary = -e.y, this.bottomBoundary = -(e.y + e.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2), this.topBoundary == this.bottomBoundary && this.leftBoundary == this.rightBoundary && (this._boundaryFullyCovered = !0));
		return !0
	},
	step: function(t) {
		t = this._followedNode.x;
		var e = this._followedNode.y;
		t = this._halfScreenSize.x - t;
		e = this._halfScreenSize.y - e;
		this.target._renderCmd._dirtyFlag = 0;
		this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(t, this.leftBoundary, this.rightBoundary), cc.clampf(e, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(t, e)
	},
	isDone: function() {
		return !this._followedNode.running
	},
	stop: function() {
		this.target = null;
		cc.Action.prototype.stop.call(this)
	}
});
cc.follow = function(t, e) {
	return new cc.Follow(t, e)
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
	_elapsed: 0,
	_firstTick: !1,
	_easeList: null,
	_times: 1,
	_repeatForever: !1,
	_repeatMethod: !1,
	_speed: 1,
	_speedMethod: !1,
	ctor: function(t) {
		this._times = this._speed = 1;
		this._repeatForever = !1;
		this.MAX_VALUE = 2;
		this._speedMethod = this._repeatMethod = !1;
		cc.FiniteTimeAction.prototype.ctor.call(this);
		void 0 !== t && this.initWithDuration(t)
	},
	getElapsed: function() {
		return this._elapsed
	},
	initWithDuration: function(t) {
		this._duration = 0 === t ? cc.FLT_EPSILON : t;
		this._elapsed = 0;
		return this._firstTick = !0
	},
	isDone: function() {
		return this._elapsed >= this._duration
	},
	_cloneDecoration: function(t) {
		t._repeatForever = this._repeatForever;
		t._speed = this._speed;
		t._times = this._times;
		t._easeList = this._easeList;
		t._speedMethod = this._speedMethod;
		t._repeatMethod = this._repeatMethod
	},
	_reverseEaseList: function(t) {
		if (this._easeList) {
			t._easeList = [];
			for (var e = 0; e < this._easeList.length; e++) t._easeList.push(this._easeList[e].reverse())
		}
	},
	clone: function() {
		var t = new cc.ActionInterval(this._duration);
		this._cloneDecoration(t);
		return t
	},
	easing: function(t) {
		this._easeList ? this._easeList.length = 0 : this._easeList = [];
		for (var e = 0; e < arguments.length; e++) this._easeList.push(arguments[e]);
		return this
	},
	_computeEaseTime: function(t) {
		var e = this._easeList;
		if (!e || 0 === e.length) return t;
		for (var i = 0, n = e.length; i < n; i++) t = e[i].easing(t);
		return t
	},
	step: function(t) {
		this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += t;
		t = this._elapsed / (1.192092896e-7 < this._duration ? this._duration : 1.192092896e-7);
		t = 1 > t ? t : 1;
		this.update(0 < t ? t : 0);
		this._repeatMethod && (1 < this._times && this.isDone()) && (this._repeatForever || this._times--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
	},
	startWithTarget: function(t) {
		cc.Action.prototype.startWithTarget.call(this, t);
		this._elapsed = 0;
		this._firstTick = !0
	},
	reverse: function() {
		cc.log("cc.IntervalAction: reverse not implemented.");
		return null
	},
	setAmplitudeRate: function(t) {
		cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
	},
	getAmplitudeRate: function() {
		cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
		return 0
	},
	speed: function(t) {
		if (0 >= t) return cc.log("The speed parameter error"), this;
		this._speedMethod = !0;
		this._speed *= t;
		return this
	},
	getSpeed: function() {
		return this._speed
	},
	setSpeed: function(t) {
		this._speed = t;
		return this
	},
	repeat: function(t) {
		t = Math.round(t);
		if (isNaN(t) || 1 > t) return cc.log("The repeat parameter error"), this;
		this._repeatMethod = !0;
		this._times *= t;
		return this
	},
	repeatForever: function() {
		this._repeatMethod = !0;
		this._times = this.MAX_VALUE;
		this._repeatForever = !0;
		return this
	}
});
cc.actionInterval = function(t) {
	return new cc.ActionInterval(t)
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
	_actions: null,
	_split: null,
	_last: 0,
	ctor: function(t) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._actions = [];
		var e = t instanceof Array ? t : arguments,
			i = e.length - 1;
		0 <= i && null == e[i] && cc.log("parameters should not be ending with null in Javascript");
		if (0 <= i) {
			for (var n = e[0], r = 1; r < i; r++) e[r] && (n = cc.Sequence._actionOneTwo(n, e[r]));
			this.initWithTwoActions(n, e[i])
		}
	},
	initWithTwoActions: function(t, e) {
		if (!t || !e) throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
		this.initWithDuration(t._duration + e._duration);
		this._actions[0] = t;
		this._actions[1] = e;
		return !0
	},
	clone: function() {
		var t = new cc.Sequence;
		this._cloneDecoration(t);
		t.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._split = this._actions[0]._duration / this._duration;
		this._last = -1
	},
	stop: function() {
		-1 !== this._last && this._actions[this._last].stop();
		cc.Action.prototype.stop.call(this)
	},
	update: function(t) {
		var e = 0,
			i = this._split,
			n = this._actions,
			r = this._last;
		t = this._computeEaseTime(t);
		t < i ? (t = 0 !== i ? t / i : 1, 0 === e && 1 === r && (n[1].update(0), n[1].stop())) : (e = 1, t = 1 === i ? 1 : (t - i) / (1 - i), -1 === r && (n[0].startWithTarget(this.target), n[0].update(1), n[0].stop()), r || (n[0].update(1), n[0].stop()));
		n = n[e];
		r === e && n.isDone() || (r !== e && n.startWithTarget(this.target), t *= n._times, n.update(1 < t ? t % 1 : t), this._last = e)
	},
	reverse: function() {
		var t = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	}
});
cc.sequence = function(t) {
	var e = t instanceof Array ? t : arguments;
	0 < e.length && null == e[e.length - 1] && cc.log("parameters should not be ending with null in Javascript");
	for (var i = e[0], n = 1; n < e.length; n++) e[n] && (i = cc.Sequence._actionOneTwo(i, e[n]));
	return i
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function(t, e) {
	var i = new cc.Sequence;
	i.initWithTwoActions(t, e);
	return i
};
cc.Repeat = cc.ActionInterval.extend({
	_times: 0,
	_total: 0,
	_nextDt: 0,
	_actionInstant: !1,
	_innerAction: null,
	ctor: function(t, e) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== e && this.initWithAction(t, e)
	},
	initWithAction: function(t, e) {
		return this.initWithDuration(t._duration * e) ? (this._times = e, this._innerAction = t, t instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
	},
	clone: function() {
		var t = new cc.Repeat;
		this._cloneDecoration(t);
		t.initWithAction(this._innerAction.clone(), this._times);
		return t
	},
	startWithTarget: function(t) {
		this._total = 0;
		this._nextDt = this._innerAction._duration / this._duration;
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._innerAction.startWithTarget(t)
	},
	stop: function() {
		this._innerAction.stop();
		cc.Action.prototype.stop.call(this)
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		var e = this._innerAction,
			i = this._duration,
			n = this._times,
			r = this._nextDt;
		if (t >= r) {
			for (; t > r && this._total < n;) e.update(1), this._total++, e.stop(), e.startWithTarget(this.target), this._nextDt = r += e._duration / i;
			1 <= t && this._total < n && this._total++;
			this._actionInstant || (this._total === n ? (e.update(1), e.stop()) : e.update(t - (r - e._duration / i)))
		} else e.update(t * n % 1)
	},
	isDone: function() {
		return this._total == this._times
	},
	reverse: function() {
		var t = new cc.Repeat(this._innerAction.reverse(), this._times);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	},
	setInnerAction: function(t) {
		this._innerAction != t && (this._innerAction = t)
	},
	getInnerAction: function() {
		return this._innerAction
	}
});
cc.repeat = function(t, e) {
	return new cc.Repeat(t, e)
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
	_innerAction: null,
	ctor: function(t) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._innerAction = null;
		t && this.initWithAction(t)
	},
	initWithAction: function(t) {
		if (!t) throw "cc.RepeatForever.initWithAction(): action must be non null";
		this._innerAction = t;
		return !0
	},
	clone: function() {
		var t = new cc.RepeatForever;
		this._cloneDecoration(t);
		t.initWithAction(this._innerAction.clone());
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._innerAction.startWithTarget(t)
	},
	step: function(t) {
		var e = this._innerAction;
		e.step(t);
		e.isDone() && (e.startWithTarget(this.target), e.step(e.getElapsed() - e._duration))
	},
	isDone: function() {
		return !1
	},
	reverse: function() {
		var t = new cc.RepeatForever(this._innerAction.reverse());
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	},
	setInnerAction: function(t) {
		this._innerAction != t && (this._innerAction = t)
	},
	getInnerAction: function() {
		return this._innerAction
	}
});
cc.repeatForever = function(t) {
	return new cc.RepeatForever(t)
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
	_one: null,
	_two: null,
	ctor: function(t) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._two = this._one = null;
		var e = t instanceof Array ? t : arguments,
			i = e.length - 1;
		0 <= i && null == e[i] && cc.log("parameters should not be ending with null in Javascript");
		if (0 <= i) {
			for (var n = e[0], r = 1; r < i; r++) e[r] && (n = cc.Spawn._actionOneTwo(n, e[r]));
			this.initWithTwoActions(n, e[i])
		}
	},
	initWithTwoActions: function(t, e) {
		if (!t || !e) throw "cc.Spawn.initWithTwoActions(): arguments must all be non null";
		var i = !1,
			n = t._duration,
			r = e._duration;
		this.initWithDuration(Math.max(n, r)) && (this._one = t, this._two = e, n > r ? this._two = cc.Sequence._actionOneTwo(e, cc.delayTime(n - r)) : n < r && (this._one = cc.Sequence._actionOneTwo(t, cc.delayTime(r - n))), i = !0);
		return i
	},
	clone: function() {
		var t = new cc.Spawn;
		this._cloneDecoration(t);
		t.initWithTwoActions(this._one.clone(), this._two.clone());
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._one.startWithTarget(t);
		this._two.startWithTarget(t)
	},
	stop: function() {
		this._one.stop();
		this._two.stop();
		cc.Action.prototype.stop.call(this)
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		this._one && this._one.update(t);
		this._two && this._two.update(t)
	},
	reverse: function() {
		var t = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	}
});
cc.spawn = function(t) {
	var e = t instanceof Array ? t : arguments;
	0 < e.length && null == e[e.length - 1] && cc.log("parameters should not be ending with null in Javascript");
	for (var i = e[0], n = 1; n < e.length; n++) null != e[n] && (i = cc.Spawn._actionOneTwo(i, e[n]));
	return i
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function(t, e) {
	var i = new cc.Spawn;
	i.initWithTwoActions(t, e);
	return i
};
cc.RotateTo = cc.ActionInterval.extend({
	_dstAngleX: 0,
	_startAngleX: 0,
	_diffAngleX: 0,
	_dstAngleY: 0,
	_startAngleY: 0,
	_diffAngleY: 0,
	ctor: function(t, e, i) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== e && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._dstAngleX = e || 0, this._dstAngleY = i || this._dstAngleX, !0) : !1
	},
	clone: function() {
		var t = new cc.RotateTo;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		var e = t.rotationX % 360,
			i = this._dstAngleX - e;
		180 < i && (i -= 360); - 180 > i && (i += 360);
		this._startAngleX = e;
		this._diffAngleX = i;
		this._startAngleY = t.rotationY % 360;
		t = this._dstAngleY - this._startAngleY;
		180 < t && (t -= 360); - 180 > t && (t += 360);
		this._diffAngleY = t
	},
	reverse: function() {
		cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		this.target && (this.target.rotationX = this._startAngleX + this._diffAngleX * t, this.target.rotationY = this._startAngleY + this._diffAngleY * t)
	}
});
cc.rotateTo = function(t, e, i) {
	return new cc.RotateTo(t, e, i)
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
	_angleX: 0,
	_startAngleX: 0,
	_angleY: 0,
	_startAngleY: 0,
	ctor: function(t, e, i) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== e && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._angleX = e || 0, this._angleY = i || this._angleX, !0) : !1
	},
	clone: function() {
		var t = new cc.RotateBy;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._angleX, this._angleY);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._startAngleX = t.rotationX;
		this._startAngleY = t.rotationY
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		this.target && (this.target.rotationX = this._startAngleX + this._angleX * t, this.target.rotationY = this._startAngleY + this._angleY * t)
	},
	reverse: function() {
		var t = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	}
});
cc.rotateBy = function(t, e, i) {
	return new cc.RotateBy(t, e, i)
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
	_positionDelta: null,
	_startPosition: null,
	_previousPosition: null,
	ctor: function(t, e, i) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._positionDelta = cc.p(0, 0);
		this._startPosition = cc.p(0, 0);
		this._previousPosition = cc.p(0, 0);
		void 0 !== e && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (void 0 !== e.x && (i = e.y, e = e.x), this._positionDelta.x = e, this._positionDelta.y = i, !0) : !1
	},
	clone: function() {
		var t = new cc.MoveBy;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._positionDelta);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		var e = t.getPositionX();
		t = t.getPositionY();
		this._previousPosition.x = e;
		this._previousPosition.y = t;
		this._startPosition.x = e;
		this._startPosition.y = t
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		if (this.target) {
			var e = this._positionDelta.x * t;
			t *= this._positionDelta.y;
			var i = this._startPosition;
			if (cc.ENABLE_STACKABLE_ACTIONS) {
				var n = this.target.getPositionX(),
					r = this.target.getPositionY(),
					c = this._previousPosition;
				i.x = i.x + n - c.x;
				i.y = i.y + r - c.y;
				e += i.x;
				t += i.y;
				c.x = e;
				c.y = t;
				this.target.setPosition(e, t)
			} else this.target.setPosition(i.x + e, i.y + t)
		}
	},
	reverse: function() {
		var t = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	}
});
cc.moveBy = function(t, e, i) {
	return new cc.MoveBy(t, e, i)
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
	_endPosition: null,
	ctor: function(t, e, i) {
		cc.MoveBy.prototype.ctor.call(this);
		this._endPosition = cc.p(0, 0);
		void 0 !== e && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		return cc.MoveBy.prototype.initWithDuration.call(this, t, e, i) ? (void 0 !== e.x && (i = e.y, e = e.x), this._endPosition.x = e, this._endPosition.y = i, !0) : !1
	},
	clone: function() {
		var t = new cc.MoveTo;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._endPosition);
		return t
	},
	startWithTarget: function(t) {
		cc.MoveBy.prototype.startWithTarget.call(this, t);
		this._positionDelta.x = this._endPosition.x - t.getPositionX();
		this._positionDelta.y = this._endPosition.y - t.getPositionY()
	}
});
cc.moveTo = function(t, e, i) {
	return new cc.MoveTo(t, e, i)
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
	_skewX: 0,
	_skewY: 0,
	_startSkewX: 0,
	_startSkewY: 0,
	_endSkewX: 0,
	_endSkewY: 0,
	_deltaX: 0,
	_deltaY: 0,
	ctor: function(t, e, i) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== i && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		var n = !1;
		cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._endSkewX = e, this._endSkewY = i, n = !0);
		return n
	},
	clone: function() {
		var t = new cc.SkewTo;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._startSkewX = t.skewX % 180;
		this._deltaX = this._endSkewX - this._startSkewX;
		180 < this._deltaX && (this._deltaX -= 360); - 180 > this._deltaX && (this._deltaX += 360);
		this._startSkewY = t.skewY % 360;
		this._deltaY = this._endSkewY - this._startSkewY;
		180 < this._deltaY && (this._deltaY -= 360); - 180 > this._deltaY && (this._deltaY += 360)
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		this.target.skewX = this._startSkewX + this._deltaX * t;
		this.target.skewY = this._startSkewY + this._deltaY * t
	}
});
cc.skewTo = function(t, e, i) {
	return new cc.SkewTo(t, e, i)
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
	ctor: function(t, e, i) {
		cc.SkewTo.prototype.ctor.call(this);
		void 0 !== i && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		var n = !1;
		cc.SkewTo.prototype.initWithDuration.call(this, t, e, i) && (this._skewX = e, this._skewY = i, n = !0);
		return n
	},
	clone: function() {
		var t = new cc.SkewBy;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._skewX, this._skewY);
		return t
	},
	startWithTarget: function(t) {
		cc.SkewTo.prototype.startWithTarget.call(this, t);
		this._deltaX = this._skewX;
		this._deltaY = this._skewY;
		this._endSkewX = this._startSkewX + this._deltaX;
		this._endSkewY = this._startSkewY + this._deltaY
	},
	reverse: function() {
		var t = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	}
});
cc.skewBy = function(t, e, i) {
	return new cc.SkewBy(t, e, i)
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
	_startPosition: null,
	_delta: null,
	_height: 0,
	_jumps: 0,
	_previousPosition: null,
	ctor: function(t, e, i, n, r) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._startPosition = cc.p(0, 0);
		this._previousPosition = cc.p(0, 0);
		this._delta = cc.p(0, 0);
		void 0 !== n && this.initWithDuration(t, e, i, n, r)
	},
	initWithDuration: function(t, e, i, n, r) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (void 0 === r && (r = n, n = i, i = e.y, e = e.x), this._delta.x = e, this._delta.y = i, this._height = n, this._jumps = r, !0) : !1
	},
	clone: function() {
		var t = new cc.JumpBy;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._delta, this._height, this._jumps);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		var e = t.getPositionX();
		t = t.getPositionY();
		this._previousPosition.x = e;
		this._previousPosition.y = t;
		this._startPosition.x = e;
		this._startPosition.y = t
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		if (this.target) {
			var e = t * this._jumps % 1,
				e = 4 * this._height * e * (1 - e),
				e = e + this._delta.y * t;
			t *= this._delta.x;
			var i = this._startPosition;
			if (cc.ENABLE_STACKABLE_ACTIONS) {
				var n = this.target.getPositionX(),
					r = this.target.getPositionY(),
					c = this._previousPosition;
				i.x = i.x + n - c.x;
				i.y = i.y + r - c.y;
				t += i.x;
				e += i.y;
				c.x = t;
				c.y = e;
				this.target.setPosition(t, e)
			} else this.target.setPosition(i.x + t, i.y + e)
		}
	},
	reverse: function() {
		var t = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	}
});
cc.jumpBy = function(t, e, i, n, r) {
	return new cc.JumpBy(t, e, i, n, r)
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
	_endPosition: null,
	ctor: function(t, e, i, n, r) {
		cc.JumpBy.prototype.ctor.call(this);
		this._endPosition = cc.p(0, 0);
		void 0 !== n && this.initWithDuration(t, e, i, n, r)
	},
	initWithDuration: function(t, e, i, n, r) {
		return cc.JumpBy.prototype.initWithDuration.call(this, t, e, i, n, r) ? (void 0 === r && (i = e.y, e = e.x), this._endPosition.x = e, this._endPosition.y = i, !0) : !1
	},
	startWithTarget: function(t) {
		cc.JumpBy.prototype.startWithTarget.call(this, t);
		this._delta.x = this._endPosition.x - this._startPosition.x;
		this._delta.y = this._endPosition.y - this._startPosition.y
	},
	clone: function() {
		var t = new cc.JumpTo;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
		return t
	}
});
cc.jumpTo = function(t, e, i, n, r) {
	return new cc.JumpTo(t, e, i, n, r)
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function(t, e, i, n, r) {
	return Math.pow(1 - r, 3) * t + 3 * r * Math.pow(1 - r, 2) * e + 3 * Math.pow(r, 2) * (1 - r) * i + Math.pow(r, 3) * n
};
cc.BezierBy = cc.ActionInterval.extend({
	_config: null,
	_startPosition: null,
	_previousPosition: null,
	ctor: function(t, e) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._config = [];
		this._startPosition = cc.p(0, 0);
		this._previousPosition = cc.p(0, 0);
		e && this.initWithDuration(t, e)
	},
	initWithDuration: function(t, e) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._config = e, !0) : !1
	},
	clone: function() {
		var t = new cc.BezierBy;
		this._cloneDecoration(t);
		for (var e = [], i = 0; i < this._config.length; i++) {
			var n = this._config[i];
			e.push(cc.p(n.x, n.y))
		}
		t.initWithDuration(this._duration, e);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		var e = t.getPositionX();
		t = t.getPositionY();
		this._previousPosition.x = e;
		this._previousPosition.y = t;
		this._startPosition.x = e;
		this._startPosition.y = t
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		if (this.target) {
			var e = this._config,
				i = e[0].y,
				n = e[1].y,
				r = e[2].y,
				e = cc.bezierAt(0, e[0].x, e[1].x, e[2].x, t);
			t = cc.bezierAt(0, i, n, r, t);
			i = this._startPosition;
			if (cc.ENABLE_STACKABLE_ACTIONS) {
				var n = this.target.getPositionX(),
					r = this.target.getPositionY(),
					c = this._previousPosition;
				i.x = i.x + n - c.x;
				i.y = i.y + r - c.y;
				e += i.x;
				t += i.y;
				c.x = e;
				c.y = t;
				this.target.setPosition(e, t)
			} else this.target.setPosition(i.x + e, i.y + t)
		}
	},
	reverse: function() {
		var t = this._config,
			t = [cc.pAdd(t[1], cc.pNeg(t[2])), cc.pAdd(t[0], cc.pNeg(t[2])), cc.pNeg(t[2])],
			t = new cc.BezierBy(this._duration, t);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	}
});
cc.bezierBy = function(t, e) {
	return new cc.BezierBy(t, e)
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
	_toConfig: null,
	ctor: function(t, e) {
		cc.BezierBy.prototype.ctor.call(this);
		this._toConfig = [];
		e && this.initWithDuration(t, e)
	},
	initWithDuration: function(t, e) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._toConfig = e, !0) : !1
	},
	clone: function() {
		var t = new cc.BezierTo;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._toConfig);
		return t
	},
	startWithTarget: function(t) {
		cc.BezierBy.prototype.startWithTarget.call(this, t);
		t = this._startPosition;
		var e = this._toConfig,
			i = this._config;
		i[0] = cc.pSub(e[0], t);
		i[1] = cc.pSub(e[1], t);
		i[2] = cc.pSub(e[2], t)
	}
});
cc.bezierTo = function(t, e) {
	return new cc.BezierTo(t, e)
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
	_scaleX: 1,
	_scaleY: 1,
	_startScaleX: 1,
	_startScaleY: 1,
	_endScaleX: 0,
	_endScaleY: 0,
	_deltaX: 0,
	_deltaY: 0,
	ctor: function(t, e, i) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== e && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._endScaleX = e, this._endScaleY = null != i ? i : e, !0) : !1
	},
	clone: function() {
		var t = new cc.ScaleTo;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._startScaleX = t.scaleX;
		this._startScaleY = t.scaleY;
		this._deltaX = this._endScaleX - this._startScaleX;
		this._deltaY = this._endScaleY - this._startScaleY
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		this.target && (this.target.scaleX = this._startScaleX + this._deltaX * t, this.target.scaleY = this._startScaleY + this._deltaY * t)
	}
});
cc.scaleTo = function(t, e, i) {
	return new cc.ScaleTo(t, e, i)
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
	startWithTarget: function(t) {
		cc.ScaleTo.prototype.startWithTarget.call(this, t);
		this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
		this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
	},
	reverse: function() {
		var t = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	},
	clone: function() {
		var t = new cc.ScaleBy;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
		return t
	}
});
cc.scaleBy = function(t, e, i) {
	return new cc.ScaleBy(t, e, i)
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
	_times: 0,
	_originalState: !1,
	ctor: function(t, e) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== e && this.initWithDuration(t, e)
	},
	initWithDuration: function(t, e) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._times = e, !0) : !1
	},
	clone: function() {
		var t = new cc.Blink;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._times);
		return t
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		if (this.target && !this.isDone()) {
			var e = 1 / this._times;
			this.target.visible = t % e > e / 2
		}
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._originalState = t.visible
	},
	stop: function() {
		this.target.visible = this._originalState;
		cc.ActionInterval.prototype.stop.call(this)
	},
	reverse: function() {
		var t = new cc.Blink(this._duration, this._times);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	}
});
cc.blink = function(t, e) {
	return new cc.Blink(t, e)
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
	_toOpacity: 0,
	_fromOpacity: 0,
	ctor: function(t, e) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== e && this.initWithDuration(t, e)
	},
	initWithDuration: function(t, e) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._toOpacity = e, !0) : !1
	},
	clone: function() {
		var t = new cc.FadeTo;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._toOpacity);
		return t
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		var e = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
		this.target.opacity = e + (this._toOpacity - e) * t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._fromOpacity = t.opacity
	}
});
cc.fadeTo = function(t, e) {
	return new cc.FadeTo(t, e)
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
	_reverseAction: null,
	ctor: function(t) {
		cc.FadeTo.prototype.ctor.call(this);
		t && this.initWithDuration(t, 255)
	},
	reverse: function() {
		var t = new cc.FadeOut;
		t.initWithDuration(this._duration, 0);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	},
	clone: function() {
		var t = new cc.FadeIn;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._toOpacity);
		return t
	},
	startWithTarget: function(t) {
		this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
		cc.FadeTo.prototype.startWithTarget.call(this, t)
	}
});
cc.fadeIn = function(t) {
	return new cc.FadeIn(t)
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
	ctor: function(t) {
		cc.FadeTo.prototype.ctor.call(this);
		t && this.initWithDuration(t, 0)
	},
	reverse: function() {
		var t = new cc.FadeIn;
		t._reverseAction = this;
		t.initWithDuration(this._duration, 255);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	},
	clone: function() {
		var t = new cc.FadeOut;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._toOpacity);
		return t
	}
});
cc.fadeOut = function(t) {
	return new cc.FadeOut(t)
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
	_to: null,
	_from: null,
	ctor: function(t, e, i, n) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._to = cc.color(0, 0, 0);
		this._from = cc.color(0, 0, 0);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	initWithDuration: function(t, e, i, n) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._to = cc.color(e, i, n), !0) : !1
	},
	clone: function() {
		var t = new cc.TintTo;
		this._cloneDecoration(t);
		var e = this._to;
		t.initWithDuration(this._duration, e.r, e.g, e.b);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._from = this.target.color
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		var e = this._from,
			i = this._to;
		e && (this.target.color = cc.color(e.r + (i.r - e.r) * t, e.g + (i.g - e.g) * t, e.b + (i.b - e.b) * t))
	}
});
cc.tintTo = function(t, e, i, n) {
	return new cc.TintTo(t, e, i, n)
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
	_deltaR: 0,
	_deltaG: 0,
	_deltaB: 0,
	_fromR: 0,
	_fromG: 0,
	_fromB: 0,
	ctor: function(t, e, i, n) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	initWithDuration: function(t, e, i, n) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._deltaR = e, this._deltaG = i, this._deltaB = n, !0) : !1
	},
	clone: function() {
		var t = new cc.TintBy;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		t = t.color;
		this._fromR = t.r;
		this._fromG = t.g;
		this._fromB = t.b
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		this.target.color = cc.color(this._fromR + this._deltaR * t, this._fromG + this._deltaG * t, this._fromB + this._deltaB * t)
	},
	reverse: function() {
		var t = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	}
});
cc.tintBy = function(t, e, i, n) {
	return new cc.TintBy(t, e, i, n)
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
	update: function(t) {},
	reverse: function() {
		var t = new cc.DelayTime(this._duration);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	},
	clone: function() {
		var t = new cc.DelayTime;
		this._cloneDecoration(t);
		t.initWithDuration(this._duration);
		return t
	}
});
cc.delayTime = function(t) {
	return new cc.DelayTime(t)
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
	_other: null,
	ctor: function(t) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._other = null;
		t && this.initWithAction(t)
	},
	initWithAction: function(t) {
		if (!t) throw "cc.ReverseTime.initWithAction(): action must be non null";
		if (t == this._other) throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
		return cc.ActionInterval.prototype.initWithDuration.call(this, t._duration) ? (this._other = t, !0) : !1
	},
	clone: function() {
		var t = new cc.ReverseTime;
		this._cloneDecoration(t);
		t.initWithAction(this._other.clone());
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._other.startWithTarget(t)
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		this._other && this._other.update(1 - t)
	},
	reverse: function() {
		return this._other.clone()
	},
	stop: function() {
		this._other.stop();
		cc.Action.prototype.stop.call(this)
	}
});
cc.reverseTime = function(t) {
	return new cc.ReverseTime(t)
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
	_animation: null,
	_nextFrame: 0,
	_origFrame: null,
	_executedLoops: 0,
	_splitTimes: null,
	ctor: function(t) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._splitTimes = [];
		t && this.initWithAnimation(t)
	},
	getAnimation: function() {
		return this._animation
	},
	setAnimation: function(t) {
		this._animation = t
	},
	initWithAnimation: function(t) {
		if (!t) throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
		var e = t.getDuration();
		if (this.initWithDuration(e * t.getLoops())) {
			this._nextFrame = 0;
			this.setAnimation(t);
			this._origFrame = null;
			this._executedLoops = 0;
			var i = this._splitTimes,
				n = i.length = 0,
				r = e / t.getTotalDelayUnits();
			t = t.getFrames();
			cc.arrayVerifyType(t, cc.AnimationFrame);
			for (var c = 0; c < t.length; c++) {
				var s = n * r / e,
					n = n + t[c].getDelayUnits();
				i.push(s)
			}
			return !0
		}
		return !1
	},
	clone: function() {
		var t = new cc.Animate;
		this._cloneDecoration(t);
		t.initWithAnimation(this._animation.clone());
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._animation.getRestoreOriginalFrame() && (this._origFrame = t.displayFrame());
		this._executedLoops = this._nextFrame = 0
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		1 > t && (t *= this._animation.getLoops(), (0 | t) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), t %= 1);
		for (var e = this._animation.getFrames(), i = e.length, n = this._splitTimes, r = this._nextFrame; r < i; r++) if (n[r] <= t) this.target.setSpriteFrame(e[r].getSpriteFrame()), this._nextFrame = r + 1;
		else break
	},
	reverse: function() {
		var t = this._animation,
			e = t.getFrames(),
			i = [];
		cc.arrayVerifyType(e, cc.AnimationFrame);
		if (0 < e.length) for (var n = e.length - 1; 0 <= n; n--) {
			var r = e[n];
			if (!r) break;
			i.push(r.clone())
		}
		e = new cc.Animation(i, t.getDelayPerUnit(), t.getLoops());
		e.setRestoreOriginalFrame(t.getRestoreOriginalFrame());
		t = new cc.Animate(e);
		this._cloneDecoration(t);
		this._reverseEaseList(t);
		return t
	},
	stop: function() {
		this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
		cc.Action.prototype.stop.call(this)
	}
});
cc.animate = function(t) {
	return new cc.Animate(t)
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
	_action: null,
	_forcedTarget: null,
	ctor: function(t, e) {
		cc.ActionInterval.prototype.ctor.call(this);
		e && this.initWithTarget(t, e)
	},
	initWithTarget: function(t, e) {
		return this.initWithDuration(e._duration) ? (this._forcedTarget = t, this._action = e, !0) : !1
	},
	clone: function() {
		var t = new cc.TargetedAction;
		this._cloneDecoration(t);
		t.initWithTarget(this._forcedTarget, this._action.clone());
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._action.startWithTarget(this._forcedTarget)
	},
	stop: function() {
		this._action.stop()
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		this._action.update(t)
	},
	getForcedTarget: function() {
		return this._forcedTarget
	},
	setForcedTarget: function(t) {
		this._forcedTarget != t && (this._forcedTarget = t)
	}
});
cc.targetedAction = function(t, e) {
	return new cc.TargetedAction(t, e)
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
	isDone: function() {
		return !0
	},
	step: function(t) {
		this.update(1)
	},
	update: function(t) {},
	reverse: function() {
		return this.clone()
	},
	clone: function() {
		return new cc.ActionInstant
	}
});
cc.Show = cc.ActionInstant.extend({
	update: function(t) {
		this.target.visible = !0
	},
	reverse: function() {
		return new cc.Hide
	},
	clone: function() {
		return new cc.Show
	}
});
cc.show = function() {
	return new cc.Show
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
	update: function(t) {
		this.target.visible = !1
	},
	reverse: function() {
		return new cc.Show
	},
	clone: function() {
		return new cc.Hide
	}
});
cc.hide = function() {
	return new cc.Hide
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
	update: function(t) {
		this.target.visible = !this.target.visible
	},
	reverse: function() {
		return new cc.ToggleVisibility
	},
	clone: function() {
		return new cc.ToggleVisibility
	}
});
cc.toggleVisibility = function() {
	return new cc.ToggleVisibility
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
	_isNeedCleanUp: !0,
	ctor: function(t) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		void 0 !== t && this.init(t)
	},
	update: function(t) {
		this.target.removeFromParent(this._isNeedCleanUp)
	},
	init: function(t) {
		this._isNeedCleanUp = t;
		return !0
	},
	reverse: function() {
		return new cc.RemoveSelf(this._isNeedCleanUp)
	},
	clone: function() {
		return new cc.RemoveSelf(this._isNeedCleanUp)
	}
});
cc.removeSelf = function(t) {
	return new cc.RemoveSelf(t)
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
	_flippedX: !1,
	ctor: function(t) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		this._flippedX = !1;
		void 0 !== t && this.initWithFlipX(t)
	},
	initWithFlipX: function(t) {
		this._flippedX = t;
		return !0
	},
	update: function(t) {
		this.target.flippedX = this._flippedX
	},
	reverse: function() {
		return new cc.FlipX(!this._flippedX)
	},
	clone: function() {
		var t = new cc.FlipX;
		t.initWithFlipX(this._flippedX);
		return t
	}
});
cc.flipX = function(t) {
	return new cc.FlipX(t)
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
	_flippedY: !1,
	ctor: function(t) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		this._flippedY = !1;
		void 0 !== t && this.initWithFlipY(t)
	},
	initWithFlipY: function(t) {
		this._flippedY = t;
		return !0
	},
	update: function(t) {
		this.target.flippedY = this._flippedY
	},
	reverse: function() {
		return new cc.FlipY(!this._flippedY)
	},
	clone: function() {
		var t = new cc.FlipY;
		t.initWithFlipY(this._flippedY);
		return t
	}
});
cc.flipY = function(t) {
	return new cc.FlipY(t)
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
	_x: 0,
	_y: 0,
	ctor: function(t, e) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		this._y = this._x = 0;
		void 0 !== t && (void 0 !== t.x && (e = t.y, t = t.x), this.initWithPosition(t, e))
	},
	initWithPosition: function(t, e) {
		this._x = t;
		this._y = e;
		return !0
	},
	update: function(t) {
		this.target.setPosition(this._x, this._y)
	},
	clone: function() {
		var t = new cc.Place;
		t.initWithPosition(this._x, this._y);
		return t
	}
});
cc.place = function(t, e) {
	return new cc.Place(t, e)
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
	_selectorTarget: null,
	_callFunc: null,
	_function: null,
	_data: null,
	ctor: function(t, e, i) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		void 0 !== t && (void 0 === e ? this.initWithFunction(t) : this.initWithFunction(t, e, i))
	},
	initWithFunction: function(t, e, i) {
		e ? (this._data = i, this._callFunc = t, this._selectorTarget = e) : t && (this._function = t);
		return !0
	},
	execute: function() {
		null != this._callFunc ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null, this.target)
	},
	update: function(t) {
		this.execute()
	},
	getTargetCallback: function() {
		return this._selectorTarget
	},
	setTargetCallback: function(t) {
		t != this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = t)
	},
	clone: function() {
		var t = new cc.CallFunc;
		this._selectorTarget ? t.initWithFunction(this._callFunc, this._selectorTarget, this._data) : this._function && t.initWithFunction(this._function);
		return t
	}
});
cc.callFunc = function(t, e, i) {
	return new cc.CallFunc(t, e, i)
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
	_centerXOrig: 0,
	_centerYOrig: 0,
	_centerZOrig: 0,
	_eyeXOrig: 0,
	_eyeYOrig: 0,
	_eyeZOrig: 0,
	_upXOrig: 0,
	_upYOrig: 0,
	_upZOrig: 0,
	ctor: function() {
		cc.ActionInterval.prototype.ctor.call(this);
		this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		t = t.getCamera();
		var e = t.getCenter();
		this._centerXOrig = e.x;
		this._centerYOrig = e.y;
		this._centerZOrig = e.z;
		e = t.getEye();
		this._eyeXOrig = e.x;
		this._eyeYOrig = e.y;
		this._eyeZOrig = e.z;
		t = t.getUp();
		this._upXOrig = t.x;
		this._upYOrig = t.y;
		this._upZOrig = t.z
	},
	clone: function() {
		return new cc.ActionCamera
	},
	reverse: function() {
		return new cc.ReverseTime(this)
	}
});
cc.OrbitCamera = cc.ActionCamera.extend({
	_radius: 0,
	_deltaRadius: 0,
	_angleZ: 0,
	_deltaAngleZ: 0,
	_angleX: 0,
	_deltaAngleX: 0,
	_radZ: 0,
	_radDeltaZ: 0,
	_radX: 0,
	_radDeltaX: 0,
	ctor: function(t, e, i, n, r, c, s) {
		cc.ActionCamera.prototype.ctor.call(this);
		void 0 !== s && this.initWithDuration(t, e, i, n, r, c, s)
	},
	initWithDuration: function(t, e, i, n, r, c, s) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._radius = e, this._deltaRadius = i, this._angleZ = n, this._deltaAngleZ = r, this._angleX = c, this._deltaAngleX = s, this._radDeltaZ = cc.degreesToRadians(r), this._radDeltaX = cc.degreesToRadians(s), !0) : !1
	},
	sphericalRadius: function() {
		var t, e;
		e = this.target.getCamera();
		var i = e.getEye();
		t = e.getCenter();
		e = i.x - t.x;
		var n = i.y - t.y;
		t = i.z - t.z;
		var i = Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) + Math.pow(t, 2)),
			r = Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2));
		0 === r && (r = cc.FLT_EPSILON);
		0 === i && (i = cc.FLT_EPSILON);
		t = Math.acos(t / i);
		e = 0 > e ? Math.PI - Math.asin(n / r) : Math.asin(n / r);
		return {
			newRadius: i / cc.Camera.getZEye(),
			zenith: t,
			azimuth: e
		}
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		t = this.sphericalRadius();
		isNaN(this._radius) && (this._radius = t.newRadius);
		isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(t.zenith));
		isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(t.azimuth));
		this._radZ = cc.degreesToRadians(this._angleZ);
		this._radX = cc.degreesToRadians(this._angleX)
	},
	clone: function() {
		var t = new cc.OrbitCamera;
		t.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
		return t
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		var e = (this._radius + this._deltaRadius * t) * cc.Camera.getZEye(),
			i = this._radZ + this._radDeltaZ * t,
			n = this._radX + this._radDeltaX * t;
		t = Math.sin(i) * Math.cos(n) * e + this._centerXOrig;
		n = Math.sin(i) * Math.sin(n) * e + this._centerYOrig;
		e = Math.cos(i) * e + this._centerZOrig;
		this.target.getCamera().setEye(t, n, e);
		this.target.setNodeDirty()
	}
});
cc.orbitCamera = function(t, e, i, n, r, c, s) {
	return new cc.OrbitCamera(t, e, i, n, r, c, s)
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
	_inner: null,
	ctor: function(t) {
		cc.ActionInterval.prototype.ctor.call(this);
		t && this.initWithAction(t)
	},
	initWithAction: function(t) {
		if (!t) throw "cc.ActionEase.initWithAction(): action must be non nil";
		return this.initWithDuration(t.getDuration()) ? (this._inner = t, !0) : !1
	},
	clone: function() {
		var t = new cc.ActionEase;
		t.initWithAction(this._inner.clone());
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._inner.startWithTarget(this.target)
	},
	stop: function() {
		this._inner.stop();
		cc.ActionInterval.prototype.stop.call(this)
	},
	update: function(t) {
		this._inner.update(t)
	},
	reverse: function() {
		return new cc.ActionEase(this._inner.reverse())
	},
	getInnerAction: function() {
		return this._inner
	}
});
cc.actionEase = function(t) {
	return new cc.ActionEase(t)
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
	_rate: 0,
	ctor: function(t, e) {
		cc.ActionEase.prototype.ctor.call(this);
		void 0 !== e && this.initWithAction(t, e)
	},
	setRate: function(t) {
		this._rate = t
	},
	getRate: function() {
		return this._rate
	},
	initWithAction: function(t, e) {
		return cc.ActionEase.prototype.initWithAction.call(this, t) ? (this._rate = e, !0) : !1
	},
	clone: function() {
		var t = new cc.EaseRateAction;
		t.initWithAction(this._inner.clone(), this._rate);
		return t
	},
	reverse: function() {
		return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate)
	}
});
cc.easeRateAction = function(t, e) {
	return new cc.EaseRateAction(t, e)
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
	update: function(t) {
		this._inner.update(Math.pow(t, this._rate))
	},
	reverse: function() {
		return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
	},
	clone: function() {
		var t = new cc.EaseIn;
		t.initWithAction(this._inner.clone(), this._rate);
		return t
	}
});
cc.EaseIn.create = function(t, e) {
	return new cc.EaseIn(t, e)
};
cc.easeIn = function(t) {
	return {
		_rate: t,
		easing: function(t) {
			return Math.pow(t, this._rate)
		},
		reverse: function() {
			return cc.easeIn(1 / this._rate)
		}
	}
};
cc.EaseOut = cc.EaseRateAction.extend({
	update: function(t) {
		this._inner.update(Math.pow(t, 1 / this._rate))
	},
	reverse: function() {
		return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
	},
	clone: function() {
		var t = new cc.EaseOut;
		t.initWithAction(this._inner.clone(), this._rate);
		return t
	}
});
cc.EaseOut.create = function(t, e) {
	return new cc.EaseOut(t, e)
};
cc.easeOut = function(t) {
	return {
		_rate: t,
		easing: function(t) {
			return Math.pow(t, 1 / this._rate)
		},
		reverse: function() {
			return cc.easeOut(1 / this._rate)
		}
	}
};
cc.EaseInOut = cc.EaseRateAction.extend({
	update: function(t) {
		t *= 2;
		1 > t ? this._inner.update(.5 * Math.pow(t, this._rate)) : this._inner.update(1 - .5 * Math.pow(2 - t, this._rate))
	},
	clone: function() {
		var t = new cc.EaseInOut;
		t.initWithAction(this._inner.clone(), this._rate);
		return t
	},
	reverse: function() {
		return new cc.EaseInOut(this._inner.reverse(), this._rate)
	}
});
cc.EaseInOut.create = function(t, e) {
	return new cc.EaseInOut(t, e)
};
cc.easeInOut = function(t) {
	return {
		_rate: t,
		easing: function(t) {
			t *= 2;
			return 1 > t ? .5 * Math.pow(t, this._rate) : 1 - .5 * Math.pow(2 - t, this._rate)
		},
		reverse: function() {
			return cc.easeInOut(this._rate)
		}
	}
};
cc.EaseExponentialIn = cc.ActionEase.extend({
	update: function(t) {
		this._inner.update(0 === t ? 0 : Math.pow(2, 10 * (t - 1)))
	},
	reverse: function() {
		return new cc.EaseExponentialOut(this._inner.reverse())
	},
	clone: function() {
		var t = new cc.EaseExponentialIn;
		t.initWithAction(this._inner.clone());
		return t
	}
});
cc.EaseExponentialIn.create = function(t) {
	return new cc.EaseExponentialIn(t)
};
cc._easeExponentialInObj = {
	easing: function(t) {
		return 0 === t ? 0 : Math.pow(2, 10 * (t - 1))
	},
	reverse: function() {
		return cc._easeExponentialOutObj
	}
};
cc.easeExponentialIn = function() {
	return cc._easeExponentialInObj
};
cc.EaseExponentialOut = cc.ActionEase.extend({
	update: function(t) {
		this._inner.update(1 == t ? 1 : -Math.pow(2, -10 * t) + 1)
	},
	reverse: function() {
		return new cc.EaseExponentialIn(this._inner.reverse())
	},
	clone: function() {
		var t = new cc.EaseExponentialOut;
		t.initWithAction(this._inner.clone());
		return t
	}
});
cc.EaseExponentialOut.create = function(t) {
	return new cc.EaseExponentialOut(t)
};
cc._easeExponentialOutObj = {
	easing: function(t) {
		return 1 == t ? 1 : -Math.pow(2, -10 * t) + 1
	},
	reverse: function() {
		return cc._easeExponentialInObj
	}
};
cc.easeExponentialOut = function() {
	return cc._easeExponentialOutObj
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
	update: function(t) {
		1 != t && 0 !== t && (t *= 2, t = 1 > t ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2));
		this._inner.update(t)
	},
	reverse: function() {
		return new cc.EaseExponentialInOut(this._inner.reverse())
	},
	clone: function() {
		var t = new cc.EaseExponentialInOut;
		t.initWithAction(this._inner.clone());
		return t
	}
});
cc.EaseExponentialInOut.create = function(t) {
	return new cc.EaseExponentialInOut(t)
};
cc._easeExponentialInOutObj = {
	easing: function(t) {
		return 1 !== t && 0 !== t ? (t *= 2, 1 > t ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)) : t
	},
	reverse: function() {
		return cc._easeExponentialInOutObj
	}
};
cc.easeExponentialInOut = function() {
	return cc._easeExponentialInOutObj
};
cc.EaseSineIn = cc.ActionEase.extend({
	update: function(t) {
		t = 0 === t || 1 === t ? t : -1 * Math.cos(t * Math.PI / 2) + 1;
		this._inner.update(t)
	},
	reverse: function() {
		return new cc.EaseSineOut(this._inner.reverse())
	},
	clone: function() {
		var t = new cc.EaseSineIn;
		t.initWithAction(this._inner.clone());
		return t
	}
});
cc.EaseSineIn.create = function(t) {
	return new cc.EaseSineIn(t)
};
cc._easeSineInObj = {
	easing: function(t) {
		return 0 === t || 1 === t ? t : -1 * Math.cos(t * Math.PI / 2) + 1
	},
	reverse: function() {
		return cc._easeSineOutObj
	}
};
cc.easeSineIn = function() {
	return cc._easeSineInObj
};
cc.EaseSineOut = cc.ActionEase.extend({
	update: function(t) {
		t = 0 === t || 1 === t ? t : Math.sin(t * Math.PI / 2);
		this._inner.update(t)
	},
	reverse: function() {
		return new cc.EaseSineIn(this._inner.reverse())
	},
	clone: function() {
		var t = new cc.EaseSineOut;
		t.initWithAction(this._inner.clone());
		return t
	}
});
cc.EaseSineOut.create = function(t) {
	return new cc.EaseSineOut(t)
};
cc._easeSineOutObj = {
	easing: function(t) {
		return 0 === t || 1 == t ? t : Math.sin(t * Math.PI / 2)
	},
	reverse: function() {
		return cc._easeSineInObj
	}
};
cc.easeSineOut = function() {
	return cc._easeSineOutObj
};
cc.EaseSineInOut = cc.ActionEase.extend({
	update: function(t) {
		t = 0 === t || 1 === t ? t : -.5 * (Math.cos(Math.PI * t) - 1);
		this._inner.update(t)
	},
	clone: function() {
		var t = new cc.EaseSineInOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseSineInOut(this._inner.reverse())
	}
});
cc.EaseSineInOut.create = function(t) {
	return new cc.EaseSineInOut(t)
};
cc._easeSineInOutObj = {
	easing: function(t) {
		return 0 === t || 1 === t ? t : -.5 * (Math.cos(Math.PI * t) - 1)
	},
	reverse: function() {
		return cc._easeSineInOutObj
	}
};
cc.easeSineInOut = function() {
	return cc._easeSineInOutObj
};
cc.EaseElastic = cc.ActionEase.extend({
	_period: .3,
	ctor: function(t, e) {
		cc.ActionEase.prototype.ctor.call(this);
		t && this.initWithAction(t, e)
	},
	getPeriod: function() {
		return this._period
	},
	setPeriod: function(t) {
		this._period = t
	},
	initWithAction: function(t, e) {
		cc.ActionEase.prototype.initWithAction.call(this, t);
		this._period = null == e ? .3 : e;
		return !0
	},
	reverse: function() {
		cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
		return null
	},
	clone: function() {
		var t = new cc.EaseElastic;
		t.initWithAction(this._inner.clone(), this._period);
		return t
	}
});
cc.EaseElastic.create = function(t, e) {
	return new cc.EaseElastic(t, e)
};
cc.EaseElasticIn = cc.EaseElastic.extend({
	update: function(t) {
		var e = 0;
		0 === t || 1 === t ? e = t : (e = this._period / 4, t -= 1, e = -Math.pow(2, 10 * t) * Math.sin(2 * (t - e) * Math.PI / this._period));
		this._inner.update(e)
	},
	reverse: function() {
		return new cc.EaseElasticOut(this._inner.reverse(), this._period)
	},
	clone: function() {
		var t = new cc.EaseElasticIn;
		t.initWithAction(this._inner.clone(), this._period);
		return t
	}
});
cc.EaseElasticIn.create = function(t, e) {
	return new cc.EaseElasticIn(t, e)
};
cc._easeElasticInObj = {
	easing: function(t) {
		if (0 === t || 1 === t) return t;
		t -= 1;
		return -Math.pow(2, 10 * t) * Math.sin(2 * (t - .075) * Math.PI / .3)
	},
	reverse: function() {
		return cc._easeElasticOutObj
	}
};
cc.easeElasticIn = function(t) {
	return t && .3 !== t ? {
		_period: t,
		easing: function(t) {
			if (0 === t || 1 === t) return t;
			t -= 1;
			return -Math.pow(2, 10 * t) * Math.sin(2 * (t - this._period / 4) * Math.PI / this._period)
		},
		reverse: function() {
			return cc.easeElasticOut(this._period)
		}
	} : cc._easeElasticInObj
};
cc.EaseElasticOut = cc.EaseElastic.extend({
	update: function(t) {
		var e = 0;
		0 === t || 1 == t ? e = t : (e = this._period / 4, e = Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / this._period) + 1);
		this._inner.update(e)
	},
	reverse: function() {
		return new cc.EaseElasticIn(this._inner.reverse(), this._period)
	},
	clone: function() {
		var t = new cc.EaseElasticOut;
		t.initWithAction(this._inner.clone(), this._period);
		return t
	}
});
cc.EaseElasticOut.create = function(t, e) {
	return new cc.EaseElasticOut(t, e)
};
cc._easeElasticOutObj = {
	easing: function(t) {
		return 0 === t || 1 === t ? t : Math.pow(2, -10 * t) * Math.sin(2 * (t - .075) * Math.PI / .3) + 1
	},
	reverse: function() {
		return cc._easeElasticInObj
	}
};
cc.easeElasticOut = function(t) {
	return t && .3 !== t ? {
		_period: t,
		easing: function(t) {
			return 0 === t || 1 === t ? t : Math.pow(2, -10 * t) * Math.sin(2 * (t - this._period / 4) * Math.PI / this._period) + 1
		},
		reverse: function() {
			return cc.easeElasticIn(this._period)
		}
	} : cc._easeElasticOutObj
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
	update: function(t) {
		var e = 0,
			e = this._period;
		if (0 === t || 1 == t) e = t;
		else {
			e || (e = this._period = .3 * 1.5);
			var i = e / 4;
			t = 2 * t - 1;
			e = 0 > t ? -.5 * Math.pow(2, 10 * t) * Math.sin(2 * (t - i) * Math.PI / e) : .5 * Math.pow(2, -10 * t) * Math.sin(2 * (t - i) * Math.PI / e) + 1
		}
		this._inner.update(e)
	},
	reverse: function() {
		return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
	},
	clone: function() {
		var t = new cc.EaseElasticInOut;
		t.initWithAction(this._inner.clone(), this._period);
		return t
	}
});
cc.EaseElasticInOut.create = function(t, e) {
	return new cc.EaseElasticInOut(t, e)
};
cc.easeElasticInOut = function(t) {
	return {
		_period: t || .3,
		easing: function(t) {
			var e = 0,
				e = this._period;
			if (0 === t || 1 === t) e = t;
			else {
				e || (e = this._period = .3 * 1.5);
				var i = e / 4;
				t = 2 * t - 1;
				e = 0 > t ? -.5 * Math.pow(2, 10 * t) * Math.sin(2 * (t - i) * Math.PI / e) : .5 * Math.pow(2, -10 * t) * Math.sin(2 * (t - i) * Math.PI / e) + 1
			}
			return e
		},
		reverse: function() {
			return cc.easeElasticInOut(this._period)
		}
	}
};
cc.EaseBounce = cc.ActionEase.extend({
	bounceTime: function(t) {
		if (t < 1 / 2.75) return 7.5625 * t * t;
		if (t < 2 / 2.75) return t -= 1.5 / 2.75, 7.5625 * t * t + .75;
		if (t < 2.5 / 2.75) return t -= 2.25 / 2.75, 7.5625 * t * t + .9375;
		t -= 2.625 / 2.75;
		return 7.5625 * t * t + .984375
	},
	clone: function() {
		var t = new cc.EaseBounce;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseBounce(this._inner.reverse())
	}
});
cc.EaseBounce.create = function(t) {
	return new cc.EaseBounce(t)
};
cc.EaseBounceIn = cc.EaseBounce.extend({
	update: function(t) {
		t = 1 - this.bounceTime(1 - t);
		this._inner.update(t)
	},
	reverse: function() {
		return new cc.EaseBounceOut(this._inner.reverse())
	},
	clone: function() {
		var t = new cc.EaseBounceIn;
		t.initWithAction(this._inner.clone());
		return t
	}
});
cc.EaseBounceIn.create = function(t) {
	return new cc.EaseBounceIn(t)
};
cc._bounceTime = function(t) {
	if (t < 1 / 2.75) return 7.5625 * t * t;
	if (t < 2 / 2.75) return t -= 1.5 / 2.75, 7.5625 * t * t + .75;
	if (t < 2.5 / 2.75) return t -= 2.25 / 2.75, 7.5625 * t * t + .9375;
	t -= 2.625 / 2.75;
	return 7.5625 * t * t + .984375
};
cc._easeBounceInObj = {
	easing: function(t) {
		return 1 - cc._bounceTime(1 - t)
	},
	reverse: function() {
		return cc._easeBounceOutObj
	}
};
cc.easeBounceIn = function() {
	return cc._easeBounceInObj
};
cc.EaseBounceOut = cc.EaseBounce.extend({
	update: function(t) {
		t = this.bounceTime(t);
		this._inner.update(t)
	},
	reverse: function() {
		return new cc.EaseBounceIn(this._inner.reverse())
	},
	clone: function() {
		var t = new cc.EaseBounceOut;
		t.initWithAction(this._inner.clone());
		return t
	}
});
cc.EaseBounceOut.create = function(t) {
	return new cc.EaseBounceOut(t)
};
cc._easeBounceOutObj = {
	easing: function(t) {
		return cc._bounceTime(t)
	},
	reverse: function() {
		return cc._easeBounceInObj
	}
};
cc.easeBounceOut = function() {
	return cc._easeBounceOutObj
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
	update: function(t) {
		var e = 0,
			e = .5 > t ? .5 * (1 - this.bounceTime(1 - 2 * t)) : .5 * this.bounceTime(2 * t - 1) + .5;
		this._inner.update(e)
	},
	clone: function() {
		var t = new cc.EaseBounceInOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseBounceInOut(this._inner.reverse())
	}
});
cc.EaseBounceInOut.create = function(t) {
	return new cc.EaseBounceInOut(t)
};
cc._easeBounceInOutObj = {
	easing: function(t) {
		return t = .5 > t ? .5 * (1 - cc._bounceTime(1 - 2 * t)) : .5 * cc._bounceTime(2 * t - 1) + .5
	},
	reverse: function() {
		return cc._easeBounceInOutObj
	}
};
cc.easeBounceInOut = function() {
	return cc._easeBounceInOutObj
};
cc.EaseBackIn = cc.ActionEase.extend({
	update: function(t) {
		this._inner.update(0 === t || 1 == t ? t : t * t * (2.70158 * t - 1.70158))
	},
	reverse: function() {
		return new cc.EaseBackOut(this._inner.reverse())
	},
	clone: function() {
		var t = new cc.EaseBackIn;
		t.initWithAction(this._inner.clone());
		return t
	}
});
cc.EaseBackIn.create = function(t) {
	return new cc.EaseBackIn(t)
};
cc._easeBackInObj = {
	easing: function(t) {
		return 0 === t || 1 === t ? t : t * t * (2.70158 * t - 1.70158)
	},
	reverse: function() {
		return cc._easeBackOutObj
	}
};
cc.easeBackIn = function() {
	return cc._easeBackInObj
};
cc.EaseBackOut = cc.ActionEase.extend({
	update: function(t) {
		t -= 1;
		this._inner.update(t * t * (2.70158 * t + 1.70158) + 1)
	},
	reverse: function() {
		return new cc.EaseBackIn(this._inner.reverse())
	},
	clone: function() {
		var t = new cc.EaseBackOut;
		t.initWithAction(this._inner.clone());
		return t
	}
});
cc.EaseBackOut.create = function(t) {
	return new cc.EaseBackOut(t)
};
cc._easeBackOutObj = {
	easing: function(t) {
		t -= 1;
		return t * t * (2.70158 * t + 1.70158) + 1
	},
	reverse: function() {
		return cc._easeBackInObj
	}
};
cc.easeBackOut = function() {
	return cc._easeBackOutObj
};
cc.EaseBackInOut = cc.ActionEase.extend({
	update: function(t) {
		t *= 2;
		1 > t ? this._inner.update(t * t * (3.5949095 * t - 2.5949095) / 2) : (t -= 2, this._inner.update(t * t * (3.5949095 * t + 2.5949095) / 2 + 1))
	},
	clone: function() {
		var t = new cc.EaseBackInOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseBackInOut(this._inner.reverse())
	}
});
cc.EaseBackInOut.create = function(t) {
	return new cc.EaseBackInOut(t)
};
cc._easeBackInOutObj = {
	easing: function(t) {
		t *= 2;
		if (1 > t) return t * t * (3.5949095 * t - 2.5949095) / 2;
		t -= 2;
		return t * t * (3.5949095 * t + 2.5949095) / 2 + 1
	},
	reverse: function() {
		return cc._easeBackInOutObj
	}
};
cc.easeBackInOut = function() {
	return cc._easeBackInOutObj
};
cc.EaseBezierAction = cc.ActionEase.extend({
	_p0: null,
	_p1: null,
	_p2: null,
	_p3: null,
	ctor: function(t) {
		cc.ActionEase.prototype.ctor.call(this, t)
	},
	_updateTime: function(t, e, i, n, r) {
		return Math.pow(1 - r, 3) * t + 3 * r * Math.pow(1 - r, 2) * e + 3 * Math.pow(r, 2) * (1 - r) * i + Math.pow(r, 3) * n
	},
	update: function(t) {
		t = this._updateTime(this._p0, this._p1, this._p2, this._p3, t);
		this._inner.update(t)
	},
	clone: function() {
		var t = new cc.EaseBezierAction;
		t.initWithAction(this._inner.clone());
		t.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
		return t
	},
	reverse: function() {
		var t = new cc.EaseBezierAction(this._inner.reverse());
		t.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
		return t
	},
	setBezierParamer: function(t, e, i, n) {
		this._p0 = t || 0;
		this._p1 = e || 0;
		this._p2 = i || 0;
		this._p3 = n || 0
	}
});
cc.EaseBezierAction.create = function(t) {
	return new cc.EaseBezierAction(t)
};
cc.easeBezierAction = function(t, e, i, n) {
	return {
		easing: function(r) {
			return cc.EaseBezierAction.prototype._updateTime(t, e, i, n, r)
		},
		reverse: function() {
			return cc.easeBezierAction(n, i, e, t)
		}
	}
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
	_updateTime: function(t) {
		return Math.pow(t, 2)
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseQuadraticActionIn;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseQuadraticActionIn(this._inner.reverse())
	}
});
cc.EaseQuadraticActionIn.create = function(t) {
	return new cc.EaseQuadraticActionIn(t)
};
cc._easeQuadraticActionIn = {
	easing: cc.EaseQuadraticActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeQuadraticActionIn
	}
};
cc.easeQuadraticActionIn = function() {
	return cc._easeQuadraticActionIn
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		return -t * (t - 2)
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseQuadraticActionOut;
		t.initWithAction();
		return t
	},
	reverse: function() {
		return new cc.EaseQuadraticActionOut(this._inner.reverse())
	}
});
cc.EaseQuadraticActionOut.create = function(t) {
	return new cc.EaseQuadraticActionOut(t)
};
cc._easeQuadraticActionOut = {
	easing: cc.EaseQuadraticActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuadraticActionOut
	}
};
cc.easeQuadraticActionOut = function() {
	return cc._easeQuadraticActionOut
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		var e = t;
		t *= 2;
		1 > t ? e = .5 * t * t : (--t, e = -.5 * (t * (t - 2) - 1));
		return e
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseQuadraticActionInOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseQuadraticActionInOut(this._inner.reverse())
	}
});
cc.EaseQuadraticActionInOut.create = function(t) {
	return new cc.EaseQuadraticActionInOut(t)
};
cc._easeQuadraticActionInOut = {
	easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuadraticActionInOut
	}
};
cc.easeQuadraticActionInOut = function() {
	return cc._easeQuadraticActionInOut
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
	_updateTime: function(t) {
		return t * t * t * t
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseQuarticActionIn;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseQuarticActionIn(this._inner.reverse())
	}
});
cc.EaseQuarticActionIn.create = function(t) {
	return new cc.EaseQuarticActionIn(t)
};
cc._easeQuarticActionIn = {
	easing: cc.EaseQuarticActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeQuarticActionIn
	}
};
cc.easeQuarticActionIn = function() {
	return cc._easeQuarticActionIn
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		t -= 1;
		return -(t * t * t * t - 1)
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseQuarticActionOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseQuarticActionOut(this._inner.reverse())
	}
});
cc.EaseQuarticActionOut.create = function(t) {
	return new cc.EaseQuarticActionOut(t)
};
cc._easeQuarticActionOut = {
	easing: cc.EaseQuarticActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuarticActionOut
	}
};
cc.easeQuarticActionOut = function() {
	return cc._easeQuarticActionOut
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		t *= 2;
		if (1 > t) return .5 * t * t * t * t;
		t -= 2;
		return -.5 * (t * t * t * t - 2)
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseQuarticActionInOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseQuarticActionInOut(this._inner.reverse())
	}
});
cc.EaseQuarticActionInOut.create = function(t) {
	return new cc.EaseQuarticActionInOut(t)
};
cc._easeQuarticActionInOut = {
	easing: cc.EaseQuarticActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuarticActionInOut
	}
};
cc.easeQuarticActionInOut = function() {
	return cc._easeQuarticActionInOut
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
	_updateTime: function(t) {
		return t * t * t * t * t
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseQuinticActionIn;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseQuinticActionIn(this._inner.reverse())
	}
});
cc.EaseQuinticActionIn.create = function(t) {
	return new cc.EaseQuinticActionIn(t)
};
cc._easeQuinticActionIn = {
	easing: cc.EaseQuinticActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeQuinticActionIn
	}
};
cc.easeQuinticActionIn = function() {
	return cc._easeQuinticActionIn
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		t -= 1;
		return t * t * t * t * t + 1
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseQuinticActionOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseQuinticActionOut(this._inner.reverse())
	}
});
cc.EaseQuinticActionOut.create = function(t) {
	return new cc.EaseQuinticActionOut(t)
};
cc._easeQuinticActionOut = {
	easing: cc.EaseQuinticActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuinticActionOut
	}
};
cc.easeQuinticActionOut = function() {
	return cc._easeQuinticActionOut
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		t *= 2;
		if (1 > t) return .5 * t * t * t * t * t;
		t -= 2;
		return .5 * (t * t * t * t * t + 2)
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseQuinticActionInOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseQuinticActionInOut(this._inner.reverse())
	}
});
cc.EaseQuinticActionInOut.create = function(t) {
	return new cc.EaseQuinticActionInOut(t)
};
cc._easeQuinticActionInOut = {
	easing: cc.EaseQuinticActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuinticActionInOut
	}
};
cc.easeQuinticActionInOut = function() {
	return cc._easeQuinticActionInOut
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
	_updateTime: function(t) {
		return -1 * (Math.sqrt(1 - t * t) - 1)
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseCircleActionIn;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseCircleActionIn(this._inner.reverse())
	}
});
cc.EaseCircleActionIn.create = function(t) {
	return new cc.EaseCircleActionIn(t)
};
cc._easeCircleActionIn = {
	easing: cc.EaseCircleActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeCircleActionIn
	}
};
cc.easeCircleActionIn = function() {
	return cc._easeCircleActionIn
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		t -= 1;
		return Math.sqrt(1 - t * t)
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseCircleActionOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseCircleActionOut(this._inner.reverse())
	}
});
cc.EaseCircleActionOut.create = function(t) {
	return new cc.EaseCircleActionOut(t)
};
cc._easeCircleActionOut = {
	easing: cc.EaseCircleActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCircleActionOut
	}
};
cc.easeCircleActionOut = function() {
	return cc._easeCircleActionOut
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		t *= 2;
		if (1 > t) return -.5 * (Math.sqrt(1 - t * t) - 1);
		t -= 2;
		return .5 * (Math.sqrt(1 - t * t) + 1)
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseCircleActionInOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseCircleActionInOut(this._inner.reverse())
	}
});
cc.EaseCircleActionInOut.create = function(t) {
	return new cc.EaseCircleActionInOut(t)
};
cc._easeCircleActionInOut = {
	easing: cc.EaseCircleActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCircleActionInOut
	}
};
cc.easeCircleActionInOut = function() {
	return cc._easeCircleActionInOut
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
	_updateTime: function(t) {
		return t * t * t
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseCubicActionIn;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseCubicActionIn(this._inner.reverse())
	}
});
cc.EaseCubicActionIn.create = function(t) {
	return new cc.EaseCubicActionIn(t)
};
cc._easeCubicActionIn = {
	easing: cc.EaseCubicActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeCubicActionIn
	}
};
cc.easeCubicActionIn = function() {
	return cc._easeCubicActionIn
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		t -= 1;
		return t * t * t + 1
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseCubicActionOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseCubicActionOut(this._inner.reverse())
	}
});
cc.EaseCubicActionOut.create = function(t) {
	return new cc.EaseCubicActionOut(t)
};
cc._easeCubicActionOut = {
	easing: cc.EaseCubicActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCubicActionOut
	}
};
cc.easeCubicActionOut = function() {
	return cc._easeCubicActionOut
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
	_updateTime: function(t) {
		t *= 2;
		if (1 > t) return .5 * t * t * t;
		t -= 2;
		return .5 * (t * t * t + 2)
	},
	update: function(t) {
		this._inner.update(this._updateTime(t))
	},
	clone: function() {
		var t = new cc.EaseCubicActionInOut;
		t.initWithAction(this._inner.clone());
		return t
	},
	reverse: function() {
		return new cc.EaseCubicActionInOut(this._inner.reverse())
	}
});
cc.EaseCubicActionInOut.create = function(t) {
	return new cc.EaseCubicActionInOut(t)
};
cc._easeCubicActionInOut = {
	easing: cc.EaseCubicActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCubicActionInOut
	}
};
cc.easeCubicActionInOut = function() {
	return cc._easeCubicActionInOut
};
cc.cardinalSplineAt = function(t, e, i, n, r, c) {
	var s = c * c,
		o = s * c,
		a = (1 - r) / 2;
	r = a * (-o + 2 * s - c);
	var h = a * (-o + s) + (2 * o - 3 * s + 1);
	c = a * (o - 2 * s + c) + (-2 * o + 3 * s);
	s = a * (o - s);
	return cc.p(t.x * r + e.x * h + i.x * c + n.x * s, t.y * r + e.y * h + i.y * c + n.y * s)
};
cc.reverseControlPoints = function(t) {
	for (var e = [], i = t.length - 1; 0 <= i; i--) e.push(cc.p(t[i].x, t[i].y));
	return e
};
cc.cloneControlPoints = function(t) {
	for (var e = [], i = 0; i < t.length; i++) e.push(cc.p(t[i].x, t[i].y));
	return e
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function(t, e) {
	var i = Math.min(t.length - 1, Math.max(e, 0));
	return t[i]
};
cc.reverseControlPointsInline = function(t) {
	for (var e = t.length, i = 0 | e / 2, n = 0; n < i; ++n) {
		var r = t[n];
		t[n] = t[e - n - 1];
		t[e - n - 1] = r
	}
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
	_points: null,
	_deltaT: 0,
	_tension: 0,
	_previousPosition: null,
	_accumulatedDiff: null,
	ctor: function(t, e, i) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._points = [];
		void 0 !== i && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		if (!e || 0 == e.length) throw "Invalid configuration. It must at least have one control point";
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this.setPoints(e), this._tension = i, !0) : !1
	},
	clone: function() {
		var t = new cc.CardinalSplineTo;
		t.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._deltaT = 1 / (this._points.length - 1);
		this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
		this._accumulatedDiff = cc.p(0, 0)
	},
	update: function(t) {
		t = this._computeEaseTime(t);
		var e, i = this._points;
		if (1 == t) e = i.length - 1, t = 1;
		else {
			var n = this._deltaT;
			e = 0 | t / n;
			t = (t - n * e) / n
		}
		e = cc.cardinalSplineAt(cc.getControlPointAt(i, e - 1), cc.getControlPointAt(i, e - 0), cc.getControlPointAt(i, e + 1), cc.getControlPointAt(i, e + 2), this._tension, t);
		if (cc.ENABLE_STACKABLE_ACTIONS && (i = this.target.getPositionX() - this._previousPosition.x, t = this.target.getPositionY() - this._previousPosition.y, 0 != i || 0 != t)) n = this._accumulatedDiff, i = n.x + i, t = n.y + t, n.x = i, n.y = t, e.x += i, e.y += t;
		this.updatePosition(e)
	},
	reverse: function() {
		var t = cc.reverseControlPoints(this._points);
		return cc.cardinalSplineTo(this._duration, t, this._tension)
	},
	updatePosition: function(t) {
		this.target.setPosition(t);
		this._previousPosition = t
	},
	getPoints: function() {
		return this._points
	},
	setPoints: function(t) {
		this._points = t
	}
});
cc.cardinalSplineTo = function(t, e, i) {
	return new cc.CardinalSplineTo(t, e, i)
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
	_startPosition: null,
	ctor: function(t, e, i) {
		cc.CardinalSplineTo.prototype.ctor.call(this);
		this._startPosition = cc.p(0, 0);
		void 0 !== i && this.initWithDuration(t, e, i)
	},
	startWithTarget: function(t) {
		cc.CardinalSplineTo.prototype.startWithTarget.call(this, t);
		this._startPosition.x = t.getPositionX();
		this._startPosition.y = t.getPositionY()
	},
	reverse: function() {
		for (var t = this._points.slice(), e, i = t[0], n = 1; n < t.length; ++n) e = t[n], t[n] = cc.pSub(e, i), i = e;
		t = cc.reverseControlPoints(t);
		i = t[t.length - 1];
		t.pop();
		i.x = -i.x;
		i.y = -i.y;
		t.unshift(i);
		for (n = 1; n < t.length; ++n) e = t[n], e.x = -e.x, e.y = -e.y, e.x += i.x, e.y += i.y, i = t[n] = e;
		return cc.cardinalSplineBy(this._duration, t, this._tension)
	},
	updatePosition: function(t) {
		var e = this._startPosition,
			i = t.x + e.x;
		t = t.y + e.y;
		this._previousPosition.x = i;
		this._previousPosition.y = t;
		this.target.setPosition(i, t)
	},
	clone: function() {
		var t = new cc.CardinalSplineBy;
		t.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
		return t
	}
});
cc.cardinalSplineBy = function(t, e, i) {
	return new cc.CardinalSplineBy(t, e, i)
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
	ctor: function(t, e) {
		e && this.initWithDuration(t, e)
	},
	initWithDuration: function(t, e) {
		return cc.CardinalSplineTo.prototype.initWithDuration.call(this, t, e, .5)
	},
	clone: function() {
		var t = new cc.CatmullRomTo;
		t.initWithDuration(this._duration, cc.copyControlPoints(this._points));
		return t
	}
});
cc.catmullRomTo = function(t, e) {
	return new cc.CatmullRomTo(t, e)
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
	ctor: function(t, e) {
		cc.CardinalSplineBy.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	initWithDuration: function(t, e) {
		return cc.CardinalSplineTo.prototype.initWithDuration.call(this, t, e, .5)
	},
	clone: function() {
		var t = new cc.CatmullRomBy;
		t.initWithDuration(this._duration, cc.copyControlPoints(this._points));
		return t
	}
});
cc.catmullRomBy = function(t, e) {
	return new cc.CatmullRomBy(t, e)
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
	updateTweenAction: function(t, e) {}
});
cc.ActionTween = cc.ActionInterval.extend({
	key: "",
	from: 0,
	to: 0,
	delta: 0,
	ctor: function(t, e, i, n) {
		cc.ActionInterval.prototype.ctor.call(this);
		this.key = "";
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	initWithDuration: function(t, e, i, n) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this.key = e, this.to = n, this.from = i, !0) : !1
	},
	startWithTarget: function(t) {
		if (!t || !t.updateTweenAction) throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this.delta = this.to - this.from
	},
	update: function(t) {
		this.target.updateTweenAction(this.to - this.delta * (1 - t), this.key)
	},
	reverse: function() {
		return new cc.ActionTween(this.duration, this.key, this.to, this.from)
	},
	clone: function() {
		var t = new cc.ActionTween;
		t.initWithDuration(this._duration, this.key, this.from, this.to);
		return t
	}
});
cc.actionTween = function(t, e, i, n) {
	return new cc.ActionTween(t, e, i, n)
};
cc.ActionTween.create = cc.actionTween;
cc.GridAction = cc.ActionInterval.extend({
	_gridSize: null,
	ctor: function(t, e) {
		cc._checkWebGLRenderMode();
		cc.ActionInterval.prototype.ctor.call(this);
		this._gridSize = cc.size(0, 0);
		e && this.initWithDuration(t, e)
	},
	clone: function() {
		var t = new cc.GridAction,
			e = this._gridSize;
		t.initWithDuration(this._duration, cc.size(e.width, e.height));
		return t
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		cc.renderer.childrenOrderDirty = !0;
		var e = this.getGrid(),
			i = this.target;
		(t = i.grid) && 0 < t.getReuseGrid() ? (e = t.getGridSize(), t.isActive() && (e.width == this._gridSize.width && e.height == this._gridSize.height) && t.reuse()) : (t && t.isActive() && t.setActive(!1), i.grid = e, i.grid.setActive(!0))
	},
	reverse: function() {
		return new cc.ReverseTime(this)
	},
	initWithDuration: function(t, e) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._gridSize.width = e.width, this._gridSize.height = e.height, !0) : !1
	},
	getGrid: function() {
		cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
	}
});
cc.gridAction = function(t, e) {
	return new cc.GridAction(t, e)
};
cc.GridAction.create = cc.gridAction;
cc.Grid3DAction = cc.GridAction.extend({
	getGrid: function() {
		return new cc.Grid3D(this._gridSize)
	},
	vertex: function(t) {
		return this.target.grid.vertex(t)
	},
	originalVertex: function(t) {
		return this.target.grid.originalVertex(t)
	},
	setVertex: function(t, e) {
		this.target.grid.setVertex(t, e)
	}
});
cc.grid3DAction = function(t, e) {
	return new cc.Grid3DAction(t, e)
};
cc.Grid3DAction.create = cc.grid3DAction;
cc.TiledGrid3DAction = cc.GridAction.extend({
	tile: function(t) {
		return this.target.grid.tile(t)
	},
	originalTile: function(t) {
		return this.target.grid.originalTile(t)
	},
	setTile: function(t, e) {
		this.target.grid.setTile(t, e)
	},
	getGrid: function() {
		return new cc.TiledGrid3D(this._gridSize)
	}
});
cc.tiledGrid3DAction = function(t, e) {
	return new cc.TiledGrid3DAction(t, e)
};
cc.TiledGrid3DAction.create = cc.tiledGrid3DAction;
cc.StopGrid = cc.ActionInstant.extend({
	startWithTarget: function(t) {
		cc.ActionInstant.prototype.startWithTarget.call(this, t);
		cc.renderer.childrenOrderDirty = !0;
		(t = this.target.grid) && t.isActive() && t.setActive(!1)
	}
});
cc.stopGrid = function() {
	return new cc.StopGrid
};
cc.StopGrid.create = cc.stopGrid;
cc.ReuseGrid = cc.ActionInstant.extend({
	_times: null,
	ctor: function(t) {
		cc.ActionInstant.prototype.ctor.call(this);
		void 0 !== t && this.initWithTimes(t)
	},
	initWithTimes: function(t) {
		this._times = t;
		return !0
	},
	startWithTarget: function(t) {
		cc.ActionInstant.prototype.startWithTarget.call(this, t);
		cc.renderer.childrenOrderDirty = !0;
		this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
	}
});
cc.reuseGrid = function(t) {
	return new cc.ReuseGrid(t)
};
cc.ReuseGrid.create = cc.reuseGrid;
cc.Waves3D = cc.Grid3DAction.extend({
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(t, e, i, n) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(t) {
		this._amplitude = t
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(t) {
		this._amplitudeRate = t
	},
	initWithDuration: function(t, e, i, n) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._waves = i, this._amplitude = n, this._amplitudeRate = 1, !0) : !1
	},
	update: function(t) {
		for (var e = this._gridSize, i = this._amplitude, n = cc.p(0, 0), r = this._amplitudeRate, c = this._waves, s = 0; s < e.width + 1; ++s) for (var o = 0; o < e.height + 1; ++o) {
			n.x = s;
			n.y = o;
			var a = this.originalVertex(n);
			a.z += Math.sin(2 * Math.PI * t * c + .01 * (a.y + a.x)) * i * r;
			this.setVertex(n, a)
		}
	}
});
cc.waves3D = function(t, e, i, n) {
	return new cc.Waves3D(t, e, i, n)
};
cc.Waves3D.create = cc.waves3D;
cc.FlipX3D = cc.Grid3DAction.extend({
	ctor: function(t) {
		void 0 !== t ? cc.GridAction.prototype.ctor.call(this, t, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
	},
	initWithDuration: function(t) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, t, cc.size(1, 1))
	},
	initWithSize: function(t, e) {
		return 1 != t.width || 1 != t.height ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, e, t)
	},
	update: function(t) {
		var e = Math.PI * t;
		t = Math.sin(e);
		var i = Math.cos(e / 2),
			e = new cc.Vertex3F,
			n = cc.p(0, 0);
		n.x = n.y = 1;
		var r = this.originalVertex(n);
		n.x = n.y = 0;
		var n = this.originalVertex(n),
			c = r.x,
			s = n.x,
			o, a;
		c > s ? (r = cc.p(0, 0), n = cc.p(0, 1), o = cc.p(1, 0), a = cc.p(1, 1)) : (o = cc.p(0, 0), a = cc.p(0, 1), r = cc.p(1, 0), n = cc.p(1, 1), c = s);
		e.x = c - c * i;
		e.z = Math.abs(parseFloat(c * t / 4));
		t = this.originalVertex(r);
		t.x = e.x;
		t.z += e.z;
		this.setVertex(r, t);
		t = this.originalVertex(n);
		t.x = e.x;
		t.z += e.z;
		this.setVertex(n, t);
		t = this.originalVertex(o);
		t.x -= e.x;
		t.z -= e.z;
		this.setVertex(o, t);
		t = this.originalVertex(a);
		t.x -= e.x;
		t.z -= e.z;
		this.setVertex(a, t)
	}
});
cc.flipX3D = function(t) {
	return new cc.FlipX3D(t)
};
cc.FlipX3D.create = cc.flipX3D;
cc.FlipY3D = cc.FlipX3D.extend({
	ctor: function(t) {
		void 0 !== t ? cc.GridAction.prototype.ctor.call(this, t, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
	},
	update: function(t) {
		var e = Math.PI * t;
		t = Math.sin(e);
		var i = Math.cos(e / 2),
			e = new cc.Vertex3F,
			n = cc.p(0, 0);
		n.x = n.y = 1;
		var r = this.originalVertex(n);
		n.x = n.y = 0;
		var n = this.originalVertex(n),
			c = r.y,
			s = n.y,
			o, a;
		c > s ? (r = cc.p(0, 0), n = cc.p(0, 1), o = cc.p(1, 0), a = cc.p(1, 1)) : (n = cc.p(0, 0), r = cc.p(0, 1), a = cc.p(1, 0), o = cc.p(1, 1), c = s);
		e.y = c - c * i;
		e.z = Math.abs(parseFloat(c * t) / 4);
		t = this.originalVertex(r);
		t.y = e.y;
		t.z += e.z;
		this.setVertex(r, t);
		t = this.originalVertex(n);
		t.y -= e.y;
		t.z -= e.z;
		this.setVertex(n, t);
		t = this.originalVertex(o);
		t.y = e.y;
		t.z += e.z;
		this.setVertex(o, t);
		t = this.originalVertex(a);
		t.y -= e.y;
		t.z -= e.z;
		this.setVertex(a, t)
	}
});
cc.flipY3D = function(t) {
	return new cc.FlipY3D(t)
};
cc.FlipY3D.create = cc.flipY3D;
cc.Lens3D = cc.Grid3DAction.extend({
	_position: null,
	_radius: 0,
	_lensEffect: 0,
	_concave: !1,
	_dirty: !1,
	ctor: function(t, e, i, n) {
		cc.GridAction.prototype.ctor.call(this);
		this._position = cc.p(0, 0);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	getLensEffect: function() {
		return this._lensEffect
	},
	setLensEffect: function(t) {
		this._lensEffect = t
	},
	setConcave: function(t) {
		this._concave = t
	},
	getPosition: function() {
		return this._position
	},
	setPosition: function(t) {
		cc.pointEqualToPoint(t, this._position) || (this._position.x = t.x, this._position.y = t.y, this._dirty = !0)
	},
	initWithDuration: function(t, e, i, n) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this.setPosition(i), this._radius = n, this._lensEffect = .7, this._dirty = !0) : !1
	},
	update: function(t) {
		if (this._dirty) {
			t = this._gridSize.width;
			for (var e = this._gridSize.height, i = this._radius, n = this._lensEffect, r = cc.p(0, 0), c = cc.p(0, 0), s, o, a, h = 0; h < t + 1; ++h) for (var l = 0; l < e + 1; ++l) r.x = h, r.y = l, s = this.originalVertex(r), c.x = this._position.x - s.x, c.y = this._position.y - s.y, o = cc.pLength(c), o < i && (o = i - o, o /= i, 0 == o && (o = .001), o = Math.log(o) * n, a = Math.exp(o) * i, o = cc.pLength(c), 0 < o && (c.x /= o, c.y /= o, c.x *= a, c.y *= a, s.z += cc.pLength(c) * n)), this.setVertex(r, s);
			this._dirty = !1
		}
	}
});
cc.lens3D = function(t, e, i, n) {
	return new cc.Lens3D(t, e, i, n)
};
cc.Lens3D.create = cc.lens3D;
cc.Ripple3D = cc.Grid3DAction.extend({
	_position: null,
	_radius: 0,
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(t, e, i, n, r, c) {
		cc.GridAction.prototype.ctor.call(this);
		this._position = cc.p(0, 0);
		void 0 !== c && this.initWithDuration(t, e, i, n, r, c)
	},
	getPosition: function() {
		return this._position
	},
	setPosition: function(t) {
		this._position.x = t.x;
		this._position.y = t.y
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(t) {
		this._amplitude = t
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(t) {
		this._amplitudeRate = t
	},
	initWithDuration: function(t, e, i, n, r, c) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this.setPosition(i), this._radius = n, this._waves = r, this._amplitude = c, this._amplitudeRate = 1, !0) : !1
	},
	update: function(t) {
		for (var e = this._gridSize.width, i = this._gridSize.height, n = cc.p(0, 0), r = this._radius, c = this._waves, s = this._amplitude, o = this._amplitudeRate, a, h, l = cc.p(0, 0), u = 0; u < e + 1; ++u) for (var d = 0; d < i + 1; ++d) {
			n.x = u;
			n.y = d;
			a = this.originalVertex(n);
			l.x = this._position.x - a.x;
			l.y = this._position.y - a.y;
			h = cc.pLength(l);
			if (h < r) {
				h = r - h;
				var _ = Math.pow(h / r, 2);
				a.z += Math.sin(2 * t * Math.PI * c + .1 * h) * s * o * _
			}
			this.setVertex(n, a)
		}
	}
});
cc.ripple3D = function(t, e, i, n, r, c) {
	return new cc.Ripple3D(t, e, i, n, r, c)
};
cc.Ripple3D.create = cc.ripple3D;
cc.Shaky3D = cc.Grid3DAction.extend({
	_randRange: 0,
	_shakeZ: !1,
	ctor: function(t, e, i, n) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	initWithDuration: function(t, e, i, n) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._randRange = i, this._shakeZ = n, !0) : !1
	},
	update: function(t) {
		t = this._gridSize.width;
		for (var e = this._gridSize.height, i = this._randRange, n = this._shakeZ, r = cc.p(0, 0), c, s = 0; s < t + 1; ++s) for (var o = 0; o < e + 1; ++o) r.x = s, r.y = o, c = this.originalVertex(r), c.x += cc.rand() % (2 * i) - i, c.y += cc.rand() % (2 * i) - i, n && (c.z += cc.rand() % (2 * i) - i), this.setVertex(r, c)
	}
});
cc.shaky3D = function(t, e, i, n) {
	return new cc.Shaky3D(t, e, i, n)
};
cc.Shaky3D.create = cc.shaky3D;
cc.Liquid = cc.Grid3DAction.extend({
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(t, e, i, n) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(t) {
		this._amplitude = t
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(t) {
		this._amplitudeRate = t
	},
	initWithDuration: function(t, e, i, n) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._waves = i, this._amplitude = n, this._amplitudeRate = 1, !0) : !1
	},
	update: function(t) {
		for (var e = this._gridSize.width, i = this._gridSize.height, n = cc.p(0, 0), r = this._waves, c = this._amplitude, s = this._amplitudeRate, o, a = 1; a < e; ++a) for (var h = 1; h < i; ++h) n.x = a, n.y = h, o = this.originalVertex(n), o.x += Math.sin(2 * t * Math.PI * r + .01 * o.x) * c * s, o.y += Math.sin(2 * t * Math.PI * r + .01 * o.y) * c * s, this.setVertex(n, o)
	}
});
cc.liquid = function(t, e, i, n) {
	return new cc.Liquid(t, e, i, n)
};
cc.Liquid.create = cc.liquid;
cc.Waves = cc.Grid3DAction.extend({
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	_vertical: !1,
	_horizontal: !1,
	ctor: function(t, e, i, n, r, c) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== c && this.initWithDuration(t, e, i, n, r, c)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(t) {
		this._amplitude = t
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(t) {
		this._amplitudeRate = t
	},
	initWithDuration: function(t, e, i, n, r, c) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._waves = i, this._amplitude = n, this._amplitudeRate = 1, this._horizontal = r, this._vertical = c, !0) : !1
	},
	update: function(t) {
		for (var e = this._gridSize.width, i = this._gridSize.height, n = cc.p(0, 0), r = this._vertical, c = this._horizontal, s = this._waves, o = this._amplitude, a = this._amplitudeRate, h, l = 0; l < e + 1; ++l) for (var u = 0; u < i + 1; ++u) n.x = l, n.y = u, h = this.originalVertex(n), r && (h.x += Math.sin(2 * t * Math.PI * s + .01 * h.y) * o * a), c && (h.y += Math.sin(2 * t * Math.PI * s + .01 * h.x) * o * a), this.setVertex(n, h)
	}
});
cc.waves = function(t, e, i, n, r, c) {
	return new cc.Waves(t, e, i, n, r, c)
};
cc.Waves.create = cc.waves;
cc.Twirl = cc.Grid3DAction.extend({
	_position: null,
	_twirls: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(t, e, i, n, r) {
		cc.GridAction.prototype.ctor.call(this);
		this._position = cc.p(0, 0);
		void 0 !== r && this.initWithDuration(t, e, i, n, r)
	},
	getPosition: function() {
		return this._position
	},
	setPosition: function(t) {
		this._position.x = t.x;
		this._position.y = t.y
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(t) {
		this._amplitude = t
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(t) {
		this._amplitudeRate = t
	},
	initWithDuration: function(t, e, i, n, r) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this.setPosition(i), this._twirls = n, this._amplitude = r, this._amplitudeRate = 1, !0) : !1
	},
	update: function(t) {
		for (var e = this._position, i = this._gridSize.width, n = this._gridSize.height, r = cc.p(0, 0), c = .1 * this._amplitude * this._amplitudeRate, s = this._twirls, o, a, h, l = cc.p(0, 0), u = 0; u < i + 1; ++u) for (var d = 0; d < n + 1; ++d) r.x = u, r.y = d, o = this.originalVertex(r), l.x = u - i / 2, l.y = d - n / 2, a = cc.pLength(l) * Math.cos(Math.PI / 2 + 2 * t * Math.PI * s) * c, h = Math.sin(a) * (o.y - e.y) + Math.cos(a) * (o.x - e.x), a = Math.cos(a) * (o.y - e.y) - Math.sin(a) * (o.x - e.x), o.x = e.x + h, o.y = e.y + a, this.setVertex(r, o)
	}
});
cc.twirl = function(t, e, i, n, r) {
	return new cc.Twirl(t, e, i, n, r)
};
cc.Twirl.create = cc.twirl;
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
	_randRange: 0,
	_shakeZ: !1,
	ctor: function(t, e, i, n) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	initWithDuration: function(t, e, i, n) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._randRange = i, this._shakeZ = n, !0) : !1
	},
	update: function(t) {
		t = this._gridSize;
		for (var e = this._randRange, i = cc.p(0, 0), n = 0; n < t.width; ++n) for (var r = 0; r < t.height; ++r) {
			i.x = n;
			i.y = r;
			var c = this.originalTile(i);
			c.bl.x += cc.rand() % (2 * e) - e;
			c.br.x += cc.rand() % (2 * e) - e;
			c.tl.x += cc.rand() % (2 * e) - e;
			c.tr.x += cc.rand() % (2 * e) - e;
			c.bl.y += cc.rand() % (2 * e) - e;
			c.br.y += cc.rand() % (2 * e) - e;
			c.tl.y += cc.rand() % (2 * e) - e;
			c.tr.y += cc.rand() % (2 * e) - e;
			this._shakeZ && (c.bl.z += cc.rand() % (2 * e) - e, c.br.z += cc.rand() % (2 * e) - e, c.tl.z += cc.rand() % (2 * e) - e, c.tr.z += cc.rand() % (2 * e) - e);
			this.setTile(i, c)
		}
	}
});
cc.shakyTiles3D = function(t, e, i, n) {
	return new cc.ShakyTiles3D(t, e, i, n)
};
cc.ShakyTiles3D.create = cc.shakyTiles3D;
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
	_randRange: 0,
	_once: !1,
	_shatterZ: !1,
	ctor: function(t, e, i, n) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	initWithDuration: function(t, e, i, n) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._once = !1, this._randRange = i, this._shatterZ = n, !0) : !1
	},
	update: function(t) {
		if (!1 === this._once) {
			t = this._gridSize;
			for (var e = this._randRange, i, n = cc.p(0, 0), r = 0; r < t.width; ++r) for (var c = 0; c < t.height; ++c) n.x = r, n.y = c, i = this.originalTile(n), i.bl.x += cc.rand() % (2 * e) - e, i.br.x += cc.rand() % (2 * e) - e, i.tl.x += cc.rand() % (2 * e) - e, i.tr.x += cc.rand() % (2 * e) - e, i.bl.y += cc.rand() % (2 * e) - e, i.br.y += cc.rand() % (2 * e) - e, i.tl.y += cc.rand() % (2 * e) - e, i.tr.y += cc.rand() % (2 * e) - e, this._shatterZ && (i.bl.z += cc.rand() % (2 * e) - e, i.br.z += cc.rand() % (2 * e) - e, i.tl.z += cc.rand() % (2 * e) - e, i.tr.z += cc.rand() % (2 * e) - e), this.setTile(n, i);
			this._once = !0
		}
	}
});
cc.shatteredTiles3D = function(t, e, i, n) {
	return new cc.ShatteredTiles3D(t, e, i, n)
};
cc.ShatteredTiles3D.create = cc.shatteredTiles3D;
cc.Tile = function(t, e, i) {
	this.position = t || cc.p(0, 0);
	this.startPosition = e || cc.p(0, 0);
	this.delta = i || cc.p(0, 0)
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
	_seed: 0,
	_tilesCount: 0,
	_tilesOrder: null,
	_tiles: null,
	ctor: function(t, e, i) {
		cc.GridAction.prototype.ctor.call(this);
		this._tilesOrder = [];
		this._tiles = [];
		void 0 !== i && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._seed = i, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1
	},
	shuffle: function(t, e) {
		for (var i = e - 1; 0 <= i; i--) {
			var n = 0 | cc.rand() % (i + 1),
				r = t[i];
			t[i] = t[n];
			t[n] = r
		}
	},
	getDelta: function(t) {
		var e = this._gridSize,
			i = t.width * e.height + t.height;
		return cc.size(this._tilesOrder[i] / e.height - t.width, this._tilesOrder[i] % e.height - t.height)
	},
	placeTile: function(t, e) {
		var i = this.originalTile(t),
			n = this.target.grid.getStep(),
			r = e.position;
		i.bl.x += r.x * n.x;
		i.bl.y += r.y * n.y;
		i.br.x += r.x * n.x;
		i.br.y += r.y * n.y;
		i.tl.x += r.x * n.x;
		i.tl.y += r.y * n.y;
		i.tr.x += r.x * n.x;
		i.tr.y += r.y * n.y;
		this.setTile(t, i)
	},
	startWithTarget: function(t) {
		cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t);
		t = this._gridSize;
		this._tilesCount = t.width * t.height;
		for (var e = this._tilesOrder, i = e.length = 0; i < this._tilesCount; ++i) e[i] = i;
		this.shuffle(e, this._tilesCount);
		for (var e = this._tiles, i = e.length = 0, n = cc.size(0, 0), r = 0; r < t.width; ++r) for (var c = 0; c < t.height; ++c) e[i] = new cc.Tile, e[i].position = cc.p(r, c), e[i].startPosition = cc.p(r, c), n.width = r, n.height = c, e[i].delta = this.getDelta(n), ++i
	},
	update: function(t) {
		for (var e = 0, i = this._gridSize, n = this._tiles, r, c = cc.p(0, 0), s = 0; s < i.width; ++s) for (var o = 0; o < i.height; ++o) c.x = s, c.y = o, r = n[e], r.position.x = r.delta.width * t, r.position.y = r.delta.height * t, this.placeTile(c, r), ++e
	}
});
cc.shuffleTiles = function(t, e, i) {
	return new cc.ShuffleTiles(t, e, i)
};
cc.ShuffleTiles.create = cc.shuffleTiles;
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
	testFunc: function(t, e) {
		var i = this._gridSize.width * e,
			n = this._gridSize.height * e;
		return 0 == i + n ? 1 : Math.pow((t.width + t.height) / (i + n), 6)
	},
	turnOnTile: function(t) {
		this.setTile(t, this.originalTile(t))
	},
	turnOffTile: function(t) {
		this.setTile(t, new cc.Quad3)
	},
	transformTile: function(t, e) {
		var i = this.originalTile(t),
			n = this.target.grid.getStep();
		i.bl.x += n.x / 2 * (1 - e);
		i.bl.y += n.y / 2 * (1 - e);
		i.br.x -= n.x / 2 * (1 - e);
		i.br.y += n.y / 2 * (1 - e);
		i.tl.x += n.x / 2 * (1 - e);
		i.tl.y -= n.y / 2 * (1 - e);
		i.tr.x -= n.x / 2 * (1 - e);
		i.tr.y -= n.y / 2 * (1 - e);
		this.setTile(t, i)
	},
	update: function(t) {
		for (var e = this._gridSize, i = cc.p(0, 0), n = cc.size(0, 0), r, c = 0; c < e.width; ++c) for (var s = 0; s < e.height; ++s) i.x = c, i.y = s, n.width = c, n.height = s, r = this.testFunc(n, t), 0 == r ? this.turnOffTile(i) : 1 > r ? this.transformTile(i, r) : this.turnOnTile(i)
	}
});
cc.fadeOutTRTiles = function(t, e) {
	return new cc.FadeOutTRTiles(t, e)
};
cc.FadeOutTRTiles.create = cc.fadeOutTRTiles;
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
	testFunc: function(t, e) {
		return 0 == t.width + t.height ? 1 : Math.pow((this._gridSize.width * (1 - e) + this._gridSize.height * (1 - e)) / (t.width + t.height), 6)
	}
});
cc.fadeOutBLTiles = function(t, e) {
	return new cc.FadeOutBLTiles(t, e)
};
cc.FadeOutBLTiles.create = cc.fadeOutBLTiles;
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
	testFunc: function(t, e) {
		var i = this._gridSize.height * e;
		return 0 == i ? 1 : Math.pow(t.height / i, 6)
	},
	transformTile: function(t, e) {
		var i = this.originalTile(t),
			n = this.target.grid.getStep();
		i.bl.y += n.y / 2 * (1 - e);
		i.br.y += n.y / 2 * (1 - e);
		i.tl.y -= n.y / 2 * (1 - e);
		i.tr.y -= n.y / 2 * (1 - e);
		this.setTile(t, i)
	}
});
cc.fadeOutUpTiles = function(t, e) {
	return new cc.FadeOutUpTiles(t, e)
};
cc.FadeOutUpTiles.create = cc.fadeOutUpTiles;
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
	testFunc: function(t, e) {
		return 0 == t.height ? 1 : Math.pow(this._gridSize.height * (1 - e) / t.height, 6)
	}
});
cc.fadeOutDownTiles = function(t, e) {
	return new cc.FadeOutDownTiles(t, e)
};
cc.FadeOutDownTiles.create = cc.fadeOutDownTiles;
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
	_seed: null,
	_tilesCount: 0,
	_tilesOrder: null,
	ctor: function(t, e, i) {
		cc.GridAction.prototype.ctor.call(this);
		this._tilesOrder = [];
		void 0 !== e && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._seed = i || 0, this._tilesOrder.length = 0, !0) : !1
	},
	shuffle: function(t, e) {
		for (var i = e - 1; 0 <= i; i--) {
			var n = 0 | cc.rand() % (i + 1),
				r = t[i];
			t[i] = t[n];
			t[n] = r
		}
	},
	turnOnTile: function(t) {
		this.setTile(t, this.originalTile(t))
	},
	turnOffTile: function(t) {
		this.setTile(t, new cc.Quad3)
	},
	startWithTarget: function(t) {
		cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t);
		this._tilesCount = this._gridSize.width * this._gridSize.height;
		t = this._tilesOrder;
		for (var e = t.length = 0; e < this._tilesCount; ++e) t[e] = e;
		this.shuffle(t, this._tilesCount)
	},
	update: function(t) {
		t = 0 | t * this._tilesCount;
		for (var e = this._gridSize, i, n = cc.p(0, 0), r = this._tilesOrder, c = 0; c < this._tilesCount; c++) i = r[c], n.x = 0 | i / e.height, n.y = i % (0 | e.height), c < t ? this.turnOffTile(n) : this.turnOnTile(n)
	}
});
cc.turnOffTiles = function(t, e, i) {
	return new cc.TurnOffTiles(t, e, i)
};
cc.TurnOffTiles.create = cc.turnOffTiles;
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(t, e, i, n) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(t) {
		this._amplitude = t
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(t) {
		this._amplitudeRate = t
	},
	initWithDuration: function(t, e, i, n) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._waves = i, this._amplitude = n, this._amplitudeRate = 1, !0) : !1
	},
	update: function(t) {
		for (var e = this._gridSize, i = this._waves, n = this._amplitude, r = this._amplitudeRate, c = cc.p(0, 0), s, o = 0; o < e.width; o++) for (var a = 0; a < e.height; a++) c.x = o, c.y = a, s = this.originalTile(c), s.bl.z = Math.sin(2 * t * Math.PI * i + .01 * (s.bl.y + s.bl.x)) * n * r, s.br.z = s.bl.z, s.tl.z = s.bl.z, s.tr.z = s.bl.z, this.setTile(c, s)
	}
});
cc.wavesTiles3D = function(t, e, i, n) {
	return new cc.WavesTiles3D(t, e, i, n)
};
cc.WavesTiles3D.create = cc.wavesTiles3D;
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
	_jumps: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(t, e, i, n) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== n && this.initWithDuration(t, e, i, n)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(t) {
		this._amplitude = t
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(t) {
		this._amplitudeRate = t
	},
	initWithDuration: function(t, e, i, n) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._jumps = i, this._amplitude = n, this._amplitudeRate = 1, !0) : !1
	},
	update: function(t) {
		var e = Math.sin(2 * Math.PI * t * this._jumps) * this._amplitude * this._amplitudeRate;
		t = Math.sin(Math.PI * (2 * t * this._jumps + 1)) * this._amplitude * this._amplitudeRate;
		for (var i = this._gridSize, n = this.target.grid, r, c = cc.p(0, 0), s = 0; s < i.width; s++) for (var o = 0; o < i.height; o++) c.x = s, c.y = o, r = n.originalTile(c), 0 == (s + o) % 2 ? (r.bl.z += e, r.br.z += e, r.tl.z += e, r.tr.z += e) : (r.bl.z += t, r.br.z += t, r.tl.z += t, r.tr.z += t), n.setTile(c, r)
	}
});
cc.jumpTiles3D = function(t, e, i, n) {
	return new cc.JumpTiles3D(t, e, i, n)
};
cc.JumpTiles3D.create = cc.jumpTiles3D;
cc.SplitRows = cc.TiledGrid3DAction.extend({
	_rows: 0,
	_winSize: null,
	ctor: function(t, e) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== e && this.initWithDuration(t, e)
	},
	initWithDuration: function(t, e) {
		this._rows = e;
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, cc.size(1, e))
	},
	update: function(t) {
		for (var e = this._gridSize, i = this._winSize.width, n, r, c = cc.p(0, 0), s = 0; s < e.height; ++s) c.y = s, n = this.originalTile(c), r = 1, 0 == s % 2 && (r = -1), n.bl.x += r * i * t, n.br.x += r * i * t, n.tl.x += r * i * t, n.tr.x += r * i * t, this.setTile(c, n)
	},
	startWithTarget: function(t) {
		cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t);
		this._winSize = cc.director.getWinSizeInPixels()
	}
});
cc.splitRows = function(t, e) {
	return new cc.SplitRows(t, e)
};
cc.SplitRows.create = cc.splitRows;
cc.SplitCols = cc.TiledGrid3DAction.extend({
	_cols: 0,
	_winSize: null,
	ctor: function(t, e) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== e && this.initWithDuration(t, e)
	},
	initWithDuration: function(t, e) {
		this._cols = e;
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, cc.size(e, 1))
	},
	update: function(t) {
		for (var e = this._gridSize.width, i = this._winSize.height, n, r, c = cc.p(0, 0), s = 0; s < e; ++s) c.x = s, n = this.originalTile(c), r = 1, 0 == s % 2 && (r = -1), n.bl.y += r * i * t, n.br.y += r * i * t, n.tl.y += r * i * t, n.tr.y += r * i * t, this.setTile(c, n);
		cc.renderer.childrenOrderDirty = !0
	},
	startWithTarget: function(t) {
		cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t);
		this._winSize = cc.director.getWinSizeInPixels()
	}
});
cc.splitCols = function(t, e) {
	return new cc.SplitCols(t, e)
};
cc.SplitCols.create = cc.splitCols;
cc.PageTurn3D = cc.Grid3DAction.extend({
	update: function(t) {
		var e = Math.max(0, t - .25),
			e = -100 - 500 * e * e;
		t = -Math.PI / 2 * Math.sqrt(t);
		var i = +Math.PI / 2 + t;
		t = Math.sin(i);
		for (var i = Math.cos(i), n = this._gridSize, r = cc.p(0, 0), c = 0; c <= n.width; ++c) for (var s = 0; s <= n.height; ++s) {
			r.x = c;
			r.y = s;
			var o = this.originalVertex(r),
				a = Math.sqrt(o.x * o.x + (o.y - e) * (o.y - e)),
				h = a * t,
				l = Math.asin(o.x / a) / t,
				u = Math.cos(l);
			o.x = l <= Math.PI ? h * Math.sin(l) : 0;
			o.y = a + e - h * (1 - u) * t;
			o.z = h * (1 - u) * i / 7;.5 > o.z && (o.z = .5);
			this.setVertex(r, o)
		}
	}
});
cc.pageTurn3D = function(t, e) {
	return new cc.PageTurn3D(t, e)
};
cc.PageTurn3D.create = cc.pageTurn3D;
cc.ProgressTimer = cc.Node.extend({
	_type: null,
	_percentage: 0,
	_sprite: null,
	_midPoint: null,
	_barChangeRate: null,
	_reverseDirection: !1,
	_className: "ProgressTimer",
	ctor: function(t) {
		cc.Node.prototype.ctor.call(this);
		this._type = cc.ProgressTimer.TYPE_RADIAL;
		this._percentage = 0;
		this._midPoint = cc.p(0, 0);
		this._barChangeRate = cc.p(0, 0);
		this._reverseDirection = !1;
		this._sprite = null;
		t && this.initWithSprite(t)
	},
	getMidpoint: function() {
		return cc.p(this._midPoint.x, this._midPoint.y)
	},
	setMidpoint: function(t) {
		this._midPoint = cc.pClamp(t, cc.p(0, 0), cc.p(1, 1))
	},
	getBarChangeRate: function() {
		return cc.p(this._barChangeRate.x, this._barChangeRate.y)
	},
	setBarChangeRate: function(t) {
		this._barChangeRate = cc.pClamp(t, cc.p(0, 0), cc.p(1, 1))
	},
	getType: function() {
		return this._type
	},
	getPercentage: function() {
		return this._percentage
	},
	getSprite: function() {
		return this._sprite
	},
	setPercentage: function(t) {
		this._percentage != t && (this._percentage = cc.clampf(t, 0, 100), this._renderCmd._updateProgress())
	},
	setOpacityModifyRGB: function(t) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	isReverseDirection: function() {
		return this._reverseDirection
	},
	setColor: function(t) {
		this._sprite.color = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	setOpacity: function(t) {
		this._sprite.opacity = t;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getColor: function() {
		return this._sprite.color
	},
	getOpacity: function() {
		return this._sprite.opacity
	},
	setReverseProgress: function(t) {
		this._reverseDirection !== t && (this._reverseDirection = t, this._renderCmd.releaseData())
	},
	setSprite: function(t) {
		this._sprite != t && ((this._sprite = t) ? this.setContentSize(t.width, t.height) : this.setContentSize(0, 0), this._renderCmd.releaseData())
	},
	setType: function(t) {
		t !== this._type && (this._type = t, this._renderCmd.releaseData())
	},
	setReverseDirection: function(t) {
		this._reverseDirection !== t && (this._reverseDirection = t, this._renderCmd.releaseData())
	},
	initWithSprite: function(t) {
		this.percentage = 0;
		this.setAnchorPoint(.5, .5);
		this._type = cc.ProgressTimer.TYPE_RADIAL;
		this._reverseDirection = !1;
		this.midPoint = cc.p(.5, .5);
		this.barChangeRate = cc.p(1, 1);
		this.setSprite(t);
		this._renderCmd.initCmd();
		return !0
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ProgressTimer.CanvasRenderCmd(this) : new cc.ProgressTimer.WebGLRenderCmd(this)
	}
});
_p = cc.ProgressTimer.prototype;
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
cc.ProgressTimer.create = function(t) {
	return new cc.ProgressTimer(t)
};
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
cc.ProgressTimer.TEXTURE_COORDS = 75;
cc.ProgressTimer.TYPE_RADIAL = 0;
cc.ProgressTimer.TYPE_BAR = 1;
cc.ProgressTo = cc.ActionInterval.extend({
	_to: 0,
	_from: 0,
	ctor: function(t, e) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._from = this._to = 0;
		void 0 !== e && this.initWithDuration(t, e)
	},
	initWithDuration: function(t, e) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._to = e, !0) : !1
	},
	clone: function() {
		var t = new cc.ProgressTo;
		t.initWithDuration(this._duration, this._to);
		return t
	},
	reverse: function() {
		cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
		return null
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t);
		this._from = t.percentage
	},
	update: function(t) {
		this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * t)
	}
});
cc.progressTo = function(t, e) {
	return new cc.ProgressTo(t, e)
};
cc.ProgressTo.create = cc.progressTo;
cc.ProgressFromTo = cc.ActionInterval.extend({
	_to: 0,
	_from: 0,
	ctor: function(t, e, i) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._from = this._to = 0;
		void 0 !== i && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._to = i, this._from = e, !0) : !1
	},
	clone: function() {
		var t = new cc.ProgressFromTo;
		t.initWithDuration(this._duration, this._from, this._to);
		return t
	},
	reverse: function() {
		return cc.progressFromTo(this._duration, this._to, this._from)
	},
	startWithTarget: function(t) {
		cc.ActionInterval.prototype.startWithTarget.call(this, t)
	},
	update: function(t) {
		this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * t)
	}
});
cc.progressFromTo = function(t, e, i) {
	return new cc.ProgressFromTo(t, e, i)
};
cc.ProgressFromTo.create = cc.progressFromTo;
(function() {
	cc.ProgressTimer.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._needDraw = !0;
		this._PI180 = Math.PI / 180;
		this._barRect = cc.rect(0, 0, 0, 0);
		this._origin = cc.p(0, 0);
		this._radius = 0;
		this._endAngle = this._startAngle = 270;
		this._counterClockWise = !1
	};
	var t = cc.ProgressTimer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.ProgressTimer.CanvasRenderCmd;
	t.rendering = function(t, e, i) {
		t = t || cc._renderContext;
		var n = this._node,
			r = n._sprite,
			c = r._renderCmd._textureCoord,
			s = r._renderCmd._displayedOpacity / 255;
		if (!(0 === c.width || 0 === c.height) && r._texture && c.validRect && 0 !== s) {
			var o = this._worldTransform;
			t.save();
			t.transform(o.a, o.c, o.b, o.d, o.tx * e, -o.ty * i);
			"source-over" != r._blendFuncStr && (t.globalCompositeOperation = r._blendFuncStr);
			t.globalAlpha = s;
			var a = r._rect,
				h = r._offsetPosition,
				s = h.x,
				o = -h.y - a.height,
				l = a.width,
				a = a.height;
			r._flippedX && (s = -s - l, t.scale(-1, 1));
			r._flippedY && (o = h.y, t.scale(1, -1));
			n._type == cc.ProgressTimer.TYPE_BAR ? (n = this._barRect, t.beginPath(), t.rect(n.x * e, n.y * i, n.width * e, n.height * i), t.clip(), t.closePath()) : n._type == cc.ProgressTimer.TYPE_RADIAL && (n = this._origin.x * e, h = this._origin.y * i, t.beginPath(), t.arc(n, h, this._radius * i, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise), t.lineTo(n, h), t.clip(), t.closePath());
			n = r._texture.getHtmlElementObj();
			r._colorized ? t.drawImage(n, 0, 0, c.width, c.height, s * e, o * i, l * e, a * i) : t.drawImage(n, c.renderX, c.renderY, c.width, c.height, s * e, o * i, l * e, a * i);
			t.restore();
			cc.g_NumberOfDraws++
		}
	};
	t.releaseData = function() {};
	t.initCmd = function() {};
	t._updateProgress = function() {
		var t = this._node,
			e = t._sprite,
			i = e.width,
			n = e.height,
			r = t._midPoint;
		if (t._type == cc.ProgressTimer.TYPE_RADIAL) {
			this._radius = Math.round(Math.sqrt(i * i + n * n));
			var c, s = !1,
				o = this._origin;
			o.x = i * r.x;
			o.y = -n * r.y;
			t._reverseDirection ? (c = 270, r = 270 - 3.6 * t._percentage) : (r = -90, c = -90 + 3.6 * t._percentage);
			e._flippedX && (o.x -= i * 2 * t._midPoint.x, r = -r - 180, c = -c - 180, s = !s);
			e._flippedY && (o.y += n * 2 * t._midPoint.y, s = !s, r = -r, c = -c);
			this._startAngle = r;
			this._endAngle = c;
			this._counterClockWise = s
		} else s = t._barChangeRate, o = t._percentage / 100, t = this._barRect, s = cc.size(i * (1 - s.x), n * (1 - s.y)), o = cc.size((i - s.width) * o, (n - s.height) * o), s = cc.size(s.width + o.width, s.height + o.height), c = cc.p(i * r.x, n * r.y), o = c.x - s.width / 2, .5 < r.x && s.width / 2 >= i - c.x && (o = i - s.width), i = c.y - s.height / 2, .5 < r.y && s.height / 2 >= n - c.y && (i = n - s.height), t.x = 0, n = 1, e._flippedX && (t.x -= s.width, n = -1), 0 < o && (t.x += o * n), t.y = 0, n = 1, e._flippedY && (t.y += s.height, n = -1), 0 < i && (t.y -= i * n), t.width = s.width, t.height = -s.height
	};
	t._updateColor = function() {};
	t._syncStatus = function(t) {
		var e = this._node;
		if (e._sprite) {
			var i = cc.Node._dirtyFlags,
				n = this._dirtyFlag,
				r = t ? t._node : null;
			r && (r._cascadeColorEnabled && t._dirtyFlag & i.colorDirty) && (n |= i.colorDirty);
			r && (r._cascadeOpacityEnabled && t._dirtyFlag & i.opacityDirty) && (n |= i.opacityDirty);
			t && t._dirtyFlag & i.transformDirty && (n |= i.transformDirty);
			this._dirtyFlag = n;
			var e = e._sprite._renderCmd,
				r = e._dirtyFlag,
				c = r & i.opacityDirty;
			r & i.colorDirty && e._syncDisplayColor();
			c && e._syncDisplayOpacity();
			n & i.transformDirty && this.transform(t)
		}
	};
	t.updateStatus = function() {
		var t = this._node;
		if (t._sprite) {
			var e = cc.Node._dirtyFlags,
				i = this._dirtyFlag,
				t = t._sprite._renderCmd,
				n = t._dirtyFlag,
				r = n & e.opacityDirty;
			n & e.colorDirty && t._updateDisplayColor();
			r && t._updateDisplayOpacity();
			i & e.transformDirty && this.transform(this.getParentRenderCmd(), !0);
			this._dirtyFlag = 0
		}
	}
})();
(function() {
	cc.ProgressTimer.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !0;
		this._vertexWebGLBuffer = cc._renderContext.createBuffer();
		this._vertexDataCount = 0;
		this._vertexArrayBuffer = this._vertexData = null;
		this._vertexDataDirty = !1
	};
	var t = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	t.constructor = cc.ProgressTimer.WebGLRenderCmd;
	t.rendering = function(t) {
		var e = this._node;
		t = t || cc._renderContext;
		if (this._vertexData && e._sprite) {
			this._shaderProgram.use();
			this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
			var i = e._sprite._blendFunc;
			cc.glBlendFunc(i.src, i.dst);
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
			cc.glBindTexture2D(e._sprite.texture);
			t.bindBuffer(t.ARRAY_BUFFER, this._vertexWebGLBuffer);
			this._vertexDataDirty && (t.bufferData(t.ARRAY_BUFFER, this._vertexArrayBuffer, t.DYNAMIC_DRAW), this._vertexDataDirty = !1);
			i = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
			t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, i, 0);
			t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, i, 8);
			t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, i, 12);
			e._type === cc.ProgressTimer.TYPE_RADIAL ? t.drawArrays(t.TRIANGLE_FAN, 0, this._vertexDataCount) : e._type == cc.ProgressTimer.TYPE_BAR && (e._reverseDirection ? (t.drawArrays(t.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), t.drawArrays(t.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : t.drawArrays(t.TRIANGLE_STRIP, 0, this._vertexDataCount));
			cc.g_NumberOfDraws++
		}
	};
	t._syncStatus = function(t) {
		var e = this._node;
		if (e._sprite) {
			var i = cc.Node._dirtyFlags,
				n = this._dirtyFlag,
				r = t ? t._node : null;
			r && (r._cascadeColorEnabled && t._dirtyFlag & i.colorDirty) && (n |= i.colorDirty);
			r && (r._cascadeOpacityEnabled && t._dirtyFlag & i.opacityDirty) && (n |= i.opacityDirty);
			t && t._dirtyFlag & i.transformDirty && (n |= i.transformDirty);
			this._dirtyFlag = n;
			e = e._sprite._renderCmd;
			r = e._dirtyFlag;
			n = r & i.colorDirty;
			i = r & i.opacityDirty;
			n && e._syncDisplayColor();
			i && e._syncDisplayOpacity();
			if (n || i) e._updateColor(), this._updateColor();
			this.transform(t);
			e._dirtyFlag = 0
		}
	};
	t.updateStatus = function() {
		var t = this._node;
		if (t._sprite) {
			var e = cc.Node._dirtyFlags,
				i = this._dirtyFlag,
				t = t._sprite._renderCmd,
				n = t._dirtyFlag,
				r = n & e.colorDirty,
				n = n & e.opacityDirty;
			r && (t._updateDisplayColor(), this._dirtyFlag ^= this._dirtyFlag & e.colorDirty);
			n && (t._updateDisplayOpacity(), this._dirtyFlag ^= this._dirtyFlag & e.opacityDirty);
			if (r || n) t._updateColor(), this._updateColor();
			i & e.transformDirty && this.transform(this.getParentRenderCmd(), !0)
		}
	};
	t.releaseData = function() {
		this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
	};
	t.initCmd = function() {
		this._vertexArrayBuffer = this._vertexData = null;
		this._vertexDataCount = 0;
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	t._updateProgress = function() {
		var t = this._node._type;
		t === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : t === cc.ProgressTimer.TYPE_BAR && this._updateBar();
		this._vertexDataDirty = !0
	};
	t._updateBar = function() {
		var t = this._node;
		if (t._sprite) {
			var e, i = t._percentage / 100;
			e = t._barChangeRate;
			e = cc.pMult(cc.p(1 - e.x + i * e.x, 1 - e.y + i * e.y), .5);
			i = cc.pSub(t._midPoint, e);
			t = cc.pAdd(t._midPoint, e);
			0 > i.x && (t.x += -i.x, i.x = 0);
			1 < t.x && (i.x -= t.x - 1, t.x = 1);
			0 > i.y && (t.y += -i.y, i.y = 0);
			1 < t.y && (i.y -= t.y - 1, t.y = 1);
			if (this._reverseDirection) {
				if (!this._vertexData) {
					this._vertexDataCount = 8;
					var n = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
					this._vertexArrayBuffer = new ArrayBuffer(8 * n);
					var r = [];
					for (e = 0; 8 > e; e++) r[e] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, e * n);
					r[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1));
					r[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
					r[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
					r[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
					r[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
					r[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
					r[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
					r[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
					this._vertexData = r
				}
				e = this._vertexData;
				e[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(i.x, t.y));
				e[2].vertices = this._vertexFromAlphaPoint(cc.p(i.x, t.y));
				e[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(i.x, i.y));
				e[3].vertices = this._vertexFromAlphaPoint(cc.p(i.x, i.y));
				e[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(t.x, t.y));
				e[4].vertices = this._vertexFromAlphaPoint(cc.p(t.x, t.y));
				e[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(t.x, i.y));
				e[5].vertices = this._vertexFromAlphaPoint(cc.p(t.x, i.y))
			} else {
				if (!this._vertexData) {
					this._vertexDataCount = 4;
					n = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
					this._vertexArrayBuffer = new ArrayBuffer(4 * n);
					this._vertexData = [];
					for (e = 0; 4 > e; e++) this._vertexData[e] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, e * n)
				}
				e = this._vertexData;
				e[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(i.x, t.y));
				e[0].vertices = this._vertexFromAlphaPoint(cc.p(i.x, t.y));
				e[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(i.x, i.y));
				e[1].vertices = this._vertexFromAlphaPoint(cc.p(i.x, i.y));
				e[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(t.x, t.y));
				e[2].vertices = this._vertexFromAlphaPoint(cc.p(t.x, t.y));
				e[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(t.x, i.y));
				e[3].vertices = this._vertexFromAlphaPoint(cc.p(t.x, i.y))
			}
			this._updateColor()
		}
	};
	t._updateRadial = function() {
		var t = this._node;
		if (t._sprite) {
			var e, i = t._midPoint;
			e = t._percentage / 100;
			var n = 2 * cc.PI * (t._reverseDirection ? e : 1 - e),
				t = cc.p(i.x, 1),
				r = cc.pRotateByAngle(t, i, n),
				n = 0;
			if (0 == e) r = t, n = 0;
			else if (1 == e) r = t, n = 4;
			else {
				var c = cc.FLT_MAX,
					s = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
				for (e = 0; e <= s; ++e) {
					var o = (e + (s - 1)) % s,
						a = this._boundaryTexCoord(e % s),
						o = this._boundaryTexCoord(o);
					0 == e ? o = cc.pLerp(a, o, 1 - i.x) : 4 == e && (a = cc.pLerp(a, o, 1 - i.x));
					var h = cc.p(0, 0);
					if (cc.pLineIntersect(a, o, i, r, h) && (!(0 == e || 4 == e) || 0 <= h.x && 1 >= h.x) && 0 <= h.y && h.y < c) c = h.y, n = e
				}
				r = cc.pAdd(i, cc.pMult(cc.pSub(r, i), c))
			}
			c = !0;
			this._vertexDataCount != n + 3 && (c = !1, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
			if (!this._vertexData) {
				s = this._vertexDataCount = n + 3;
				a = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
				this._vertexArrayBuffer = new ArrayBuffer(s * a);
				o = [];
				for (e = 0; e < s; e++) o[e] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, e * a);
				this._vertexData = o;
				if (!this._vertexData) {
					cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
					return
				}
			}
			this._updateColor();
			s = this._vertexData;
			if (!c) {
				s[0].texCoords = this._textureCoordFromAlphaPoint(i);
				s[0].vertices = this._vertexFromAlphaPoint(i);
				s[1].texCoords = this._textureCoordFromAlphaPoint(t);
				s[1].vertices = this._vertexFromAlphaPoint(t);
				for (e = 0; e < n; e++) i = this._boundaryTexCoord(e), s[e + 2].texCoords = this._textureCoordFromAlphaPoint(i), s[e + 2].vertices = this._vertexFromAlphaPoint(i)
			}
			s[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(r);
			s[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(r)
		}
	};
	t._boundaryTexCoord = function(t) {
		if (t < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
			var e = cc.ProgressTimer.TEXTURE_COORDS;
			return this._node._reverseDirection ? cc.p(e >> 7 - (t << 1) & 1, e >> 7 - ((t << 1) + 1) & 1) : cc.p(e >> (t << 1) + 1 & 1, e >> (t << 1) & 1)
		}
		return cc.p(0, 0)
	};
	t._textureCoordFromAlphaPoint = function(t) {
		var e = this._node._sprite;
		if (!e) return {
			u: 0,
			v: 0
		};
		var i = e.quad,
			n = cc.p(i.bl.texCoords.u, i.bl.texCoords.v),
			i = cc.p(i.tr.texCoords.u, i.tr.texCoords.v);
		e.textureRectRotated && (e = t.x, t.x = t.y, t.y = e);
		return {
			u: n.x * (1 - t.x) + i.x * t.x,
			v: n.y * (1 - t.y) + i.y * t.y
		}
	};
	t._vertexFromAlphaPoint = function(t) {
		var e = this._node._sprite;
		if (!e) return {
			x: 0,
			y: 0
		};
		var i = e.quad,
			e = cc.p(i.bl.vertices.x, i.bl.vertices.y),
			i = cc.p(i.tr.vertices.x, i.tr.vertices.y);
		return {
			x: e.x * (1 - t.x) + i.x * t.x,
			y: e.y * (1 - t.y) + i.y * t.y
		}
	};
	t._updateColor = function() {
		var t = this._node;
		if (t._sprite && this._vertexData) {
			for (var t = t._sprite.quad.tl.colors, e = this._vertexData, i = 0, n = this._vertexDataCount; i < n; ++i) e[i].colors = t;
			this._vertexDataDirty = !0
		}
	}
})();
cc.SCENE_FADE = 4208917214;
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({
	_inScene: null,
	_outScene: null,
	_duration: null,
	_isInSceneOnTop: !1,
	_isSendCleanupToScene: !1,
	_className: "TransitionScene",
	ctor: function(t, e) {
		cc.Scene.prototype.ctor.call(this);
		void 0 !== t && void 0 !== e && this.initWithDuration(t, e)
	},
	_setNewScene: function(t) {
		this.unschedule(this._setNewScene);
		t = cc.director;
		this._isSendCleanupToScene = t.isSendCleanupToScene();
		t.runScene(this._inScene);
		cc.eventManager.setEnabled(!0);
		this._outScene.visible = !0
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !0
	},
	visit: function() {
		this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit());
		cc.Node.prototype.visit.call(this)
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		cc.eventManager.setEnabled(!1);
		this._outScene.onExitTransitionDidStart();
		this._inScene.onEnter()
	},
	onExit: function() {
		cc.Node.prototype.onExit.call(this);
		cc.eventManager.setEnabled(!0);
		this._outScene.onExit();
		this._inScene.onEnterTransitionDidFinish()
	},
	cleanup: function() {
		cc.Node.prototype.cleanup.call(this);
		this._isSendCleanupToScene && this._outScene.cleanup()
	},
	initWithDuration: function(t, e) {
		if (!e) throw "cc.TransitionScene.initWithDuration(): Argument scene must be non-nil";
		if (this.init()) {
			this._duration = t;
			this.attr({
				x: 0,
				y: 0,
				anchorX: 0,
				anchorY: 0
			});
			this._inScene = e;
			this._outScene = cc.director.getRunningScene();
			this._outScene || (this._outScene = new cc.Scene, this._outScene.init());
			if (this._inScene == this._outScene) throw "cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene";
			this._sceneOrder();
			return !0
		}
		return !1
	},
	finish: function() {
		this._inScene.attr({
			visible: !0,
			x: 0,
			y: 0,
			scale: 1,
			rotation: 0
		});
		cc._renderType === cc._RENDER_TYPE_WEBGL && this._inScene.getCamera().restore();
		this._outScene.attr({
			visible: !1,
			x: 0,
			y: 0,
			scale: 1,
			rotation: 0
		});
		cc._renderType === cc._RENDER_TYPE_WEBGL && this._outScene.getCamera().restore();
		this.schedule(this._setNewScene, 0)
	},
	hideOutShowIn: function() {
		this._inScene.visible = !0;
		this._outScene.visible = !1
	}
});
cc.TransitionScene.create = function(t, e) {
	return new cc.TransitionScene(t, e)
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({
	_orientation: 0,
	ctor: function(t, e, i) {
		cc.TransitionScene.prototype.ctor.call(this);
		void 0 != i && this.initWithDuration(t, e, i)
	},
	initWithDuration: function(t, e, i) {
		cc.TransitionScene.prototype.initWithDuration.call(this, t, e) && (this._orientation = i);
		return !0
	}
});
cc.TransitionSceneOriented.create = function(t, e, i) {
	return new cc.TransitionSceneOriented(t, e, i)
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._inScene.attr({
			scale: .001,
			anchorX: .5,
			anchorY: .5
		});
		this._outScene.attr({
			scale: 1,
			anchorX: .5,
			anchorY: .5
		});
		var t = cc.sequence(cc.spawn(cc.scaleBy(this._duration / 2, .001), cc.rotateBy(this._duration / 2, 720)), cc.delayTime(this._duration / 2));
		this._outScene.runAction(t);
		this._inScene.runAction(cc.sequence(t.reverse(), cc.callFunc(this.finish, this)))
	}
});
cc.TransitionRotoZoom.create = function(t, e) {
	return new cc.TransitionRotoZoom(t, e)
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t = cc.director.getWinSize();
		this._inScene.attr({
			scale: .5,
			x: t.width,
			y: 0,
			anchorX: .5,
			anchorY: .5
		});
		this._outScene.anchorX = .5;
		this._outScene.anchorY = .5;
		var e = cc.jumpBy(this._duration / 4, cc.p(-t.width, 0), t.width / 4, 2),
			i = cc.scaleTo(this._duration / 4, 1),
			t = cc.scaleTo(this._duration / 4, .5),
			t = cc.sequence(t, e),
			e = cc.sequence(e, i),
			i = cc.delayTime(this._duration / 2);
		this._outScene.runAction(t);
		this._inScene.runAction(cc.sequence(i, e, cc.callFunc(this.finish, this)))
	}
});
cc.TransitionJumpZoom.create = function(t, e) {
	return new cc.TransitionJumpZoom(t, e)
};
cc.TransitionMoveInL = cc.TransitionScene.extend({
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this.initScenes();
		var t = this.action();
		this._inScene.runAction(cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this)))
	},
	initScenes: function() {
		this._inScene.setPosition(-cc.director.getWinSize().width, 0)
	},
	action: function() {
		return cc.moveTo(this._duration, cc.p(0, 0))
	},
	easeActionWithAction: function(t) {
		return new cc.EaseOut(t, 2)
	}
});
cc.TransitionMoveInL.create = function(t, e) {
	return new cc.TransitionMoveInL(t, e)
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
	ctor: function(t, e) {
		cc.TransitionMoveInL.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	initScenes: function() {
		this._inScene.setPosition(cc.director.getWinSize().width, 0)
	}
});
cc.TransitionMoveInR.create = function(t, e) {
	return new cc.TransitionMoveInR(t, e)
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
	ctor: function(t, e) {
		cc.TransitionMoveInL.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	initScenes: function() {
		this._inScene.setPosition(0, cc.director.getWinSize().height)
	}
});
cc.TransitionMoveInT.create = function(t, e) {
	return new cc.TransitionMoveInT(t, e)
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
	ctor: function(t, e) {
		cc.TransitionMoveInL.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	initScenes: function() {
		this._inScene.setPosition(0, -cc.director.getWinSize().height)
	}
});
cc.TransitionMoveInB.create = function(t, e) {
	return new cc.TransitionMoveInB(t, e)
};
cc.ADJUST_FACTOR = .5;
cc.TransitionSlideInL = cc.TransitionScene.extend({
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this.initScenes();
		var t = this.action(),
			e = this.action(),
			t = this.easeActionWithAction(t),
			e = cc.sequence(this.easeActionWithAction(e), cc.callFunc(this.finish, this));
		this._inScene.runAction(t);
		this._outScene.runAction(e)
	},
	initScenes: function() {
		this._inScene.setPosition(-cc.director.getWinSize().width + cc.ADJUST_FACTOR, 0)
	},
	action: function() {
		return cc.moveBy(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
	},
	easeActionWithAction: function(t) {
		return new cc.EaseInOut(t, 2)
	}
});
cc.TransitionSlideInL.create = function(t, e) {
	return new cc.TransitionSlideInL(t, e)
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
	ctor: function(t, e) {
		cc.TransitionSlideInL.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !0
	},
	initScenes: function() {
		this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
	},
	action: function() {
		return cc.moveBy(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
	}
});
cc.TransitionSlideInR.create = function(t, e) {
	return new cc.TransitionSlideInR(t, e)
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
	ctor: function(t, e) {
		cc.TransitionSlideInL.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	initScenes: function() {
		this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
	},
	action: function() {
		return cc.moveBy(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
	}
});
cc.TransitionSlideInB.create = function(t, e) {
	return new cc.TransitionSlideInB(t, e)
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
	ctor: function(t, e) {
		cc.TransitionSlideInL.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !0
	},
	initScenes: function() {
		this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
	},
	action: function() {
		return cc.moveBy(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
	}
});
cc.TransitionSlideInT.create = function(t, e) {
	return new cc.TransitionSlideInT(t, e)
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._inScene.attr({
			scale: .001,
			anchorX: 2 / 3,
			anchorY: .5
		});
		this._outScene.attr({
			scale: 1,
			anchorX: 1 / 3,
			anchorY: .5
		});
		var t = cc.scaleTo(this._duration, .01),
			e = cc.scaleTo(this._duration, 1);
		this._inScene.runAction(this.easeActionWithAction(e));
		this._outScene.runAction(cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this)))
	},
	easeActionWithAction: function(t) {
		return new cc.EaseOut(t, 2)
	}
});
cc.TransitionShrinkGrow.create = function(t, e) {
	return new cc.TransitionShrinkGrow(t, e)
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
	ctor: function(t, e, i) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == i && (i = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
		e && this.initWithDuration(t, e, i)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t, e;
		this._inScene.visible = !1;
		var i;
		this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (t = 90, i = 270, e = 90) : (t = -90, i = 90, e = -90);
		t = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, i, t, 0, 0), cc.callFunc(this.finish, this));
		e = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 0, 0), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.runAction(t);
		this._outScene.runAction(e)
	}
});
cc.TransitionFlipX.create = function(t, e, i) {
	return new cc.TransitionFlipX(t, e, i)
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
	ctor: function(t, e, i) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == i && (i = cc.TRANSITION_ORIENTATION_UP_OVER);
		e && this.initWithDuration(t, e, i)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t, e;
		this._inScene.visible = !1;
		var i;
		this._orientation == cc.TRANSITION_ORIENTATION_UP_OVER ? (t = 90, i = 270, e = 90) : (t = -90, i = 90, e = -90);
		t = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, i, t, 90, 0), cc.callFunc(this.finish, this));
		e = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 90, 0), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.runAction(t);
		this._outScene.runAction(e)
	}
});
cc.TransitionFlipY.create = function(t, e, i) {
	return new cc.TransitionFlipY(t, e, i)
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
	ctor: function(t, e, i) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == i && (i = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
		e && this.initWithDuration(t, e, i)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t, e;
		this._inScene.visible = !1;
		var i;
		this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (t = 90, i = 270, e = 90) : (t = -90, i = 90, e = -90);
		t = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, i, t, -45, 0), cc.callFunc(this.finish, this));
		e = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 45, 0), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.runAction(t);
		this._outScene.runAction(e)
	}
});
cc.TransitionFlipAngular.create = function(t, e, i) {
	return new cc.TransitionFlipAngular(t, e, i)
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
	ctor: function(t, e, i) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == i && (i = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
		e && this.initWithDuration(t, e, i)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t, e;
		this._inScene.visible = !1;
		var i;
		this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (t = 90, i = 270, e = 90) : (t = -90, i = 90, e = -90);
		t = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, i, t, 0, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
		e = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 0, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.scale = .5;
		this._inScene.runAction(t);
		this._outScene.runAction(e)
	}
});
cc.TransitionZoomFlipX.create = function(t, e, i) {
	return new cc.TransitionZoomFlipX(t, e, i)
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
	ctor: function(t, e, i) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == i && (i = cc.TRANSITION_ORIENTATION_UP_OVER);
		e && this.initWithDuration(t, e, i)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t, e;
		this._inScene.visible = !1;
		var i;
		this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (t = 90, i = 270, e = 90) : (t = -90, i = 90, e = -90);
		t = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, i, t, 90, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
		e = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 90, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.scale = .5;
		this._inScene.runAction(t);
		this._outScene.runAction(e)
	}
});
cc.TransitionZoomFlipY.create = function(t, e, i) {
	return new cc.TransitionZoomFlipY(t, e, i)
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
	ctor: function(t, e, i) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == i && (i = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
		e && this.initWithDuration(t, e, i)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t, e;
		this._inScene.visible = !1;
		var i;
		this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (t = 90, i = 270, e = 90) : (t = -90, i = 90, e = -90);
		t = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, i, t, -45, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.show(), cc.callFunc(this.finish, this));
		e = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, e, 45, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.scale = .5;
		this._inScene.runAction(t);
		this._outScene.runAction(e)
	}
});
cc.TransitionZoomFlipAngular.create = function(t, e, i) {
	return new cc.TransitionZoomFlipAngular(t, e, i)
};
cc.TransitionFade = cc.TransitionScene.extend({
	_color: null,
	ctor: function(t, e, i) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._color = cc.color();
		e && this.initWithDuration(t, e, i)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t = new cc.LayerColor(this._color);
		this._inScene.visible = !1;
		this.addChild(t, 2, cc.SCENE_FADE);
		var t = this.getChildByTag(cc.SCENE_FADE),
			e = cc.sequence(cc.fadeIn(this._duration / 2), cc.callFunc(this.hideOutShowIn, this), cc.fadeOut(this._duration / 2), cc.callFunc(this.finish, this));
		t.runAction(e)
	},
	onExit: function() {
		cc.TransitionScene.prototype.onExit.call(this);
		this.removeChildByTag(cc.SCENE_FADE, !1)
	},
	initWithDuration: function(t, e, i) {
		i = i || cc.color.BLACK;
		cc.TransitionScene.prototype.initWithDuration.call(this, t, e) && (this._color.r = i.r, this._color.g = i.g, this._color.b = i.b, this._color.a = 0);
		return !0
	}
});
cc.TransitionFade.create = function(t, e, i) {
	return new cc.TransitionFade(t, e, i)
};
cc.TransitionCrossFade = cc.TransitionScene.extend({
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t = cc.color(0, 0, 0, 0),
			e = cc.director.getWinSize(),
			t = new cc.LayerColor(t),
			i = new cc.RenderTexture(e.width, e.height);
		if (null != i) {
			i.sprite.anchorX = .5;
			i.sprite.anchorY = .5;
			i.attr({
				x: e.width / 2,
				y: e.height / 2,
				anchorX: .5,
				anchorY: .5
			});
			i.begin();
			this._inScene.visit();
			i.end();
			var n = new cc.RenderTexture(e.width, e.height);
			n.setPosition(e.width / 2, e.height / 2);
			n.sprite.anchorX = n.anchorX = .5;
			n.sprite.anchorY = n.anchorY = .5;
			n.begin();
			this._outScene.visit();
			n.end();
			i.sprite.setBlendFunc(cc.ONE, cc.ONE);
			n.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
			t.addChild(i);
			t.addChild(n);
			i.sprite.opacity = 255;
			n.sprite.opacity = 255;
			e = cc.sequence(cc.fadeTo(this._duration, 0), cc.callFunc(this.hideOutShowIn, this), cc.callFunc(this.finish, this));
			n.sprite.runAction(e);
			this.addChild(t, 2, cc.SCENE_FADE)
		}
	},
	onExit: function() {
		this.removeChildByTag(cc.SCENE_FADE, !1);
		cc.TransitionScene.prototype.onExit.call(this)
	},
	visit: function() {
		cc.Node.prototype.visit.call(this)
	},
	draw: function() {}
});
cc.TransitionCrossFade.create = function(t, e) {
	return new cc.TransitionCrossFade(t, e)
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
	_gridProxy: null,
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._gridProxy = new cc.NodeGrid;
		e && this.initWithDuration(t, e)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._gridProxy.setTarget(this._outScene);
		this._gridProxy.onEnter();
		var t = cc.director.getWinSize(),
			t = cc.turnOffTiles(this._duration, cc.size(0 | 12 * (t.width / t.height), 12)),
			t = this.easeActionWithAction(t);
		this._gridProxy.runAction(cc.sequence(t, cc.callFunc(this.finish, this), cc.stopGrid()))
	},
	visit: function() {
		this._inScene.visit();
		this._gridProxy.visit()
	},
	easeActionWithAction: function(t) {
		return t
	}
});
cc.TransitionTurnOffTiles.create = function(t, e) {
	return new cc.TransitionTurnOffTiles(t, e)
};
cc.TransitionSplitCols = cc.TransitionScene.extend({
	_gridProxy: null,
	_switchTargetToInscene: function() {
		this._gridProxy.setTarget(this._inScene)
	},
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._gridProxy = new cc.NodeGrid;
		e && this.initWithDuration(t, e)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._gridProxy.setTarget(this._outScene);
		this._gridProxy.onEnter();
		var t = this.action(),
			t = cc.sequence(t, cc.callFunc(this._switchTargetToInscene, this), t.reverse());
		this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this), cc.stopGrid()))
	},
	onExit: function() {
		this._gridProxy.setTarget(null);
		this._gridProxy.onExit();
		cc.TransitionScene.prototype.onExit.call(this)
	},
	visit: function() {
		this._gridProxy.visit()
	},
	easeActionWithAction: function(t) {
		return new cc.EaseInOut(t, 3)
	},
	action: function() {
		return cc.splitCols(this._duration / 2, 3)
	}
});
cc.TransitionSplitCols.create = function(t, e) {
	return new cc.TransitionSplitCols(t, e)
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
	ctor: function(t, e) {
		cc.TransitionSplitCols.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	action: function() {
		return cc.splitRows(this._duration / 2, 3)
	}
});
cc.TransitionSplitRows.create = function(t, e) {
	return new cc.TransitionSplitRows(t, e)
};
cc.TransitionFadeTR = cc.TransitionScene.extend({
	_gridProxy: null,
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._gridProxy = new cc.NodeGrid;
		e && this.initWithDuration(t, e)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._gridProxy.setTarget(this._outScene);
		this._gridProxy.onEnter();
		var t = cc.director.getWinSize(),
			t = this.actionWithSize(cc.size(0 | 12 * (t.width / t.height), 12));
		this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this), cc.stopGrid()))
	},
	visit: function() {
		this._inScene.visit();
		this._gridProxy.visit()
	},
	easeActionWithAction: function(t) {
		return t
	},
	actionWithSize: function(t) {
		return cc.fadeOutTRTiles(this._duration, t)
	}
});
cc.TransitionFadeTR.create = function(t, e) {
	return new cc.TransitionFadeTR(t, e)
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
	ctor: function(t, e) {
		cc.TransitionFadeTR.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	actionWithSize: function(t) {
		return cc.fadeOutBLTiles(this._duration, t)
	}
});
cc.TransitionFadeBL.create = function(t, e) {
	return new cc.TransitionFadeBL(t, e)
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
	ctor: function(t, e) {
		cc.TransitionFadeTR.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	actionWithSize: function(t) {
		return new cc.FadeOutUpTiles(this._duration, t)
	}
});
cc.TransitionFadeUp.create = function(t, e) {
	return new cc.TransitionFadeUp(t, e)
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
	ctor: function(t, e) {
		cc.TransitionFadeTR.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	actionWithSize: function(t) {
		return cc.fadeOutDownTiles(this._duration, t)
	}
});
cc.TransitionFadeDown.create = function(t, e) {
	return new cc.TransitionFadeDown(t, e)
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({
	_to: 0,
	_from: 0,
	_sceneToBeModified: null,
	_className: "TransitionProgress",
	ctor: function(t, e) {
		cc.TransitionScene.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_setAttrs: function(t, e, i) {
		t.attr({
			x: e,
			y: i,
			anchorX: .5,
			anchorY: .5
		})
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._setupTransition();
		var t = cc.director.getWinSize(),
			e = new cc.RenderTexture(t.width, t.height);
		e.sprite.anchorX = .5;
		e.sprite.anchorY = .5;
		this._setAttrs(e, t.width / 2, t.height / 2);
		e.clear(0, 0, 0, 1);
		e.begin();
		this._sceneToBeModified.visit();
		e.end();
		this._sceneToBeModified == this._outScene && this.hideOutShowIn();
		t = this._progressTimerNodeWithRenderTexture(e);
		e = cc.sequence(cc.progressFromTo(this._duration, this._from, this._to), cc.callFunc(this.finish, this));
		t.runAction(e);
		this.addChild(t, 2, cc.SCENE_RADIAL)
	},
	onExit: function() {
		this.removeChildByTag(cc.SCENE_RADIAL, !0);
		cc.TransitionScene.prototype.onExit.call(this)
	},
	_setupTransition: function() {
		this._sceneToBeModified = this._outScene;
		this._from = 100;
		this._to = 0
	},
	_progressTimerNodeWithRenderTexture: function(t) {
		cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass");
		return null
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	}
});
cc.TransitionProgress.create = function(t, e) {
	return new cc.TransitionProgress(t, e)
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
	ctor: function(t, e) {
		cc.TransitionProgress.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_progressTimerNodeWithRenderTexture: function(t) {
		var e = cc.director.getWinSize();
		t = new cc.ProgressTimer(t.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0);
		t.type = cc.ProgressTimer.TYPE_RADIAL;
		t.reverseDir = !1;
		t.percentage = 100;
		this._setAttrs(t, e.width / 2, e.height / 2);
		return t
	}
});
cc.TransitionProgressRadialCCW.create = function(t, e) {
	return new cc.TransitionProgressRadialCCW(t, e)
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
	ctor: function(t, e) {
		cc.TransitionProgress.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_progressTimerNodeWithRenderTexture: function(t) {
		var e = cc.director.getWinSize();
		t = new cc.ProgressTimer(t.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0);
		t.type = cc.ProgressTimer.TYPE_RADIAL;
		t.reverseDir = !0;
		t.percentage = 100;
		this._setAttrs(t, e.width / 2, e.height / 2);
		return t
	}
});
cc.TransitionProgressRadialCW.create = function(t, e) {
	var i = new cc.TransitionProgressRadialCW;
	return null != i && i.initWithDuration(t, e) ? i : new cc.TransitionProgressRadialCW(t, e)
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
	ctor: function(t, e) {
		cc.TransitionProgress.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_progressTimerNodeWithRenderTexture: function(t) {
		var e = cc.director.getWinSize();
		t = new cc.ProgressTimer(t.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0);
		t.type = cc.ProgressTimer.TYPE_BAR;
		t.midPoint = cc.p(1, 0);
		t.barChangeRate = cc.p(1, 0);
		t.percentage = 100;
		this._setAttrs(t, e.width / 2, e.height / 2);
		return t
	}
});
cc.TransitionProgressHorizontal.create = function(t, e) {
	return new cc.TransitionProgressHorizontal(t, e)
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
	ctor: function(t, e) {
		cc.TransitionProgress.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_progressTimerNodeWithRenderTexture: function(t) {
		var e = cc.director.getWinSize();
		t = new cc.ProgressTimer(t.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0);
		t.type = cc.ProgressTimer.TYPE_BAR;
		t.midPoint = cc.p(0, 0);
		t.barChangeRate = cc.p(0, 1);
		t.percentage = 100;
		this._setAttrs(t, e.width / 2, e.height / 2);
		return t
	}
});
cc.TransitionProgressVertical.create = function(t, e) {
	return new cc.TransitionProgressVertical(t, e)
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
	ctor: function(t, e) {
		cc.TransitionProgress.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_progressTimerNodeWithRenderTexture: function(t) {
		var e = cc.director.getWinSize();
		t = new cc.ProgressTimer(t.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0);
		t.type = cc.ProgressTimer.TYPE_BAR;
		t.midPoint = cc.p(.5, .5);
		t.barChangeRate = cc.p(1, 1);
		t.percentage = 0;
		this._setAttrs(t, e.width / 2, e.height / 2);
		return t
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	_setupTransition: function() {
		this._sceneToBeModified = this._inScene;
		this._from = 0;
		this._to = 100
	}
});
cc.TransitionProgressInOut.create = function(t, e) {
	return new cc.TransitionProgressInOut(t, e)
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
	ctor: function(t, e) {
		cc.TransitionProgress.prototype.ctor.call(this);
		e && this.initWithDuration(t, e)
	},
	_progressTimerNodeWithRenderTexture: function(t) {
		var e = cc.director.getWinSize();
		t = new cc.ProgressTimer(t.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (t.sprite.flippedY = !0);
		t.type = cc.ProgressTimer.TYPE_BAR;
		t.midPoint = cc.p(.5, .5);
		t.barChangeRate = cc.p(1, 1);
		t.percentage = 100;
		this._setAttrs(t, e.width / 2, e.height / 2);
		return t
	}
});
cc.TransitionProgressOutIn.create = function(t, e) {
	return new cc.TransitionProgressOutIn(t, e)
};
cc.TransitionPageTurn = cc.TransitionScene.extend({
	ctor: function(t, e, i) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._gridProxy = new cc.NodeGrid;
		this.initWithDuration(t, e, i)
	},
	_back: !0,
	_gridProxy: null,
	_className: "TransitionPageTurn",
	initWithDuration: function(t, e, i) {
		this._back = i;
		cc.TransitionScene.prototype.initWithDuration.call(this, t, e);
		return !0
	},
	actionWithSize: function(t) {
		return this._back ? cc.reverseTime(cc.pageTurn3D(this._duration, t)) : cc.pageTurn3D(this._duration, t)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var t = cc.director.getWinSize(),
			e;
		t.width > t.height ? (t = 16, e = 12) : (t = 12, e = 16);
		t = this.actionWithSize(cc.size(t, e));
		e = this._gridProxy;
		this._back ? (e.setTarget(this._inScene), e.onEnter(), this._inScene.visible = !1, e.runAction(cc.sequence(t, cc.callFunc(this.finish, this), cc.stopGrid())), this._inScene.runAction(cc.show())) : (e.setTarget(this._outScene), e.onEnter(), e.runAction(cc.sequence(t, cc.callFunc(this.finish, this), cc.stopGrid())))
	},
	visit: function() {
		this._back ? this._outScene.visit() : this._inScene.visit();
		this._gridProxy.visit()
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = this._back
	}
});
cc.TransitionPageTurn.create = function(t, e, i) {
	return new cc.TransitionPageTurn(t, e, i)
};
cc.Codec = {
	name: "Jacob__Codec"
};
cc.unzip = function() {
	return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
};
cc.unzipBase64 = function() {
	var t = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
	return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [t])
};
cc.unzipBase64AsArray = function(t, e) {
	e = e || 1;
	var i = this.unzipBase64(t),
		n = [],
		r, c, s;
	r = 0;
	for (s = i.length / e; r < s; r++) {
		n[r] = 0;
		for (c = e - 1; 0 <= c; --c) n[r] += i.charCodeAt(r * e + c) << 8 * c
	}
	return n
};
cc.unzipAsArray = function(t, e) {
	e = e || 1;
	var i = this.unzip(t),
		n = [],
		r, c, s;
	r = 0;
	for (s = i.length / e; r < s; r++) {
		n[r] = 0;
		for (c = e - 1; 0 <= c; --c) n[r] += i.charCodeAt(r * e + c) << 8 * c
	}
	return n
};
cc.StringToArray = function(t) {
	t = t.split(",");
	var e = [],
		i;
	for (i = 0; i < t.length; i++) e.push(parseInt(t[i]));
	return e
};
cc.Codec.Base64 = {
	name: "Jacob__Codec__Base64"
};
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
cc.Codec.Base64.decode = function(t) {
	var e = [],
		i, n, r, c, s, o = 0;
	for (t = t.replace(/[^A-Za-z0-9\+\/\=]/g, ""); o < t.length;) i = this._keyStr.indexOf(t.charAt(o++)), n = this._keyStr.indexOf(t.charAt(o++)), c = this._keyStr.indexOf(t.charAt(o++)), s = this._keyStr.indexOf(t.charAt(o++)), i = i << 2 | n >> 4, n = (n & 15) << 4 | c >> 2, r = (c & 3) << 6 | s, e.push(String.fromCharCode(i)), 64 != c && e.push(String.fromCharCode(n)), 64 != s && e.push(String.fromCharCode(r));
	return e = e.join("")
};
cc.Codec.Base64.decodeAsArray = function(t, e) {
	var i = this.decode(t),
		n = [],
		r, c, s;
	r = 0;
	for (s = i.length / e; r < s; r++) {
		n[r] = 0;
		for (c = e - 1; 0 <= c; --c) n[r] += i.charCodeAt(r * e + c) << 8 * c
	}
	return n
};
cc.uint8ArrayToUint32Array = function(t) {
	if (0 != t.length % 4) return null;
	for (var e = t.length / 4, i = window.Uint32Array ? new Uint32Array(e) : [], n = 0; n < e; n++) {
		var r = 4 * n;
		i[n] = t[r] + 256 * t[r + 1] + 65536 * t[r + 2] + 16777216 * t[r + 3]
	}
	return i
};
cc.Codec.GZip = function(t) {
	this.data = t;
	this.debug = !1;
	this.gpflags = void 0;
	this.files = 0;
	this.unzipped = [];
	this.buf32k = Array(32768);
	this.bIdx = 0;
	this.modeZIP = !1;
	this.bytepos = 0;
	this.bb = 1;
	this.bits = 0;
	this.nameBuf = [];
	this.fileout = void 0;
	this.literalTree = Array(cc.Codec.GZip.LITERALS);
	this.distanceTree = Array(32);
	this.treepos = 0;
	this.Places = null;
	this.len = 0;
	this.fpos = Array(17);
	this.fpos[0] = 0;
	this.fmax = this.flens = void 0
};
cc.Codec.GZip.gunzip = function(t) {
	return new cc.Codec.GZip(t).gunzip()[0][0]
};
cc.Codec.GZip.HufNode = function() {
	this.b1 = this.b0 = 0;
	this.jump = null;
	this.jumppos = -1
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255];
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function() {
	this.outputArr = [];
	this.nextFile();
	return this.unzipped
};
cc.Codec.GZip.prototype.readByte = function() {
	this.bits += 8;
	return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
};
cc.Codec.GZip.prototype.byteAlign = function() {
	this.bb = 1
};
cc.Codec.GZip.prototype.readBit = function() {
	var t;
	this.bits++;
	t = this.bb & 1;
	this.bb >>= 1;
	0 == this.bb && (this.bb = this.readByte(), t = this.bb & 1, this.bb = this.bb >> 1 | 128);
	return t
};
cc.Codec.GZip.prototype.readBits = function(t) {
	for (var e = 0, i = t; i--;) e = e << 1 | this.readBit();
	t && (e = cc.Codec.GZip.bitReverse[e] >> 8 - t);
	return e
};
cc.Codec.GZip.prototype.flushBuffer = function() {
	this.bIdx = 0
};
cc.Codec.GZip.prototype.addBuffer = function(t) {
	this.buf32k[this.bIdx++] = t;
	this.outputArr.push(String.fromCharCode(t));
	32768 == this.bIdx && (this.bIdx = 0)
};
cc.Codec.GZip.prototype.IsPat = function() {
	for (;;) {
		if (this.fpos[this.len] >= this.fmax) return -1;
		if (this.flens[this.fpos[this.len]] == this.len) return this.fpos[this.len]++;
		this.fpos[this.len]++
	}
};
cc.Codec.GZip.prototype.Rec = function() {
	var t = this.Places[this.treepos],
		e;
	if (17 == this.len) return -1;
	this.treepos++;
	this.len++;
	e = this.IsPat();
	if (0 <= e) t.b0 = e;
	else if (t.b0 = 32768, this.Rec()) return -1;
	e = this.IsPat();
	if (0 <= e) t.b1 = e, t.jump = null;
	else if (t.b1 = 32768, t.jump = this.Places[this.treepos], t.jumppos = this.treepos, this.Rec()) return -1;
	this.len--;
	return 0
};
cc.Codec.GZip.prototype.CreateTree = function(t, e, i, n) {
	this.Places = t;
	this.treepos = 0;
	this.flens = i;
	this.fmax = e;
	for (t = 0; 17 > t; t++) this.fpos[t] = 0;
	this.len = 0;
	return this.Rec() ? -1 : 0
};
cc.Codec.GZip.prototype.DecodeValue = function(t) {
	for (var e, i, n = 0, r = t[n];;) if (e = this.readBit()) {
		if (!(r.b1 & 32768)) return r.b1;
		r = r.jump;
		e = t.length;
		for (i = 0; i < e; i++) if (t[i] === r) {
			n = i;
			break
		}
	} else {
		if (!(r.b0 & 32768)) return r.b0;
		n++;
		r = t[n]
	}
	return -1
};
cc.Codec.GZip.prototype.DeflateLoop = function() {
	var t, e, i, n, r;
	do
	if (t = this.readBit(), i = this.readBits(2), 0 == i) {
		this.byteAlign();
		i = this.readByte();
		i |= this.readByte() << 8;
		e = this.readByte();
		e |= this.readByte() << 8;
		for ((i ^ ~e) & 65535 && document.write("BlockLen checksum mismatch\n"); i--;) e = this.readByte(), this.addBuffer(e)
	} else if (1 == i) for (;;) if (i = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, 23 < i ? (i = i << 1 | this.readBit(), 199 < i ? (i -= 128, i = i << 1 | this.readBit()) : (i -= 48, 143 < i && (i += 136))) : i += 256, 256 > i) this.addBuffer(i);
	else if (256 == i) break;
	else {
		var c;
		i -= 257;
		r = this.readBits(cc.Codec.GZip.cplext[i]) + cc.Codec.GZip.cplens[i];
		i = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
		8 < cc.Codec.GZip.cpdext[i] ? (c = this.readBits(8), c |= this.readBits(cc.Codec.GZip.cpdext[i] - 8) << 8) : c = this.readBits(cc.Codec.GZip.cpdext[i]);
		c += cc.Codec.GZip.cpdist[i];
		for (i = 0; i < r; i++) e = this.buf32k[this.bIdx - c & 32767], this.addBuffer(e)
	} else if (2 == i) {
		var s = Array(320);
		e = 257 + this.readBits(5);
		c = 1 + this.readBits(5);
		n = 4 + this.readBits(4);
		for (i = 0; 19 > i; i++) s[i] = 0;
		for (i = 0; i < n; i++) s[cc.Codec.GZip.border[i]] = this.readBits(3);
		r = this.distanceTree.length;
		for (n = 0; n < r; n++) this.distanceTree[n] = new cc.Codec.GZip.HufNode;
		if (this.CreateTree(this.distanceTree, 19, s, 0)) return this.flushBuffer(), 1;
		r = e + c;
		n = 0;
		for (var o = -1; n < r;) if (o++, i = this.DecodeValue(this.distanceTree), 16 > i) s[n++] = i;
		else if (16 == i) {
			var a;
			i = 3 + this.readBits(2);
			if (n + i > r) return this.flushBuffer(), 1;
			for (a = n ? s[n - 1] : 0; i--;) s[n++] = a
		} else {
			i = 17 == i ? 3 + this.readBits(3) : 11 + this.readBits(7);
			if (n + i > r) return this.flushBuffer(), 1;
			for (; i--;) s[n++] = 0
		}
		r = this.literalTree.length;
		for (n = 0; n < r; n++) this.literalTree[n] = new cc.Codec.GZip.HufNode;
		if (this.CreateTree(this.literalTree, e, s, 0)) return this.flushBuffer(), 1;
		r = this.literalTree.length;
		for (n = 0; n < r; n++) this.distanceTree[n] = new cc.Codec.GZip.HufNode;
		i = [];
		for (n = e; n < s.length; n++) i[n - e] = s[n];
		if (this.CreateTree(this.distanceTree, c, i, 0)) return this.flushBuffer(), 1;
		for (;;) if (i = this.DecodeValue(this.literalTree), 256 <= i) {
			i -= 256;
			if (0 == i) break;
			i--;
			r = this.readBits(cc.Codec.GZip.cplext[i]) + cc.Codec.GZip.cplens[i];
			i = this.DecodeValue(this.distanceTree);
			8 < cc.Codec.GZip.cpdext[i] ? (c = this.readBits(8), c |= this.readBits(cc.Codec.GZip.cpdext[i] - 8) << 8) : c = this.readBits(cc.Codec.GZip.cpdext[i]);
			for (c += cc.Codec.GZip.cpdist[i]; r--;) e = this.buf32k[this.bIdx - c & 32767], this.addBuffer(e)
		} else this.addBuffer(i)
	}
	while (!t);
	this.flushBuffer();
	this.byteAlign();
	return 0
};
cc.Codec.GZip.prototype.unzipFile = function(t) {
	var e;
	this.gunzip();
	for (e = 0; e < this.unzipped.length; e++) if (this.unzipped[e][1] == t) return this.unzipped[e][0]
};
cc.Codec.GZip.prototype.nextFile = function() {
	this.outputArr = [];
	this.modeZIP = !1;
	var t = [];
	t[0] = this.readByte();
	t[1] = this.readByte();
	120 == t[0] && 218 == t[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++);
	31 == t[0] && 139 == t[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++);
	if (80 == t[0] && 75 == t[1] && (this.modeZIP = !0, t[2] = this.readByte(), t[3] = this.readByte(), 3 == t[2] && 4 == t[3])) {
		t[0] = this.readByte();
		t[1] = this.readByte();
		this.gpflags = this.readByte();
		this.gpflags |= this.readByte() << 8;
		t = this.readByte();
		t |= this.readByte() << 8;
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		var e = this.readByte(),
			e = e | this.readByte() << 8,
			i = this.readByte(),
			i = i | this.readByte() << 8,
			n = 0;
		for (this.nameBuf = []; e--;) {
			var r = this.readByte();
			"/" == r | ":" == r ? n = 0 : n < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[n++] = String.fromCharCode(r))
		}
		this.fileout || (this.fileout = this.nameBuf);
		for (var n = 0; n < i;) this.readByte(), n++;
		8 == t && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++);
		this.skipdir()
	}
};
cc.Codec.GZip.prototype.skipdir = function() {
	var t = [],
		e;
	this.gpflags & 8 && (t[0] = this.readByte(), t[1] = this.readByte(), t[2] = this.readByte(), t[3] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte());
	this.modeZIP && this.nextFile();
	t[0] = this.readByte();
	if (8 != t[0]) return 0;
	this.gpflags = this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	if (this.gpflags & 4) {
		t[0] = this.readByte();
		t[2] = this.readByte();
		this.len = t[0] + 256 * t[1];
		for (t = 0; t < this.len; t++) this.readByte()
	}
	if (this.gpflags & 8) {
		t = 0;
		for (this.nameBuf = []; e = this.readByte();) {
			if ("7" == e || ":" == e) t = 0;
			t < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[t++] = e)
		}
	}
	if (this.gpflags & 16) for (; this.readByte(););
	this.gpflags & 2 && (this.readByte(), this.readByte());
	this.DeflateLoop();
	this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	this.modeZIP && this.nextFile()
};
(function() {
	function t(t) {
		throw t
	}
	function e(t, e) {
		var i = t.split("."),
			n = v;
		!(i[0] in n) && n.execScript && n.execScript("var " + i[0]);
		for (var r; i.length && (r = i.shift());)!i.length && e !== T ? n[r] = e : n = n[r] ? n[r] : n[r] = {}
	}
	function i(t) {
		if ("string" === typeof t) {
			t = t.split("");
			var e, i;
			e = 0;
			for (i = t.length; e < i; e++) t[e] = (t[e].charCodeAt(0) & 255) >>> 0
		}
		e = 1;
		i = 0;
		for (var n = t.length, r, c = 0; 0 < n;) {
			r = 1024 < n ? 1024 : n;
			n -= r;
			do e += t[c++], i += e;
			while (--r);
			e %= 65521;
			i %= 65521
		}
		return (i << 16 | e) >>> 0
	}
	function n(e, i) {
		this.index = "number" === typeof i ? i : 0;
		this.i = 0;
		this.buffer = e instanceof(A ? Uint8Array : Array) ? e : new(A ? Uint8Array : Array)(32768);
		2 * this.buffer.length <= this.index && t(Error("invalid index"));
		this.buffer.length <= this.index && this.f()
	}
	function r(t) {
		this.buffer = new(A ? Uint16Array : Array)(2 * t);
		this.length = 0
	}
	function c(t) {
		var e = t.length,
			i = 0,
			n = Number.POSITIVE_INFINITY,
			r, c, s, o, a, h, l, u, d;
		for (u = 0; u < e; ++u) t[u] > i && (i = t[u]), t[u] < n && (n = t[u]);
		r = 1 << i;
		c = new(A ? Uint32Array : Array)(r);
		s = 1;
		o = 0;
		for (a = 2; s <= i;) {
			for (u = 0; u < e; ++u) if (t[u] === s) {
				h = 0;
				l = o;
				for (d = 0; d < s; ++d) h = h << 1 | l & 1, l >>= 1;
				for (d = h; d < r; d += a) c[d] = s << 16 | u;
				++o
			}++s;
			o <<= 1;
			a <<= 1
		}
		return [c, i, n]
	}
	function s(t, e) {
		this.h = I;
		this.w = 0;
		this.input = t;
		this.b = 0;
		e && (e.lazy && (this.w = e.lazy), "number" === typeof e.compressionType && (this.h = e.compressionType), e.outputBuffer && (this.a = A && e.outputBuffer instanceof Array ? new Uint8Array(e.outputBuffer) : e.outputBuffer), "number" === typeof e.outputIndex && (this.b = e.outputIndex));
		this.a || (this.a = new(A ? Uint8Array : Array)(32768))
	}
	function o(t, e) {
		this.length = t;
		this.G = e
	}
	function a() {
		var e = w;
		switch (y) {
		case 3 === e:
			return [257, e - 3, 0];
		case 4 === e:
			return [258, e - 4, 0];
		case 5 === e:
			return [259, e - 5, 0];
		case 6 === e:
			return [260, e - 6, 0];
		case 7 === e:
			return [261, e - 7, 0];
		case 8 === e:
			return [262, e - 8, 0];
		case 9 === e:
			return [263, e - 9, 0];
		case 10 === e:
			return [264, e - 10, 0];
		case 12 >= e:
			return [265, e - 11, 1];
		case 14 >= e:
			return [266, e - 13, 1];
		case 16 >= e:
			return [267, e - 15, 1];
		case 18 >= e:
			return [268, e - 17, 1];
		case 22 >= e:
			return [269, e - 19, 2];
		case 26 >= e:
			return [270, e - 23, 2];
		case 30 >= e:
			return [271, e - 27, 2];
		case 34 >= e:
			return [272, e - 31, 2];
		case 42 >= e:
			return [273, e - 35, 3];
		case 50 >= e:
			return [274, e - 43, 3];
		case 58 >= e:
			return [275, e - 51, 3];
		case 66 >= e:
			return [276, e - 59, 3];
		case 82 >= e:
			return [277, e - 67, 4];
		case 98 >= e:
			return [278, e - 83, 4];
		case 114 >= e:
			return [279, e - 99, 4];
		case 130 >= e:
			return [280, e - 115, 4];
		case 162 >= e:
			return [281, e - 131, 5];
		case 194 >= e:
			return [282, e - 163, 5];
		case 226 >= e:
			return [283, e - 195, 5];
		case 257 >= e:
			return [284, e - 227, 5];
		case 258 === e:
			return [285, e - 258, 0];
		default:
			t("invalid length: " + e)
		}
	}
	function h(e, i) {
		function n(e, i) {
			var n = e.G,
				r = [],
				c = 0,
				s;
			s = F[e.length];
			r[c++] = s & 65535;
			r[c++] = s >> 16 & 255;
			r[c++] = s >> 24;
			var o;
			switch (y) {
			case 1 === n:
				o = [0, n - 1, 0];
				break;
			case 2 === n:
				o = [1, n - 2, 0];
				break;
			case 3 === n:
				o = [2, n - 3, 0];
				break;
			case 4 === n:
				o = [3, n - 4, 0];
				break;
			case 6 >= n:
				o = [4, n - 5, 1];
				break;
			case 8 >= n:
				o = [5, n - 7, 1];
				break;
			case 12 >= n:
				o = [6, n - 9, 2];
				break;
			case 16 >= n:
				o = [7, n - 13, 2];
				break;
			case 24 >= n:
				o = [8, n - 17, 3];
				break;
			case 32 >= n:
				o = [9, n - 25, 3];
				break;
			case 48 >= n:
				o = [10, n - 33, 4];
				break;
			case 64 >= n:
				o = [11, n - 49, 4];
				break;
			case 96 >= n:
				o = [12, n - 65, 5];
				break;
			case 128 >= n:
				o = [13, n - 97, 5];
				break;
			case 192 >= n:
				o = [14, n - 129, 6];
				break;
			case 256 >= n:
				o = [15, n - 193, 6];
				break;
			case 384 >= n:
				o = [16, n - 257, 7];
				break;
			case 512 >= n:
				o = [17, n - 385, 7];
				break;
			case 768 >= n:
				o = [18, n - 513, 8];
				break;
			case 1024 >= n:
				o = [19, n - 769, 8];
				break;
			case 1536 >= n:
				o = [20, n - 1025, 9];
				break;
			case 2048 >= n:
				o = [21, n - 1537, 9];
				break;
			case 3072 >= n:
				o = [22, n - 2049, 10];
				break;
			case 4096 >= n:
				o = [23, n - 3073, 10];
				break;
			case 6144 >= n:
				o = [24, n - 4097, 11];
				break;
			case 8192 >= n:
				o = [25, n - 6145, 11];
				break;
			case 12288 >= n:
				o = [26, n - 8193, 12];
				break;
			case 16384 >= n:
				o = [27, n - 12289, 12];
				break;
			case 24576 >= n:
				o = [28, n - 16385, 13];
				break;
			case 32768 >= n:
				o = [29, n - 24577, 13];
				break;
			default:
				t("invalid distance")
			}
			s = o;
			r[c++] = s[0];
			r[c++] = s[1];
			r[c++] = s[2];
			n = 0;
			for (c = r.length; n < c; ++n) d[_++] = r[n];
			p[r[0]]++;
			g[r[3]]++;
			f = e.length + i - 1;
			u = null
		}
		var r, c, s, a, h, l = {},
			u, d = A ? new Uint16Array(2 * i.length) : [],
			_ = 0,
			f = 0,
			p = new(A ? Uint32Array : Array)(286),
			g = new(A ? Uint32Array : Array)(30),
			m = e.w,
			v;
		if (!A) {
			for (s = 0; 285 >= s;) p[s++] = 0;
			for (s = 0; 29 >= s;) g[s++] = 0
		}
		p[256] = 1;
		r = 0;
		for (c = i.length; r < c; ++r) {
			s = h = 0;
			for (a = 3; s < a && r + s !== c; ++s) h = h << 8 | i[r + s];
			l[h] === T && (l[h] = []);
			s = l[h];
			if (!(0 < f--)) {
				for (; 0 < s.length && 32768 < r - s[0];) s.shift();
				if (r + 3 >= c) {
					u && n(u, -1);
					s = 0;
					for (a = c - r; s < a; ++s) v = i[r + s], d[_++] = v, ++p[v];
					break
				}
				if (0 < s.length) {
					h = a = T;
					var x = 0,
						E = T,
						S = T,
						C = E = T,
						R = i.length,
						S = 0,
						C = s.length;
					t: for (; S < C; S++) {
						a = s[C - S - 1];
						E = 3;
						if (3 < x) {
							for (E = x; 3 < E; E--) if (i[a + E - 1] !== i[r + E - 1]) continue t;
							E = x
						}
						for (; 258 > E && r + E < R && i[a + E] === i[r + E];)++E;
						E > x && (h = a, x = E);
						if (258 === E) break
					}
					a = new o(x, r - h);
					u ? u.length < a.length ? (v = i[r - 1], d[_++] = v, ++p[v], n(a, 0)) : n(u, -1) : a.length < m ? u = a : n(a, 0)
				} else u ? n(u, -1) : (v = i[r], d[_++] = v, ++p[v])
			}
			s.push(r)
		}
		d[_++] = 256;
		p[256]++;
		e.L = p;
		e.K = g;
		return A ? d.subarray(0, _) : d
	}
	function l(t, e) {
		function i(t) {
			var e = d[t][_[t]];
			e === l ? (i(t + 1), i(t + 1)) : --u[e];
			++_[t]
		}
		var n = t.length,
			c = new r(572),
			s = new(A ? Uint8Array : Array)(n),
			o, a, h;
		if (!A) for (a = 0; a < n; a++) s[a] = 0;
		for (a = 0; a < n; ++a) 0 < t[a] && c.push(a, t[a]);
		n = Array(c.length / 2);
		o = new(A ? Uint32Array : Array)(c.length / 2);
		if (1 === n.length) return s[c.pop().index] = 1, s;
		a = 0;
		for (h = c.length / 2; a < h; ++a) n[a] = c.pop(), o[a] = n[a].value;
		var l = o.length;
		a = new(A ? Uint16Array : Array)(e);
		var c = new(A ? Uint8Array : Array)(e),
			u = new(A ? Uint8Array : Array)(l);
		h = Array(e);
		var d = Array(e),
			_ = Array(e),
			f = (1 << e) - l,
			p = 1 << e - 1,
			g, m, T;
		a[e - 1] = l;
		for (g = 0; g < e; ++g) f < p ? c[g] = 0 : (c[g] = 1, f -= p), f <<= 1, a[e - 2 - g] = (a[e - 1 - g] / 2 | 0) + l;
		a[0] = c[0];
		h[0] = Array(a[0]);
		d[0] = Array(a[0]);
		for (g = 1; g < e; ++g) a[g] > 2 * a[g - 1] + c[g] && (a[g] = 2 * a[g - 1] + c[g]), h[g] = Array(a[g]), d[g] = Array(a[g]);
		for (f = 0; f < l; ++f) u[f] = e;
		for (p = 0; p < a[e - 1]; ++p) h[e - 1][p] = o[p], d[e - 1][p] = p;
		for (f = 0; f < e; ++f) _[f] = 0;
		1 === c[e - 1] && (--u[0], ++_[e - 1]);
		for (g = e - 2; 0 <= g; --g) {
			m = f = 0;
			T = _[g + 1];
			for (p = 0; p < a[g]; p++) m = h[g + 1][T] + h[g + 1][T + 1], m > o[f] ? (h[g][p] = m, d[g][p] = l, T += 2) : (h[g][p] = o[f], d[g][p] = f, ++f);
			_[g] = 0;
			1 === c[g] && i(g)
		}
		o = u;
		a = 0;
		for (h = n.length; a < h; ++a) s[n[a].index] = o[a];
		return s
	}
	function u(e) {
		var i = new(A ? Uint16Array : Array)(e.length),
			n = [],
			r = [],
			c = 0,
			s, o, a;
		s = 0;
		for (o = e.length; s < o; s++) n[e[s]] = (n[e[s]] | 0) + 1;
		s = 1;
		for (o = 16; s <= o; s++) r[s] = c, c += n[s] | 0, c > 1 << s && t("overcommitted"), c <<= 1;
		65536 > c && t("undercommitted");
		s = 0;
		for (o = e.length; s < o; s++) {
			c = r[e[s]];
			r[e[s]] += 1;
			n = i[s] = 0;
			for (a = e[s]; n < a; n++) i[s] = i[s] << 1 | c & 1, c >>>= 1
		}
		return i
	}
	function d(t, e) {
		this.input = t;
		this.a = new(A ? Uint8Array : Array)(32768);
		this.h = L.j;
		var i = {},
			n;
		if ((e || !(e = {})) && "number" === typeof e.compressionType) this.h = e.compressionType;
		for (n in e) i[n] = e[n];
		i.outputBuffer = this.a;
		this.z = new s(this.input, i)
	}
	function _(e, i) {
		this.k = [];
		this.l = 32768;
		this.e = this.g = this.c = this.q = 0;
		this.input = A ? new Uint8Array(e) : e;
		this.s = !1;
		this.m = D;
		this.B = !1;
		if (i || !(i = {})) i.index && (this.c = i.index), i.bufferSize && (this.l = i.bufferSize), i.bufferType && (this.m = i.bufferType), i.resize && (this.B = i.resize);
		switch (this.m) {
		case O:
			this.b = 32768;
			this.a = new(A ? Uint8Array : Array)(32768 + this.l + 258);
			break;
		case D:
			this.b = 0;
			this.a = new(A ? Uint8Array : Array)(this.l);
			this.f = this.J;
			this.t = this.H;
			this.o = this.I;
			break;
		default:
			t(Error("invalid inflate mode"))
		}
	}
	function f(e, i) {
		for (var n = e.g, r = e.e, c = e.input, s = e.c, o; r < i;) o = c[s++], o === T && t(Error("input buffer is broken")), n |= o << r, r += 8;
		e.g = n >>> i;
		e.e = r - i;
		e.c = s;
		return n & (1 << i) - 1
	}
	function p(e, i) {
		for (var n = e.g, r = e.e, c = e.input, s = e.c, o = i[0], a = i[1], h; r < a;) h = c[s++], h === T && t(Error("input buffer is broken")), n |= h << r, r += 8;
		c = o[n & (1 << a) - 1];
		o = c >>> 16;
		e.g = n >> o;
		e.e = r - o;
		e.c = s;
		return c & 65535
	}
	function g(t) {
		function e(t, e, i) {
			var n, r, c, s;
			for (s = 0; s < t;) switch (n = p(this, e), n) {
			case 16:
				for (c = 3 + f(this, 2); c--;) i[s++] = r;
				break;
			case 17:
				for (c = 3 + f(this, 3); c--;) i[s++] = 0;
				r = 0;
				break;
			case 18:
				for (c = 11 + f(this, 7); c--;) i[s++] = 0;
				r = 0;
				break;
			default:
				r = i[s++] = n
			}
			return i
		}
		var i = f(t, 5) + 257,
			n = f(t, 5) + 1,
			r = f(t, 4) + 4,
			s = new(A ? Uint8Array : Array)(N.length),
			o;
		for (o = 0; o < r; ++o) s[N[o]] = f(t, 3);
		r = c(s);
		s = new(A ? Uint8Array : Array)(i);
		o = new(A ? Uint8Array : Array)(n);
		t.o(c(e.call(t, i, r, s)), c(e.call(t, n, r, o)))
	}
	function m(e, i) {
		var n, r;
		this.input = e;
		this.c = 0;
		if (i || !(i = {})) i.index && (this.c = i.index), i.verify && (this.M = i.verify);
		n = e[this.c++];
		r = e[this.c++];
		switch (n & 15) {
		case z:
			this.method = z;
			break;
		default:
			t(Error("unsupported compression method"))
		}
		0 !== ((n << 8) + r) % 31 && t(Error("invalid fcheck flag:" + ((n << 8) + r) % 31));
		r & 32 && t(Error("fdict flag is not supported"));
		this.A = new _(e, {
			index: this.c,
			bufferSize: i.bufferSize,
			bufferType: i.bufferType,
			resize: i.resize
		})
	}
	var T = void 0,
		y = !0,
		v = this,
		A = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
	n.prototype.f = function() {
		var t = this.buffer,
			e, i = t.length,
			n = new(A ? Uint8Array : Array)(i << 1);
		if (A) n.set(t);
		else for (e = 0; e < i; ++e) n[e] = t[e];
		return this.buffer = n
	};
	n.prototype.d = function(t, e, i) {
		var n = this.buffer,
			r = this.index,
			c = this.i,
			s = n[r];
		i && 1 < e && (t = 8 < e ? (b[t & 255] << 24 | b[t >>> 8 & 255] << 16 | b[t >>> 16 & 255] << 8 | b[t >>> 24 & 255]) >> 32 - e : b[t] >> 8 - e);
		if (8 > e + c) s = s << e | t, c += e;
		else for (i = 0; i < e; ++i) s = s << 1 | t >> e - i - 1 & 1, 8 === ++c && (c = 0, n[r++] = b[s], s = 0, r === n.length && (n = this.f()));
		n[r] = s;
		this.buffer = n;
		this.i = c;
		this.index = r
	};
	n.prototype.finish = function() {
		var t = this.buffer,
			e = this.index,
			i;
		0 < this.i && (t[e] <<= 8 - this.i, t[e] = b[t[e]], e++);
		A ? i = t.subarray(0, e) : (t.length = e, i = t);
		return i
	};
	var x = new(A ? Uint8Array : Array)(256),
		E;
	for (E = 0; 256 > E; ++E) {
		for (var S = E, C = S, R = 7, S = S >>> 1; S; S >>>= 1) C <<= 1, C |= S & 1, --R;
		x[E] = (C << R & 255) >>> 0
	}
	var b = x,
		x = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
	A && new Uint32Array(x);
	r.prototype.getParent = function(t) {
		return 2 * ((t - 2) / 4 | 0)
	};
	r.prototype.push = function(t, e) {
		var i, n, r = this.buffer,
			c;
		i = this.length;
		r[this.length++] = e;
		for (r[this.length++] = t; 0 < i;) if (n = this.getParent(i), r[i] > r[n]) c = r[i], r[i] = r[n], r[n] = c, c = r[i + 1], r[i + 1] = r[n + 1], r[n + 1] = c, i = n;
		else break;
		return this.length
	};
	r.prototype.pop = function() {
		var t, e, i = this.buffer,
			n, r, c;
		e = i[0];
		t = i[1];
		this.length -= 2;
		i[0] = i[this.length];
		i[1] = i[this.length + 1];
		for (c = 0;;) {
			r = 2 * c + 2;
			if (r >= this.length) break;
			r + 2 < this.length && i[r + 2] > i[r] && (r += 2);
			if (i[r] > i[c]) n = i[c], i[c] = i[r], i[r] = n, n = i[c + 1], i[c + 1] = i[r + 1], i[r + 1] = n;
			else break;
			c = r
		}
		return {
			index: t,
			value: e,
			length: this.length
		}
	};
	var I = 2,
		x = {
			NONE: 0,
			r: 1,
			j: I,
			N: 3
		},
		P = [];
	for (E = 0; 288 > E; E++) switch (y) {
	case 143 >= E:
		P.push([E + 48, 8]);
		break;
	case 255 >= E:
		P.push([E - 144 + 400, 9]);
		break;
	case 279 >= E:
		P.push([E - 256 + 0, 7]);
		break;
	case 287 >= E:
		P.push([E - 280 + 192, 8]);
		break;
	default:
		t("invalid literal: " + E)
	}
	s.prototype.n = function() {
		var e, i, r, c, s = this.input;
		switch (this.h) {
		case 0:
			r = 0;
			for (c = s.length; r < c;) {
				i = A ? s.subarray(r, r + 65535) : s.slice(r, r + 65535);
				r += i.length;
				var o = r === c,
					a = T,
					d = a = T,
					d = a = T,
					_ = this.a,
					f = this.b;
				if (A) {
					for (_ = new Uint8Array(this.a.buffer); _.length <= f + i.length + 5;) _ = new Uint8Array(_.length << 1);
					_.set(this.a)
				}
				a = o ? 1 : 0;
				_[f++] = a | 0;
				a = i.length;
				d = ~a + 65536 & 65535;
				_[f++] = a & 255;
				_[f++] = a >>> 8 & 255;
				_[f++] = d & 255;
				_[f++] = d >>> 8 & 255;
				if (A) _.set(i, f), f += i.length, _ = _.subarray(0, f);
				else {
					a = 0;
					for (d = i.length; a < d; ++a) _[f++] = i[a];
					_.length = f
				}
				this.b = f;
				this.a = _
			}
			break;
		case 1:
			r = new n(new Uint8Array(this.a.buffer), this.b);
			r.d(1, 1, y);
			r.d(1, 2, y);
			s = h(this, s);
			i = 0;
			for (o = s.length; i < o; i++) if (c = s[i], n.prototype.d.apply(r, P[c]), 256 < c) r.d(s[++i], s[++i], y), r.d(s[++i], 5), r.d(s[++i], s[++i], y);
			else if (256 === c) break;
			this.a = r.finish();
			this.b = this.a.length;
			break;
		case I:
			c = new n(new Uint8Array(this.a), this.b);
			var p, g, m, v = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
				x, E, a = Array(19),
				S, _ = I;
			c.d(1, 1, y);
			c.d(_, 2, y);
			s = h(this, s);
			d = l(this.L, 15);
			x = u(d);
			_ = l(this.K, 7);
			f = u(_);
			for (p = 286; 257 < p && 0 === d[p - 1]; p--);
			for (g = 30; 1 < g && 0 === _[g - 1]; g--);
			var C = p,
				R = g;
			e = new(A ? Uint32Array : Array)(C + R);
			var b = new(A ? Uint32Array : Array)(316),
				w, F;
			E = new(A ? Uint8Array : Array)(19);
			for (S = m = 0; S < C; S++) e[m++] = d[S];
			for (S = 0; S < R; S++) e[m++] = _[S];
			if (!A) {
				S = 0;
				for (R = E.length; S < R; ++S) E[S] = 0
			}
			S = w = 0;
			for (R = e.length; S < R; S += m) {
				for (m = 1; S + m < R && e[S + m] === e[S]; ++m);
				C = m;
				if (0 === e[S]) if (3 > C) for (; 0 < C--;) b[w++] = 0, E[0]++;
				else for (; 0 < C;) F = 138 > C ? C : 138, F > C - 3 && F < C && (F = C - 3), 10 >= F ? (b[w++] = 17, b[w++] = F - 3, E[17]++) : (b[w++] = 18, b[w++] = F - 11, E[18]++), C -= F;
				else if (b[w++] = e[S], E[e[S]]++, C--, 3 > C) for (; 0 < C--;) b[w++] = e[S], E[e[S]]++;
				else for (; 0 < C;) F = 6 > C ? C : 6, F > C - 3 && F < C && (F = C - 3), b[w++] = 16, b[w++] = F - 3, E[16]++, C -= F
			}
			e = A ? b.subarray(0, w) : b.slice(0, w);
			E = l(E, 7);
			for (S = 0; 19 > S; S++) a[S] = E[v[S]];
			for (m = 19; 4 < m && 0 === a[m - 1]; m--);
			v = u(E);
			c.d(p - 257, 5, y);
			c.d(g - 1, 5, y);
			c.d(m - 4, 4, y);
			for (S = 0; S < m; S++) c.d(a[S], 3, y);
			S = 0;
			for (a = e.length; S < a; S++) if (i = e[S], c.d(v[i], E[i], y), 16 <= i) {
				S++;
				switch (i) {
				case 16:
					o = 2;
					break;
				case 17:
					o = 3;
					break;
				case 18:
					o = 7;
					break;
				default:
					t("invalid code: " + i)
				}
				c.d(e[S], o, y)
			}
			o = [x, d];
			f = [f, _];
			i = o[0];
			o = o[1];
			_ = f[0];
			x = f[1];
			f = 0;
			for (a = s.length; f < a; ++f) if (r = s[f], c.d(i[r], o[r], y), 256 < r) c.d(s[++f], s[++f], y), d = s[++f], c.d(_[d], x[d], y), c.d(s[++f], s[++f], y);
			else if (256 === r) break;
			this.a = c.finish();
			this.b = this.a.length;
			break;
		default:
			t("invalid compression type")
		}
		return this.a
	};
	E = [];
	var w;
	for (w = 3; 258 >= w; w++) S = a(), E[w] = S[2] << 24 | S[1] << 16 | S[0];
	var F = A ? new Uint32Array(E) : E,
		L = x;
	d.prototype.n = function() {
		var e, n, r, c, s = 0;
		c = this.a;
		e = z;
		switch (e) {
		case z:
			n = Math.LOG2E * Math.log(32768) - 8;
			break;
		default:
			t(Error("invalid compression method"))
		}
		n = n << 4 | e;
		c[s++] = n;
		switch (e) {
		case z:
			switch (this.h) {
			case L.NONE:
				r = 0;
				break;
			case L.r:
				r = 1;
				break;
			case L.j:
				r = 2;
				break;
			default:
				t(Error("unsupported compression type"))
			}
			break;
		default:
			t(Error("invalid compression method"))
		}
		e = r << 6 | 0;
		c[s++] = e | 31 - (256 * n + e) % 31;
		e = i(this.input);
		this.z.b = s;
		c = this.z.n();
		s = c.length;
		A && (c = new Uint8Array(c.buffer), c.length <= s + 4 && (this.a = new Uint8Array(c.length + 4), this.a.set(c), c = this.a), c = c.subarray(0, s + 4));
		c[s++] = e >> 24 & 255;
		c[s++] = e >> 16 & 255;
		c[s++] = e >> 8 & 255;
		c[s++] = e & 255;
		return c
	};
	e("Zlib.Deflate", d);
	e("Zlib.Deflate.compress", function(t, e) {
		return new d(t, e).n()
	});
	e("Zlib.Deflate.CompressionType", L);
	e("Zlib.Deflate.CompressionType.NONE", L.NONE);
	e("Zlib.Deflate.CompressionType.FIXED", L.r);
	e("Zlib.Deflate.CompressionType.DYNAMIC", L.j);
	var O = 0,
		D = 1,
		x = {
			D: O,
			C: D
		};
	_.prototype.p = function() {
		for (; !this.s;) {
			var e = f(this, 3);
			e & 1 && (this.s = y);
			e >>>= 1;
			switch (e) {
			case 0:
				var e = this.input,
					i = this.c,
					n = this.a,
					r = this.b,
					c = T,
					s = T,
					o = T,
					a = n.length,
					c = T;
				this.e = this.g = 0;
				c = e[i++];
				c === T && t(Error("invalid uncompressed block header: LEN (first byte)"));
				s = c;
				c = e[i++];
				c === T && t(Error("invalid uncompressed block header: LEN (second byte)"));
				s |= c << 8;
				c = e[i++];
				c === T && t(Error("invalid uncompressed block header: NLEN (first byte)"));
				o = c;
				c = e[i++];
				c === T && t(Error("invalid uncompressed block header: NLEN (second byte)"));
				o |= c << 8;
				s === ~o && t(Error("invalid uncompressed block header: length verify"));
				i + s > e.length && t(Error("input buffer is broken"));
				switch (this.m) {
				case O:
					for (; r + s > n.length;) {
						c = a - r;
						s -= c;
						if (A) n.set(e.subarray(i, i + c), r), r += c, i += c;
						else for (; c--;) n[r++] = e[i++];
						this.b = r;
						n = this.f();
						r = this.b
					}
					break;
				case D:
					for (; r + s > n.length;) n = this.f({
						v: 2
					});
					break;
				default:
					t(Error("invalid inflate mode"))
				}
				if (A) n.set(e.subarray(i, i + s), r), r += s, i += s;
				else for (; s--;) n[r++] = e[i++];
				this.c = i;
				this.b = r;
				this.a = n;
				break;
			case 1:
				this.o(G, V);
				break;
			case 2:
				g(this);
				break;
			default:
				t(Error("unknown BTYPE: " + e))
			}
		}
		return this.t()
	};
	E = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	var N = A ? new Uint16Array(E) : E;
	E = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
	var M = A ? new Uint16Array(E) : E;
	E = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
	var B = A ? new Uint8Array(E) : E;
	E = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
	var W = A ? new Uint16Array(E) : E;
	E = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
	var k = A ? new Uint8Array(E) : E;
	E = new(A ? Uint8Array : Array)(288);
	S = 0;
	for (C = E.length; S < C; ++S) E[S] = 143 >= S ? 8 : 255 >= S ? 9 : 279 >= S ? 7 : 8;
	var G = c(E);
	E = new(A ? Uint8Array : Array)(30);
	S = 0;
	for (C = E.length; S < C; ++S) E[S] = 5;
	var V = c(E);
	_.prototype.o = function(t, e) {
		var i = this.a,
			n = this.b;
		this.u = t;
		for (var r = i.length - 258, c, s, o; 256 !== (c = p(this, t));) if (256 > c) n >= r && (this.b = n, i = this.f(), n = this.b), i[n++] = c;
		else {
			c -= 257;
			o = M[c];
			0 < B[c] && (o += f(this, B[c]));
			c = p(this, e);
			s = W[c];
			0 < k[c] && (s += f(this, k[c]));
			for (n >= r && (this.b = n, i = this.f(), n = this.b); o--;) i[n] = i[n++-s]
		}
		for (; 8 <= this.e;) this.e -= 8, this.c--;
		this.b = n
	};
	_.prototype.I = function(t, e) {
		var i = this.a,
			n = this.b;
		this.u = t;
		for (var r = i.length, c, s, o; 256 !== (c = p(this, t));) if (256 > c) n >= r && (i = this.f(), r = i.length), i[n++] = c;
		else {
			c -= 257;
			o = M[c];
			0 < B[c] && (o += f(this, B[c]));
			c = p(this, e);
			s = W[c];
			0 < k[c] && (s += f(this, k[c]));
			for (n + o > r && (i = this.f(), r = i.length); o--;) i[n] = i[n++-s]
		}
		for (; 8 <= this.e;) this.e -= 8, this.c--;
		this.b = n
	};
	_.prototype.f = function() {
		var t = new(A ? Uint8Array : Array)(this.b - 32768),
			e = this.b - 32768,
			i, n, r = this.a;
		if (A) t.set(r.subarray(32768, t.length));
		else {
			i = 0;
			for (n = t.length; i < n; ++i) t[i] = r[i + 32768]
		}
		this.k.push(t);
		this.q += t.length;
		if (A) r.set(r.subarray(e, e + 32768));
		else for (i = 0; 32768 > i; ++i) r[i] = r[e + i];
		this.b = 32768;
		return r
	};
	_.prototype.J = function(t) {
		var e, i = this.input.length / this.c + 1 | 0,
			n, r, c, s = this.input,
			o = this.a;
		t && ("number" === typeof t.v && (i = t.v), "number" === typeof t.F && (i += t.F));
		2 > i ? (n = (s.length - this.c) / this.u[2], c = 258 * (n / 2) | 0, r = c < o.length ? o.length + c : o.length << 1) : r = o.length * i;
		A ? (e = new Uint8Array(r), e.set(o)) : e = o;
		return this.a = e
	};
	_.prototype.t = function() {
		var t = 0,
			e = this.a,
			i = this.k,
			n, r = new(A ? Uint8Array : Array)(this.q + (this.b - 32768)),
			c, s, o, a;
		if (0 === i.length) return A ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
		c = 0;
		for (s = i.length; c < s; ++c) {
			n = i[c];
			o = 0;
			for (a = n.length; o < a; ++o) r[t++] = n[o]
		}
		c = 32768;
		for (s = this.b; c < s; ++c) r[t++] = e[c];
		this.k = [];
		return this.buffer = r
	};
	_.prototype.H = function() {
		var t, e = this.b;
		A ? this.B ? (t = new Uint8Array(e), t.set(this.a.subarray(0, e))) : t = this.a.subarray(0, e) : (this.a.length > e && (this.a.length = e), t = this.a);
		return this.buffer = t
	};
	m.prototype.p = function() {
		var e = this.input,
			n, r;
		n = this.A.p();
		this.c = this.A.c;
		this.M && (r = (e[this.c++] << 24 | e[this.c++] << 16 | e[this.c++] << 8 | e[this.c++]) >>> 0, r !== i(n) && t(Error("invalid adler-32 checksum")));
		return n
	};
	e("Zlib.Inflate", m);
	e("Zlib.Inflate.BufferType", x);
	x.ADAPTIVE = x.C;
	x.BLOCK = x.D;
	e("Zlib.Inflate.prototype.decompress", m.prototype.p);
	x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	A && new Uint16Array(x);
	x = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
	A && new Uint16Array(x);
	x = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
	A && new Uint8Array(x);
	x = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
	A && new Uint16Array(x);
	x = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
	A && new Uint8Array(x);
	x = new(A ? Uint8Array : Array)(288);
	E = 0;
	for (S = x.length; E < S; ++E) x[E] = 143 >= E ? 8 : 255 >= E ? 9 : 279 >= E ? 7 : 8;
	c(x);
	x = new(A ? Uint8Array : Array)(30);
	E = 0;
	for (S = x.length; E < S; ++E) x[E] = 5;
	c(x);
	var z = 8
}).call(this);
_p = window;
_p = _p.Zlib = _p.Zlib;
_p.Deflate = _p.Deflate;
_p.Deflate.compress = _p.Deflate.compress;
_p.Inflate = _p.Inflate;
_p.Inflate.BufferType = _p.Inflate.BufferType;
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
cc.PNGReader = cc.Class.extend({
	ctor: function(t) {
		var e, i, n, r;
		this.data = t;
		this.pos = 8;
		this.palette = [];
		this.imgData = [];
		this.transparency = {};
		this.animation = null;
		this.text = {};
		for (n = null;;) {
			e = this.readUInt32();
			r = t = void 0;
			r = [];
			for (t = 0; 4 > t; ++t) r.push(String.fromCharCode(this.data[this.pos++]));
			t = r.join("");
			switch (t) {
			case "IHDR":
				this.width = this.readUInt32();
				this.height = this.readUInt32();
				this.bits = this.data[this.pos++];
				this.colorType = this.data[this.pos++];
				this.compressionMethod = this.data[this.pos++];
				this.filterMethod = this.data[this.pos++];
				this.interlaceMethod = this.data[this.pos++];
				break;
			case "acTL":
				this.animation = {
					numFrames: this.readUInt32(),
					numPlays: this.readUInt32() || Infinity,
					frames: []
				};
				break;
			case "PLTE":
				this.palette = this.read(e);
				break;
			case "fcTL":
				n && this.animation.frames.push(n);
				this.pos += 4;
				n = {
					width: this.readUInt32(),
					height: this.readUInt32(),
					xOffset: this.readUInt32(),
					yOffset: this.readUInt32()
				};
				t = this.readUInt16();
				e = this.readUInt16() || 100;
				n.delay = 1e3 * t / e;
				n.disposeOp = this.data[this.pos++];
				n.blendOp = this.data[this.pos++];
				n.data = [];
				break;
			case "IDAT":
			case "fdAT":
				"fdAT" === t && (this.pos += 4, e -= 4);
				t = (null != n ? n.data : void 0) || this.imgData;
				for (r = 0; 0 <= e ? r < e : r > e; 0 <= e ? ++r : --r) t.push(this.data[this.pos++]);
				break;
			case "tRNS":
				this.transparency = {};
				switch (this.colorType) {
				case 3:
					this.transparency.indexed = this.read(e);
					e = 255 - this.transparency.indexed.length;
					if (0 < e) for (t = 0; 0 <= e ? t < e : t > e; 0 <= e ? ++t : --t) this.transparency.indexed.push(255);
					break;
				case 0:
					this.transparency.grayscale = this.read(e)[0];
					break;
				case 2:
					this.transparency.rgb = this.read(e)
				}
				break;
			case "tEXt":
				r = this.read(e);
				e = r.indexOf(0);
				t = String.fromCharCode.apply(String, r.slice(0, e));
				this.text[t] = String.fromCharCode.apply(String, r.slice(e + 1));
				break;
			case "IEND":
				n && this.animation.frames.push(n);
				t: {
					switch (this.colorType) {
					case 0:
					case 3:
					case 4:
						n = 1;
						break t;
					case 2:
					case 6:
						n = 3;
						break t
					}
					n = void 0
				}
				this.colors = n;
				this.hasAlphaChannel = 4 === (i = this.colorType) || 6 === i;
				i = this.colors + (this.hasAlphaChannel ? 1 : 0);
				this.pixelBitlength = this.bits * i;
				t: {
					switch (this.colors) {
					case 1:
						i = "DeviceGray";
						break t;
					case 3:
						i = "DeviceRGB";
						break t
					}
					i = void 0
				}
				this.colorSpace = i;
				Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
				return;
			default:
				this.pos += e
			}
			this.pos += 4;
			if (this.pos > this.data.length) throw Error("Incomplete or corrupt PNG file")
		}
	},
	read: function(t) {
		var e, i;
		i = [];
		for (e = 0; 0 <= t ? e < t : e > t; 0 <= t ? ++e : --e) i.push(this.data[this.pos++]);
		return i
	},
	readUInt32: function() {
		var t, e, i, n;
		t = this.data[this.pos++] << 24;
		e = this.data[this.pos++] << 16;
		i = this.data[this.pos++] << 8;
		n = this.data[this.pos++];
		return t | e | i | n
	},
	readUInt16: function() {
		var t, e;
		t = this.data[this.pos++] << 8;
		e = this.data[this.pos++];
		return t | e
	},
	decodePixels: function(t) {
		var e, i, n, r, c, s, o, a, h, l, u, d, _, f, p;
		null == t && (t = this.imgData);
		if (0 === t.length) return new Uint8Array(0);
		t = new Zlib.Inflate(t, {
			index: 0,
			verify: !1
		}).decompress();
		a = this.pixelBitlength / 8;
		d = a * this.width;
		h = new Uint8Array(d * this.height);
		s = t.length;
		for (i = l = u = 0; l < s;) {
			switch (t[l++]) {
			case 0:
				for (e = 0; e < d; e += 1) h[i++] = t[l++];
				break;
			case 1:
				for (r = _ = 0; _ < d; r = _ += 1) e = t[l++], c = r < a ? 0 : h[i - a], h[i++] = (e + c) % 256;
				break;
			case 2:
				for (r = c = 0; c < d; r = c += 1) e = t[l++], n = (r - r % a) / a, _ = u && h[(u - 1) * d + n * a + r % a], h[i++] = (_ + e) % 256;
				break;
			case 3:
				for (r = p = 0; p < d; r = p += 1) e = t[l++], n = (r - r % a) / a, c = r < a ? 0 : h[i - a], _ = u && h[(u - 1) * d + n * a + r % a], h[i++] = (e + Math.floor((c + _) / 2)) % 256;
				break;
			case 4:
				for (r = p = 0; p < d; r = p += 1) e = t[l++], n = (r - r % a) / a, c = r < a ? 0 : h[i - a], 0 === u ? _ = f = 0 : (_ = h[(u - 1) * d + n * a + r % a], f = n && h[(u - 1) * d + (n - 1) * a + r % a]), o = c + _ - f, r = Math.abs(o - c), n = Math.abs(o - _), o = Math.abs(o - f), c = r <= n && r <= o ? c : n <= o ? _ : f, h[i++] = (e + c) % 256;
				break;
			default:
				throw Error("Invalid filter algorithm: " + t[l - 1])
			}
			u++
		}
		return h
	},
	copyToImageData: function(t, e) {
		var i, n, r, c, s, o, a, h;
		n = this.colors;
		h = null;
		i = this.hasAlphaChannel;
		this.palette.length && (h = null != (r = this._decodedPalette) ? r : this._decodedPalette = this.decodePalette(), n = 4, i = !0);
		r = t.data || t;
		a = r.length;
		s = h || e;
		c = o = 0;
		if (1 === n) for (; c < a;) n = h ? 4 * e[c / 4] : o, o = s[n++], r[c++] = o, r[c++] = o, r[c++] = o, r[c++] = i ? s[n++] : 255, o = n;
		else for (; c < a;) n = h ? 4 * e[c / 4] : o, r[c++] = s[n++], r[c++] = s[n++], r[c++] = s[n++], r[c++] = i ? s[n++] : 255, o = n
	},
	decodePalette: function() {
		var t, e, i, n, r, c, s, o, a;
		i = this.palette;
		c = this.transparency.indexed || [];
		r = new Uint8Array((c.length || 0) + i.length);
		e = s = t = n = 0;
		for (o = i.length; s < o; e = s += 3) r[n++] = i[e], r[n++] = i[e + 1], r[n++] = i[e + 2], r[n++] = null != (a = c[t++]) ? a : 255;
		return r
	},
	render: function(t) {
		var e;
		t.width = this.width;
		t.height = this.height;
		t = t.getContext("2d");
		e = t.createImageData(this.width, this.height);
		this.copyToImageData(e, this.decodePixels());
		return t.putImageData(e, 0, 0)
	}
});
cc.tiffReader = {
	_littleEndian: !1,
	_tiffData: null,
	_fileDirectories: [],
	getUint8: function(t) {
		return this._tiffData[t]
	},
	getUint16: function(t) {
		return this._littleEndian ? this._tiffData[t + 1] << 8 | this._tiffData[t] : this._tiffData[t] << 8 | this._tiffData[t + 1]
	},
	getUint32: function(t) {
		var e = this._tiffData;
		return this._littleEndian ? e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t] : e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
	},
	checkLittleEndian: function() {
		var t = this.getUint16(0);
		if (18761 === t) this.littleEndian = !0;
		else if (19789 === t) this.littleEndian = !1;
		else throw console.log(t), TypeError("Invalid byte order value.");
		return this.littleEndian
	},
	hasTowel: function() {
		if (42 !== this.getUint16(2)) throw RangeError("You forgot your towel!");
		return !0
	},
	getFieldTypeName: function(t) {
		var e = this.fieldTypeNames;
		return t in e ? e[t] : null
	},
	getFieldTagName: function(t) {
		var e = this.fieldTagNames;
		if (t in e) return e[t];
		console.log("Unknown Field Tag:", t);
		return "Tag" + t
	},
	getFieldTypeLength: function(t) {
		return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(t) ? 1 : -1 !== ["SHORT", "SSHORT"].indexOf(t) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(t) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(t) ? 8 : null
	},
	getFieldValues: function(t, e, i, n) {
		t = [];
		var r = this.getFieldTypeLength(e);
		if (4 >= r * i)!1 === this.littleEndian ? t.push(n >>> 8 * (4 - r)) : t.push(n);
		else for (var c = 0; c < i; c++) {
			var s = r * c;
			8 <= r ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(e) ? (t.push(this.getUint32(n + s)), t.push(this.getUint32(n + s + 4))) : cc.log("Can't handle this field type or size") : t.push(this.getBytes(r, n + s))
		}
		"ASCII" === e && t.forEach(function(t, e, i) {
			i[e] = String.fromCharCode(t)
		});
		return t
	},
	getBytes: function(t, e) {
		if (0 >= t) cc.log("No bytes requested");
		else {
			if (1 >= t) return this.getUint8(e);
			if (2 >= t) return this.getUint16(e);
			if (3 >= t) return this.getUint32(e) >>> 8;
			if (4 >= t) return this.getUint32(e);
			cc.log("Too many bytes requested")
		}
	},
	getBits: function(t, e, i) {
		i = i || 0;
		e += Math.floor(i / 8);
		var n = i + t;
		t = 32 - t;
		var r, c;
		0 >= n ? console.log("No bits requested") : 8 >= n ? (r = 24 + i, c = this.getUint8(e)) : 16 >= n ? (r = 16 + i, c = this.getUint16(e)) : 32 >= n ? (r = i, c = this.getUint32(e)) : console.log("Too many bits requested");
		return {
			bits: c << r >>> t,
			byteOffset: e + Math.floor(n / 8),
			bitOffset: n % 8
		}
	},
	parseFileDirectory: function(t) {
		var e = this.getUint16(t),
			i = [];
		t += 2;
		for (var n = 0; n < e; t += 12, n++) {
			var r = this.getUint16(t),
				c = this.getUint16(t + 2),
				s = this.getUint32(t + 4),
				o = this.getUint32(t + 8),
				r = this.getFieldTagName(r),
				c = this.getFieldTypeName(c),
				s = this.getFieldValues(r, c, s, o);
			i[r] = {
				type: c,
				values: s
			}
		}
		this._fileDirectories.push(i);
		e = this.getUint32(t);
		0 !== e && this.parseFileDirectory(e)
	},
	clampColorSample: function(t, e) {
		var i = Math.pow(2, 8 - e);
		return Math.floor(t * i + (i - 1))
	},
	parseTIFF: function(t, e) {
		e = e || cc.newElement("canvas");
		this._tiffData = t;
		this.canvas = e;
		this.checkLittleEndian();
		if (this.hasTowel()) {
			var i = this.getUint32(4);
			this._fileDirectories.length = 0;
			this.parseFileDirectory(i);
			var n = this._fileDirectories[0],
				i = n.ImageWidth.values[0],
				r = n.ImageLength.values[0];
			this.canvas.width = i;
			this.canvas.height = r;
			var c = [],
				s = n.Compression ? n.Compression.values[0] : 1,
				o = n.SamplesPerPixel.values[0],
				a = [],
				h = 0,
				l = !1;
			n.BitsPerSample.values.forEach(function(t, e, i) {
				a[e] = {
					bitsPerSample: t,
					hasBytesPerSample: !1,
					bytesPerSample: void 0
				};
				0 === t % 8 && (a[e].hasBytesPerSample = !0, a[e].bytesPerSample = t / 8);
				h += t
			}, this);
			if (0 === h % 8) var l = !0,
				u = h / 8;
			var d = n.StripOffsets.values,
				_ = d.length;
			if (n.StripByteCounts) var f = n.StripByteCounts.values;
			else if (cc.log("Missing StripByteCounts!"), 1 === _) f = [Math.ceil(i * r * h / 8)];
			else throw Error("Cannot recover from missing StripByteCounts");
			for (var p = 0; p < _; p++) {
				var g = d[p];
				c[p] = [];
				for (var m = f[p], T = 0, y = 0, v = 1, A = !0, x = [], E = 0, S = 0, C = 0; T < m; T += v) switch (s) {
				case 1:
					v = 0;
					for (x = []; v < o; v++) if (a[v].hasBytesPerSample) x.push(this.getBytes(a[v].bytesPerSample, g + T + a[v].bytesPerSample * v));
					else {
						var R = this.getBits(a[v].bitsPerSample, g + T, y);
						x.push(R.bits);
						T = R.byteOffset - g;
						y = R.bitOffset;
						throw RangeError("Cannot handle sub-byte bits per sample")
					}
					c[p].push(x);
					if (l) v = u;
					else throw v = 0, RangeError("Cannot handle sub-byte bits per pixel");
					break;
				case 32773:
					if (A) {
						var A = !1,
							b = 1,
							I = 1,
							v = this.getInt8(g + T);
						0 <= v && 127 >= v ? b = v + 1 : -127 <= v && -1 >= v ? I = -v + 1 : A = !0
					} else {
						for (var P = this.getUint8(g + T), v = 0; v < I; v++) {
							if (a[S].hasBytesPerSample) C = C << 8 * E | P, E++, E === a[S].bytesPerSample && (x.push(C), C = E = 0, S++);
							else throw RangeError("Cannot handle sub-byte bits per sample");
							S === o && (c[p].push(x), x = [], S = 0)
						}
						b--;
						0 === b && (A = !0)
					}
					v = 1
				}
			}
			if (e.getContext) {
				u = this.canvas.getContext("2d");
				u.fillStyle = "rgba(255, 255, 255, 0)";
				p = n.RowsPerStrip ? n.RowsPerStrip.values[0] : r;
				g = c.length;
				r %= p;
				r = 0 === r ? p : r;
				T = p;
				s = 0;
				x = n.PhotometricInterpretation.values[0];
				b = [];
				I = 0;
				n.ExtraSamples && (b = n.ExtraSamples.values, I = b.length);
				if (n.ColorMap) var R = n.ColorMap.values,
					w = Math.pow(2, a[0].bitsPerSample);
				for (p = 0; p < g; p++) {
					p + 1 === g && (T = r);
					n = c[p].length;
					s *= p;
					for (l = o = 0; o < T, l < n; o++) for (d = 0; d < i; d++, l++) {
						f = c[p][l];
						A = y = m = 0;
						_ = 1;
						if (0 < I) for (m = 0; m < I; m++) if (1 === b[m] || 2 === b[m]) {
							_ = f[3 + m] / 256;
							break
						}
						switch (x) {
						case 0:
							if (a[0].hasBytesPerSample) var F = Math.pow(16, 2 * a[0].bytesPerSample);
							f.forEach(function(t, e, i) {
								i[e] = F - t
							});
						case 1:
							m = y = A = this.clampColorSample(f[0], a[0].bitsPerSample);
							break;
						case 2:
							m = this.clampColorSample(f[0], a[0].bitsPerSample);
							y = this.clampColorSample(f[1], a[1].bitsPerSample);
							A = this.clampColorSample(f[2], a[2].bitsPerSample);
							break;
						case 3:
							if (void 0 === R) throw Error("Palette image missing color map");
							f = f[0];
							m = this.clampColorSample(R[f], 16);
							y = this.clampColorSample(R[w + f], 16);
							A = this.clampColorSample(R[2 * w + f], 16);
							break;
						default:
							throw RangeError("Unknown Photometric Interpretation:", x)
						}
						u.fillStyle = "rgba(" + m + ", " + y + ", " + A + ", " + _ + ")";
						u.fillRect(d, s + o, 1, 1)
					}
					s = T
				}
			}
			return this.canvas
		}
	},
	fieldTagNames: {
		315: "Artist",
		258: "BitsPerSample",
		265: "CellLength",
		264: "CellWidth",
		320: "ColorMap",
		259: "Compression",
		33432: "Copyright",
		306: "DateTime",
		338: "ExtraSamples",
		266: "FillOrder",
		289: "FreeByteCounts",
		288: "FreeOffsets",
		291: "GrayResponseCurve",
		290: "GrayResponseUnit",
		316: "HostComputer",
		270: "ImageDescription",
		257: "ImageLength",
		256: "ImageWidth",
		271: "Make",
		281: "MaxSampleValue",
		280: "MinSampleValue",
		272: "Model",
		254: "NewSubfileType",
		274: "Orientation",
		262: "PhotometricInterpretation",
		284: "PlanarConfiguration",
		296: "ResolutionUnit",
		278: "RowsPerStrip",
		277: "SamplesPerPixel",
		305: "Software",
		279: "StripByteCounts",
		273: "StripOffsets",
		255: "SubfileType",
		263: "Threshholding",
		282: "XResolution",
		283: "YResolution",
		326: "BadFaxLines",
		327: "CleanFaxData",
		343: "ClipPath",
		328: "ConsecutiveBadFaxLines",
		433: "Decode",
		434: "DefaultImageColor",
		269: "DocumentName",
		336: "DotRange",
		321: "HalftoneHints",
		346: "Indexed",
		347: "JPEGTables",
		285: "PageName",
		297: "PageNumber",
		317: "Predictor",
		319: "PrimaryChromaticities",
		532: "ReferenceBlackWhite",
		339: "SampleFormat",
		559: "StripRowCounts",
		330: "SubIFDs",
		292: "T4Options",
		293: "T6Options",
		325: "TileByteCounts",
		323: "TileLength",
		324: "TileOffsets",
		322: "TileWidth",
		301: "TransferFunction",
		318: "WhitePoint",
		344: "XClipPathUnits",
		286: "XPosition",
		529: "YCbCrCoefficients",
		531: "YCbCrPositioning",
		530: "YCbCrSubSampling",
		345: "YClipPathUnits",
		287: "YPosition",
		37378: "ApertureValue",
		40961: "ColorSpace",
		36868: "DateTimeDigitized",
		36867: "DateTimeOriginal",
		34665: "Exif IFD",
		36864: "ExifVersion",
		33434: "ExposureTime",
		41728: "FileSource",
		37385: "Flash",
		40960: "FlashpixVersion",
		33437: "FNumber",
		42016: "ImageUniqueID",
		37384: "LightSource",
		37500: "MakerNote",
		37377: "ShutterSpeedValue",
		37510: "UserComment",
		33723: "IPTC",
		34675: "ICC Profile",
		700: "XMP",
		42112: "GDAL_METADATA",
		42113: "GDAL_NODATA",
		34377: "Photoshop"
	},
	fieldTypeNames: {
		1: "BYTE",
		2: "ASCII",
		3: "SHORT",
		4: "LONG",
		5: "RATIONAL",
		6: "SBYTE",
		7: "UNDEFINED",
		8: "SSHORT",
		9: "SLONG",
		10: "SRATIONAL",
		11: "FLOAT",
		12: "DOUBLE"
	}
};
cc.Particle = function(t, e, i, n, r, c, s, o, a, h, l, u) {
	this.pos = t ? t : cc.p(0, 0);
	this.startPos = e ? e : cc.p(0, 0);
	this.color = i ? i : {
		r: 0,
		g: 0,
		b: 0,
		a: 255
	};
	this.deltaColor = n ? n : {
		r: 0,
		g: 0,
		b: 0,
		a: 255
	};
	this.size = r || 0;
	this.deltaSize = c || 0;
	this.rotation = s || 0;
	this.deltaRotation = o || 0;
	this.timeToLive = a || 0;
	this.atlasIndex = h || 0;
	this.modeA = l ? l : new cc.Particle.ModeA;
	this.modeB = u ? u : new cc.Particle.ModeB;
	this.isChangeColor = !1;
	this.drawPos = cc.p(0, 0)
};
cc.Particle.ModeA = function(t, e, i) {
	this.dir = t ? t : cc.p(0, 0);
	this.radialAccel = e || 0;
	this.tangentialAccel = i || 0
};
cc.Particle.ModeB = function(t, e, i, n) {
	this.angle = t || 0;
	this.degreesPerSecond = e || 0;
	this.radius = i || 0;
	this.deltaRadius = n || 0
};
cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()];
cc.ParticleSystem = cc.Node.extend({
	_className: "ParticleSystem",
	_plistFile: "",
	_elapsed: 0,
	_dontTint: !1,
	modeA: null,
	modeB: null,
	_pointZeroForParticle: cc.p(0, 0),
	_particles: null,
	_emitCounter: 0,
	_particleIdx: 0,
	_batchNode: null,
	atlasIndex: 0,
	_transformSystemDirty: !1,
	_allocatedParticles: 0,
	_isActive: !1,
	particleCount: 0,
	duration: 0,
	_sourcePosition: null,
	_posVar: null,
	life: 0,
	lifeVar: 0,
	angle: 0,
	angleVar: 0,
	startSize: 0,
	startSizeVar: 0,
	endSize: 0,
	endSizeVar: 0,
	_startColor: null,
	_startColorVar: null,
	_endColor: null,
	_endColorVar: null,
	startSpin: 0,
	startSpinVar: 0,
	endSpin: 0,
	endSpinVar: 0,
	emissionRate: 0,
	_totalParticles: 0,
	_texture: null,
	_blendFunc: null,
	_opacityModifyRGB: !1,
	positionType: null,
	autoRemoveOnFinish: !1,
	emitterMode: 0,
	_textureLoaded: null,
	ctor: function(t) {
		cc.Node.prototype.ctor.call(this);
		this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
		this.modeA = new cc.ParticleSystem.ModeA;
		this.modeB = new cc.ParticleSystem.ModeB;
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		this._particles = [];
		this._sourcePosition = cc.p(0, 0);
		this._posVar = cc.p(0, 0);
		this._startColor = cc.color(255, 255, 255, 255);
		this._startColorVar = cc.color(255, 255, 255, 255);
		this._endColor = cc.color(255, 255, 255, 255);
		this._endColorVar = cc.color(255, 255, 255, 255);
		this._plistFile = "";
		this._elapsed = 0;
		this._dontTint = !1;
		this._pointZeroForParticle = cc.p(0, 0);
		this._particleIdx = this._emitCounter = 0;
		this._batchNode = null;
		this.atlasIndex = 0;
		this._transformSystemDirty = !1;
		this._allocatedParticles = 0;
		this._isActive = !1;
		this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar = this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0;
		this._texture = null;
		this._opacityModifyRGB = !1;
		this.positionType = cc.ParticleSystem.TYPE_FREE;
		this.autoRemoveOnFinish = !1;
		this._textureLoaded = !0;
		!t || cc.isNumber(t) ? (t = t || 100, this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE), this.initWithTotalParticles(t)) : t && this.initWithFile(t)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParticleSystem.CanvasRenderCmd(this) : new cc.ParticleSystem.WebGLRenderCmd(this)
	},
	ignoreColor: function(t) {
		this._dontTint = t
	},
	initTexCoordsWithRect: function(t) {
		this._renderCmd.initTexCoordsWithRect(t)
	},
	getBatchNode: function() {
		return this._batchNode
	},
	setBatchNode: function(t) {
		this._renderCmd.setBatchNode(t)
	},
	getAtlasIndex: function() {
		return this.atlasIndex
	},
	setAtlasIndex: function(t) {
		this.atlasIndex = t
	},
	getDrawMode: function() {
		return this._renderCmd.getDrawMode()
	},
	setDrawMode: function(t) {
		this._renderCmd.setDrawMode(t)
	},
	getShapeType: function() {
		return this._renderCmd.getShapeType()
	},
	setShapeType: function(t) {
		this._renderCmd.setShapeType(t)
	},
	isActive: function() {
		return this._isActive
	},
	getParticleCount: function() {
		return this.particleCount
	},
	setParticleCount: function(t) {
		this.particleCount = t
	},
	getDuration: function() {
		return this.duration
	},
	setDuration: function(t) {
		this.duration = t
	},
	getSourcePosition: function() {
		return {
			x: this._sourcePosition.x,
			y: this._sourcePosition.y
		}
	},
	setSourcePosition: function(t) {
		this._sourcePosition = t
	},
	getPosVar: function() {
		return {
			x: this._posVar.x,
			y: this._posVar.y
		}
	},
	setPosVar: function(t) {
		this._posVar = t
	},
	getLife: function() {
		return this.life
	},
	setLife: function(t) {
		this.life = t
	},
	getLifeVar: function() {
		return this.lifeVar
	},
	setLifeVar: function(t) {
		this.lifeVar = t
	},
	getAngle: function() {
		return this.angle
	},
	setAngle: function(t) {
		this.angle = t
	},
	getAngleVar: function() {
		return this.angleVar
	},
	setAngleVar: function(t) {
		this.angleVar = t
	},
	getGravity: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
		var t = this.modeA.gravity;
		return cc.p(t.x, t.y)
	},
	setGravity: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity");
		this.modeA.gravity = t
	},
	getSpeed: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity");
		return this.modeA.speed
	},
	setSpeed: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity");
		this.modeA.speed = t
	},
	getSpeedVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity");
		return this.modeA.speedVar
	},
	setSpeedVar: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity");
		this.modeA.speedVar = t
	},
	getTangentialAccel: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity");
		return this.modeA.tangentialAccel
	},
	setTangentialAccel: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity");
		this.modeA.tangentialAccel = t
	},
	getTangentialAccelVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity");
		return this.modeA.tangentialAccelVar
	},
	setTangentialAccelVar: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity");
		this.modeA.tangentialAccelVar = t
	},
	getRadialAccel: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity");
		return this.modeA.radialAccel
	},
	setRadialAccel: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity");
		this.modeA.radialAccel = t
	},
	getRadialAccelVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity");
		return this.modeA.radialAccelVar
	},
	setRadialAccelVar: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity");
		this.modeA.radialAccelVar = t
	},
	getRotationIsDir: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity");
		return this.modeA.rotationIsDir
	},
	setRotationIsDir: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity");
		this.modeA.rotationIsDir = t
	},
	getStartRadius: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius");
		return this.modeB.startRadius
	},
	setStartRadius: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius");
		this.modeB.startRadius = t
	},
	getStartRadiusVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius");
		return this.modeB.startRadiusVar
	},
	setStartRadiusVar: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius");
		this.modeB.startRadiusVar = t
	},
	getEndRadius: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius");
		return this.modeB.endRadius
	},
	setEndRadius: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius");
		this.modeB.endRadius = t
	},
	getEndRadiusVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius");
		return this.modeB.endRadiusVar
	},
	setEndRadiusVar: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius");
		this.modeB.endRadiusVar = t
	},
	getRotatePerSecond: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius");
		return this.modeB.rotatePerSecond
	},
	setRotatePerSecond: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius");
		this.modeB.rotatePerSecond = t
	},
	getRotatePerSecondVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius");
		return this.modeB.rotatePerSecondVar
	},
	setRotatePerSecondVar: function(t) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius");
		this.modeB.rotatePerSecondVar = t
	},
	setScale: function(t, e) {
		this._transformSystemDirty = !0;
		cc.Node.prototype.setScale.call(this, t, e)
	},
	setRotation: function(t) {
		this._transformSystemDirty = !0;
		cc.Node.prototype.setRotation.call(this, t)
	},
	setScaleX: function(t) {
		this._transformSystemDirty = !0;
		cc.Node.prototype.setScaleX.call(this, t)
	},
	setScaleY: function(t) {
		this._transformSystemDirty = !0;
		cc.Node.prototype.setScaleY.call(this, t)
	},
	getStartSize: function() {
		return this.startSize
	},
	setStartSize: function(t) {
		this.startSize = t
	},
	getStartSizeVar: function() {
		return this.startSizeVar
	},
	setStartSizeVar: function(t) {
		this.startSizeVar = t
	},
	getEndSize: function() {
		return this.endSize
	},
	setEndSize: function(t) {
		this.endSize = t
	},
	getEndSizeVar: function() {
		return this.endSizeVar
	},
	setEndSizeVar: function(t) {
		this.endSizeVar = t
	},
	getStartColor: function() {
		return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
	},
	setStartColor: function(t) {
		this._startColor = cc.color(t)
	},
	getStartColorVar: function() {
		return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
	},
	setStartColorVar: function(t) {
		this._startColorVar = cc.color(t)
	},
	getEndColor: function() {
		return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a)
	},
	setEndColor: function(t) {
		this._endColor = cc.color(t)
	},
	getEndColorVar: function() {
		return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a)
	},
	setEndColorVar: function(t) {
		this._endColorVar = cc.color(t)
	},
	getStartSpin: function() {
		return this.startSpin
	},
	setStartSpin: function(t) {
		this.startSpin = t
	},
	getStartSpinVar: function() {
		return this.startSpinVar
	},
	setStartSpinVar: function(t) {
		this.startSpinVar = t
	},
	getEndSpin: function() {
		return this.endSpin
	},
	setEndSpin: function(t) {
		this.endSpin = t
	},
	getEndSpinVar: function() {
		return this.endSpinVar
	},
	setEndSpinVar: function(t) {
		this.endSpinVar = t
	},
	getEmissionRate: function() {
		return this.emissionRate
	},
	setEmissionRate: function(t) {
		this.emissionRate = t
	},
	getTotalParticles: function() {
		return this._totalParticles
	},
	setTotalParticles: function(t) {
		this._renderCmd.setTotalParticles(t)
	},
	getTexture: function() {
		return this._texture
	},
	setTexture: function(t) {
		t && (t.isLoaded() ? this.setTextureWithRect(t, cc.rect(0, 0, t.width, t.height)) : (this._textureLoaded = !1, t.addEventListener("load", function(t) {
			this._textureLoaded = !0;
			this.setTextureWithRect(t, cc.rect(0, 0, t.width, t.height))
		}, this)))
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(t, e) {
		if (void 0 === e) this._blendFunc != t && (this._blendFunc = t, this._updateBlendFunc());
		else if (this._blendFunc.src != t || this._blendFunc.dst != e) this._blendFunc = {
			src: t,
			dst: e
		}, this._updateBlendFunc()
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	setOpacityModifyRGB: function(t) {
		this._opacityModifyRGB = t
	},
	isBlendAdditive: function() {
		return this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE || this._blendFunc.src == cc.ONE && this._blendFunc.dst == cc.ONE
	},
	setBlendAdditive: function(t) {
		var e = this._blendFunc;
		t ? (e.src = cc.SRC_ALPHA, e.dst = cc.ONE) : this._renderCmd._setBlendAdditive()
	},
	getPositionType: function() {
		return this.positionType
	},
	setPositionType: function(t) {
		this.positionType = t
	},
	isAutoRemoveOnFinish: function() {
		return this.autoRemoveOnFinish
	},
	setAutoRemoveOnFinish: function(t) {
		this.autoRemoveOnFinish = t
	},
	getEmitterMode: function() {
		return this.emitterMode
	},
	setEmitterMode: function(t) {
		this.emitterMode = t
	},
	init: function() {
		return this.initWithTotalParticles(150)
	},
	initWithFile: function(t) {
		this._plistFile = t;
		t = cc.loader.getRes(t);
		return !t ? (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1) : this.initWithDictionary(t, "")
	},
	getBoundingBoxToWorld: function() {
		return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
	},
	initWithDictionary: function(t, e) {
		var i = !1,
			n = null,
			n = this._valueForKey,
			r = parseInt(n("maxParticles", t));
		if (this.initWithTotalParticles(r)) {
			this.angle = parseFloat(n("angle", t));
			this.angleVar = parseFloat(n("angleVariance", t));
			this.duration = parseFloat(n("duration", t));
			this._blendFunc.src = parseInt(n("blendFuncSource", t));
			this._blendFunc.dst = parseInt(n("blendFuncDestination", t));
			i = this._startColor;
			i.r = 255 * parseFloat(n("startColorRed", t));
			i.g = 255 * parseFloat(n("startColorGreen", t));
			i.b = 255 * parseFloat(n("startColorBlue", t));
			i.a = 255 * parseFloat(n("startColorAlpha", t));
			i = this._startColorVar;
			i.r = 255 * parseFloat(n("startColorVarianceRed", t));
			i.g = 255 * parseFloat(n("startColorVarianceGreen", t));
			i.b = 255 * parseFloat(n("startColorVarianceBlue", t));
			i.a = 255 * parseFloat(n("startColorVarianceAlpha", t));
			i = this._endColor;
			i.r = 255 * parseFloat(n("finishColorRed", t));
			i.g = 255 * parseFloat(n("finishColorGreen", t));
			i.b = 255 * parseFloat(n("finishColorBlue", t));
			i.a = 255 * parseFloat(n("finishColorAlpha", t));
			i = this._endColorVar;
			i.r = 255 * parseFloat(n("finishColorVarianceRed", t));
			i.g = 255 * parseFloat(n("finishColorVarianceGreen", t));
			i.b = 255 * parseFloat(n("finishColorVarianceBlue", t));
			i.a = 255 * parseFloat(n("finishColorVarianceAlpha", t));
			this.startSize = parseFloat(n("startParticleSize", t));
			this.startSizeVar = parseFloat(n("startParticleSizeVariance", t));
			this.endSize = parseFloat(n("finishParticleSize", t));
			this.endSizeVar = parseFloat(n("finishParticleSizeVariance", t));
			this.setPosition(parseFloat(n("sourcePositionx", t)), parseFloat(n("sourcePositiony", t)));
			this._posVar.x = parseFloat(n("sourcePositionVariancex", t));
			this._posVar.y = parseFloat(n("sourcePositionVariancey", t));
			this.startSpin = parseFloat(n("rotationStart", t));
			this.startSpinVar = parseFloat(n("rotationStartVariance", t));
			this.endSpin = parseFloat(n("rotationEnd", t));
			this.endSpinVar = parseFloat(n("rotationEndVariance", t));
			this.emitterMode = parseInt(n("emitterType", t));
			if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) i = this.modeA, i.gravity.x = parseFloat(n("gravityx", t)), i.gravity.y = parseFloat(n("gravityy", t)), i.speed = parseFloat(n("speed", t)), i.speedVar = parseFloat(n("speedVariance", t)), r = n("radialAcceleration", t), i.radialAccel = r ? parseFloat(r) : 0, r = n("radialAccelVariance", t), i.radialAccelVar = r ? parseFloat(r) : 0, r = n("tangentialAcceleration", t), i.tangentialAccel = r ? parseFloat(r) : 0, r = n("tangentialAccelVariance", t), i.tangentialAccelVar = r ? parseFloat(r) : 0, r = n("rotationIsDir", t).toLowerCase(), i.rotationIsDir = null != r && ("true" === r || "1" === r);
			else if (this.emitterMode == cc.ParticleSystem.MODE_RADIUS) i = this.modeB, i.startRadius = parseFloat(n("maxRadius", t)), i.startRadiusVar = parseFloat(n("maxRadiusVariance", t)), i.endRadius = parseFloat(n("minRadius", t)), i.endRadiusVar = 0, i.rotatePerSecond = parseFloat(n("rotatePerSecond", t)), i.rotatePerSecondVar = parseFloat(n("rotatePerSecondVariance", t));
			else return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
			this.life = parseFloat(n("particleLifespan", t));
			this.lifeVar = parseFloat(n("particleLifespanVariance", t));
			this.emissionRate = this._totalParticles / this.life;
			if (!this._batchNode) if (this._opacityModifyRGB = !1, i = n("textureFileName", t), i = cc.path.changeBasename(this._plistFile, i), r = cc.textureCache.getTextureForKey(i)) this.setTexture(r);
			else if (n = n("textureImageData", t), !n || 0 === n.length) {
				r = cc.textureCache.addImage(i);
				if (!r) return !1;
				this.setTexture(r)
			} else {
				n = cc.unzipBase64AsArray(n, 1);
				if (!n) return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
				r = cc.getImageFormatByData(n);
				if (r !== cc.FMT_TIFF && r !== cc.FMT_PNG) return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
				var c = cc.newElement("canvas");
				r === cc.FMT_PNG ? new cc.PNGReader(n).render(c) : cc.tiffReader.parseTIFF(n, c);
				cc.textureCache.cacheImage(i, c);
				(n = cc.textureCache.getTextureForKey(i)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture");
				this.setTexture(n)
			}
			i = !0
		}
		return i
	},
	initWithTotalParticles: function(t) {
		this._totalParticles = t;
		var e, i = this._particles;
		for (e = i.length = 0; e < t; e++) i[e] = new cc.Particle;
		if (!i) return cc.log("Particle system: not enough memory"), !1;
		this._allocatedParticles = t;
		if (this._batchNode) for (e = 0; e < this._totalParticles; e++) i[e].atlasIndex = e;
		this._isActive = !0;
		this._blendFunc.src = cc.BLEND_SRC;
		this._blendFunc.dst = cc.BLEND_DST;
		this.positionType = cc.ParticleSystem.TYPE_FREE;
		this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
		this._transformSystemDirty = this.autoRemoveOnFinish = !1;
		this.scheduleUpdateWithPriority(1);
		this._renderCmd._initWithTotalParticles(t);
		return !0
	},
	destroyParticleSystem: function() {
		this.unscheduleUpdate()
	},
	addParticle: function() {
		if (this.isFull()) return !1;
		var t = this._renderCmd.addParticle();
		this.initParticle(t);
		++this.particleCount;
		return !0
	},
	initParticle: function(t) {
		var e = cc.randomMinus1To1;
		t.timeToLive = this.life + this.lifeVar * e();
		t.timeToLive = Math.max(0, t.timeToLive);
		t.pos.x = this._sourcePosition.x + this._posVar.x * e();
		t.pos.y = this._sourcePosition.y + this._posVar.y * e();
		var i, n;
		i = this._startColor;
		var r = this._startColorVar,
			c = this._endColor;
		n = this._endColorVar;
		i = {
			r: cc.clampf(i.r + r.r * e(), 0, 255),
			g: cc.clampf(i.g + r.g * e(), 0, 255),
			b: cc.clampf(i.b + r.b * e(), 0, 255),
			a: cc.clampf(i.a + r.a * e(), 0, 255)
		};
		n = {
			r: cc.clampf(c.r + n.r * e(), 0, 255),
			g: cc.clampf(c.g + n.g * e(), 0, 255),
			b: cc.clampf(c.b + n.b * e(), 0, 255),
			a: cc.clampf(c.a + n.a * e(), 0, 255)
		};
		t.color = i;
		r = t.deltaColor;
		c = t.timeToLive;
		r.r = (n.r - i.r) / c;
		r.g = (n.g - i.g) / c;
		r.b = (n.b - i.b) / c;
		r.a = (n.a - i.a) / c;
		i = this.startSize + this.startSizeVar * e();
		i = Math.max(0, i);
		t.size = i;
		this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE ? t.deltaSize = 0 : (n = this.endSize + this.endSizeVar * e(), n = Math.max(0, n), t.deltaSize = (n - i) / c);
		i = this.startSpin + this.startSpinVar * e();
		n = this.endSpin + this.endSpinVar * e();
		t.rotation = i;
		t.deltaRotation = (n - i) / c;
		this.positionType == cc.ParticleSystem.TYPE_FREE ? t.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType == cc.ParticleSystem.TYPE_RELATIVE && (t.startPos.x = this._position.x, t.startPos.y = this._position.y);
		i = cc.degreesToRadians(this.angle + this.angleVar * e());
		if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) c = this.modeA, n = t.modeA, r = c.speed + c.speedVar * e(), n.dir.x = Math.cos(i), n.dir.y = Math.sin(i), cc.pMultIn(n.dir, r), n.radialAccel = c.radialAccel + c.radialAccelVar * e(), n.tangentialAccel = c.tangentialAccel + c.tangentialAccelVar * e(), c.rotationIsDir && (t.rotation = -cc.radiansToDegrees(cc.pToAngle(n.dir)));
		else {
			n = this.modeB;
			t = t.modeB;
			var r = n.startRadius + n.startRadiusVar * e(),
				s = n.endRadius + n.endRadiusVar * e();
			t.radius = r;
			t.deltaRadius = n.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (s - r) / c;
			t.angle = i;
			t.degreesPerSecond = cc.degreesToRadians(n.rotatePerSecond + n.rotatePerSecondVar * e())
		}
	},
	stopSystem: function() {
		this._isActive = !1;
		this._elapsed = this.duration;
		this._emitCounter = 0
	},
	resetSystem: function() {
		this._isActive = !0;
		this._elapsed = 0;
		var t = this._particles;
		for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) t[this._particleIdx].timeToLive = 0
	},
	isFull: function() {
		return this.particleCount >= this._totalParticles
	},
	updateQuadWithParticle: function(t, e) {
		this._renderCmd.updateQuadWithParticle(t, e)
	},
	postStep: function() {
		this._renderCmd.postStep()
	},
	update: function(t) {
		if (this._isActive && this.emissionRate) {
			var e = 1 / this.emissionRate;
			this.particleCount < this._totalParticles && (this._emitCounter += t);
			for (; this.particleCount < this._totalParticles && this._emitCounter > e;) this.addParticle(), this._emitCounter -= e;
			this._elapsed += t; - 1 != this.duration && this.duration < this._elapsed && this.stopSystem()
		}
		this._particleIdx = 0;
		e = cc.Particle.TemporaryPoints[0];
		this.positionType == cc.ParticleSystem.TYPE_FREE ? cc.pIn(e, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType == cc.ParticleSystem.TYPE_RELATIVE && (e.x = this._position.x, e.y = this._position.y);
		if (this._visible) {
			for (var i = cc.Particle.TemporaryPoints[1], n = cc.Particle.TemporaryPoints[2], r = cc.Particle.TemporaryPoints[3], c = this._particles; this._particleIdx < this.particleCount;) {
				cc.pZeroIn(i);
				cc.pZeroIn(n);
				cc.pZeroIn(r);
				var s = c[this._particleIdx];
				s.timeToLive -= t;
				if (0 < s.timeToLive) {
					if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) {
						var o = r,
							a = i,
							h = n;
						s.pos.x || s.pos.y ? (cc.pIn(a, s.pos), cc.pNormalizeIn(a)) : cc.pZeroIn(a);
						cc.pIn(h, a);
						cc.pMultIn(a, s.modeA.radialAccel);
						var l = h.x;
						h.x = -h.y;
						h.y = l;
						cc.pMultIn(h, s.modeA.tangentialAccel);
						cc.pIn(o, a);
						cc.pAddIn(o, h);
						cc.pAddIn(o, this.modeA.gravity);
						cc.pMultIn(o, t);
						cc.pAddIn(s.modeA.dir, o);
						cc.pIn(o, s.modeA.dir);
						cc.pMultIn(o, t);
						cc.pAddIn(s.pos, o)
					} else o = s.modeB, o.angle += o.degreesPerSecond * t, o.radius += o.deltaRadius * t, s.pos.x = -Math.cos(o.angle) * o.radius, s.pos.y = -Math.sin(o.angle) * o.radius;
					this._renderCmd._updateDeltaColor(s, t);
					s.size += s.deltaSize * t;
					s.size = Math.max(0, s.size);
					s.rotation += s.deltaRotation * t;
					o = i;
					this.positionType == cc.ParticleSystem.TYPE_FREE || this.positionType == cc.ParticleSystem.TYPE_RELATIVE ? (a = n, cc.pIn(a, e), cc.pSubIn(a, s.startPos), cc.pIn(o, s.pos), cc.pSubIn(o, a)) : cc.pIn(o, s.pos);
					this._batchNode && (o.x += this._position.x, o.y += this._position.y);
					this._renderCmd.updateParticlePosition(s, o);
					++this._particleIdx
				} else if (s = s.atlasIndex, this._particleIdx !== this.particleCount - 1 && (o = c[this._particleIdx], c[this._particleIdx] = c[this.particleCount - 1], c[this.particleCount - 1] = o), this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + s), c[this.particleCount - 1].atlasIndex = s), --this.particleCount, 0 == this.particleCount && this.autoRemoveOnFinish) {
					this.unscheduleUpdate();
					this._parent.removeChild(this, !0);
					return
				}
			}
			this._transformSystemDirty = !1
		}
		this._batchNode || this.postStep()
	},
	updateWithNoTime: function() {
		this.update(0)
	},
	_valueForKey: function(t, e) {
		if (e) {
			var i = e[t];
			return null != i ? i : ""
		}
		return ""
	},
	_updateBlendFunc: function() {
		if (this._batchNode) cc.log("Can't change blending functions when the particle is being batched");
		else {
			var t = this._texture;
			if (t && t instanceof cc.Texture2D) {
				this._opacityModifyRGB = !1;
				var e = this._blendFunc;
				e.src == cc.BLEND_SRC && e.dst == cc.BLEND_DST && (t.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (e.src = cc.SRC_ALPHA, e.dst = cc.ONE_MINUS_SRC_ALPHA))
			}
		}
	},
	clone: function() {
		var t = new cc.ParticleSystem;
		if (t.initWithTotalParticles(this.getTotalParticles())) {
			t.setAngle(this.getAngle());
			t.setAngleVar(this.getAngleVar());
			t.setDuration(this.getDuration());
			var e = this.getBlendFunc();
			t.setBlendFunc(e.src, e.dst);
			t.setStartColor(this.getStartColor());
			t.setStartColorVar(this.getStartColorVar());
			t.setEndColor(this.getEndColor());
			t.setEndColorVar(this.getEndColorVar());
			t.setStartSize(this.getStartSize());
			t.setStartSizeVar(this.getStartSizeVar());
			t.setEndSize(this.getEndSize());
			t.setEndSizeVar(this.getEndSizeVar());
			t.setPosition(cc.p(this.x, this.y));
			t.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y));
			t.setStartSpin(this.getStartSpin() || 0);
			t.setStartSpinVar(this.getStartSpinVar() || 0);
			t.setEndSpin(this.getEndSpin() || 0);
			t.setEndSpinVar(this.getEndSpinVar() || 0);
			t.setEmitterMode(this.getEmitterMode());
			this.getEmitterMode() == cc.ParticleSystem.MODE_GRAVITY ? (e = this.getGravity(), t.setGravity(cc.p(e.x, e.y)), t.setSpeed(this.getSpeed()), t.setSpeedVar(this.getSpeedVar()), t.setRadialAccel(this.getRadialAccel()), t.setRadialAccelVar(this.getRadialAccelVar()), t.setTangentialAccel(this.getTangentialAccel()), t.setTangentialAccelVar(this.getTangentialAccelVar())) : this.getEmitterMode() == cc.ParticleSystem.MODE_RADIUS && (t.setStartRadius(this.getStartRadius()), t.setStartRadiusVar(this.getStartRadiusVar()), t.setEndRadius(this.getEndRadius()), t.setEndRadiusVar(this.getEndRadiusVar()), t.setRotatePerSecond(this.getRotatePerSecond()), t.setRotatePerSecondVar(this.getRotatePerSecondVar()));
			t.setLife(this.getLife());
			t.setLifeVar(this.getLifeVar());
			t.setEmissionRate(this.getEmissionRate());
			if (!this.getBatchNode() && (t.setOpacityModifyRGB(this.isOpacityModifyRGB()), e = this.getTexture())) {
				var i = e.getContentSize();
				t.setTextureWithRect(e, cc.rect(0, 0, i.width, i.height))
			}
		}
		return t
	},
	setDisplayFrame: function(t) {
		if (t) {
			var e = t.getOffsetInPixels();
			(0 != e.x || 0 != e.y) && cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
			t = t.getTexture();
			this._texture != t && this.setTexture(t)
		}
	},
	setTextureWithRect: function(t, e) {
		this._texture != t && (this._texture = t, this._updateBlendFunc());
		this.initTexCoordsWithRect(e)
	},
	listenBackToForeground: function(t) {}
});
_p = cc.ParticleSystem.prototype;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, "drawMode", _p.getDrawMode, _p.setDrawMode);
cc.defineGetterSetter(_p, "shapeType", _p.getShapeType, _p.setShapeType);
cc.defineGetterSetter(_p, "active", _p.isActive);
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleSystem.create = function(t) {
	return new cc.ParticleSystem(t)
};
cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create;
cc.ParticleSystem.ModeA = function(t, e, i, n, r, c, s, o) {
	this.gravity = t ? t : cc.p(0, 0);
	this.speed = e || 0;
	this.speedVar = i || 0;
	this.tangentialAccel = n || 0;
	this.tangentialAccelVar = r || 0;
	this.radialAccel = c || 0;
	this.radialAccelVar = s || 0;
	this.rotationIsDir = o || !1
};
cc.ParticleSystem.ModeB = function(t, e, i, n, r, c) {
	this.startRadius = t || 0;
	this.startRadiusVar = e || 0;
	this.endRadius = i || 0;
	this.endRadiusVar = n || 0;
	this.rotatePerSecond = r || 0;
	this.rotatePerSecondVar = c || 0
};
cc.ParticleSystem.SHAPE_MODE = 0;
cc.ParticleSystem.TEXTURE_MODE = 1;
cc.ParticleSystem.STAR_SHAPE = 0;
cc.ParticleSystem.BALL_SHAPE = 1;
cc.ParticleSystem.DURATION_INFINITY = -1;
cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.ParticleSystem.MODE_GRAVITY = 0;
cc.ParticleSystem.MODE_RADIUS = 1;
cc.ParticleSystem.TYPE_FREE = 0;
cc.ParticleSystem.TYPE_RELATIVE = 1;
cc.ParticleSystem.TYPE_GROUPED = 2;
(function() {
	cc.ParticleSystem.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._needDraw = !0;
		this._drawMode = cc.ParticleSystem.SHAPE_MODE;
		this._shapeType = cc.ParticleSystem.BALL_SHAPE;
		this._pointRect = cc.rect(0, 0, 0, 0)
	};
	var t = cc.ParticleSystem.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.ParticleSystem.CanvasRenderCmd;
	t.getDrawMode = function() {
		return this._drawMode
	};
	t.setDrawMode = function(t) {
		this._drawMode = t
	};
	t.getShapeType = function() {
		return this._shapeType
	};
	t.setShapeType = function(t) {
		this._shapeType = t
	};
	t.setBatchNode = function(t) {
		this._batchNode != t && (this._node._batchNode = t)
	};
	t.updateQuadWithParticle = function(t, e) {};
	t.updateParticlePosition = function(t, e) {
		cc.pIn(t.drawPos, e)
	};
	t.rendering = function(t, e, i) {
		t = t || cc._renderContext;
		var n = this._node,
			r = this._worldTransform,
			c = this._pointRect;
		t.save();
		var s = n._parent;
		this.transform(s ? s._renderCmd : null);
		t.transform(r.a, r.c, r.b, r.d, r.tx * e, -r.ty * i);
		n.isBlendAdditive() ? t.globalCompositeOperation = "lighter" : t.globalCompositeOperation = "source-over";
		var o;
		i = this._node.particleCount;
		r = this._node._particles;
		if (n.drawMode == cc.ParticleSystem.TEXTURE_MODE) {
			if (!n._texture || !n._texture._isLoaded) {
				t.restore();
				return
			}
			n = n._texture.getHtmlElementObj();
			if (!n.width || !n.height) {
				t.restore();
				return
			}
			s = n;
			for (e = 0; e < i; e++) if (s = r[e], o = s.color.a / 255, 0 !== o) {
				t.globalAlpha = o;
				t.save();
				t.translate(0 | s.drawPos.x, -(0 | s.drawPos.y));
				var a = 4 * Math.floor(s.size / 4);
				o = c.width;
				var h = c.height;
				t.scale(Math.max(1 / o * a, 1e-6), Math.max(1 / h * a, 1e-6));
				s.rotation && t.rotate(cc.degreesToRadians(s.rotation));
				s = s.isChangeColor ? this._changeTextureColor(n, s.color, this._pointRect) : n;
				t.drawImage(s, -(0 | o / 2), -(0 | h / 2));
				t.restore()
			}
		} else {
			h = cc._drawingUtil;
			for (e = 0; e < i; e++) s = r[e], c = 0 | .5 * s.size, o = s.color.a / 255, 0 !== o && (t.globalAlpha = o, t.save(), t.translate(0 | s.drawPos.x, -(0 | s.drawPos.y)), n.shapeType == cc.ParticleSystem.STAR_SHAPE ? (s.rotation && t.rotate(cc.degreesToRadians(s.rotation)), h.drawStar(t, c, s.color)) : h.drawColorBall(t, c, s.color), t.restore())
		}
		t.restore();
		cc.g_NumberOfDraws++
	};
	t._changeTextureColor = cc.sys._supportCanvasNewBlendModes ?
	function(t, e, i) {
		t.tintCache || (t.tintCache = document.createElement("canvas"), t.tintCache.width = t.width, t.tintCache.height = t.height);
		return cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(t, e, i, t.tintCache)
	} : function(t, e, i) {
		var n = cc.textureCache.getTextureColors(t);
		return n ? (n.tintCache || (n.tintCache = document.createElement("canvas"), n.tintCache.width = t.width, n.tintCache.height = t.height), cc.Sprite.CanvasRenderCmd._generateTintImage(t, n, e, i, n.tintCache), n.tintCache) : null
	};
	t.initTexCoordsWithRect = function(t) {
		this._pointRect = t
	};
	t.setTotalParticles = function(t) {
		this._node._totalParticles = 200 > t ? t : 200
	};
	t.addParticle = function() {
		var t = this._node,
			e = t._particles;
		t.particleCount < e.length ? t = e[t.particleCount] : (t = new cc.Particle, e.push(t));
		return t
	};
	t._setupVBO = function() {};
	t._allocMemory = function() {
		return !0
	};
	t.postStep = function() {};
	t._setBlendAdditive = function() {
		var t = this._node._blendFunc;
		t.src = cc.BLEND_SRC;
		t.dst = cc.BLEND_DST
	};
	t._initWithTotalParticles = function(t) {};
	t._updateDeltaColor = function(t, e) {
		this._dontTint || (t.color.r += t.deltaColor.r * e, t.color.g += t.deltaColor.g * e, t.color.b += t.deltaColor.b * e, t.color.a += t.deltaColor.a * e, t.isChangeColor = !0)
	}
})();
(function() {
	cc.ParticleSystem.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !0;
		this._buffersVBO = [0, 0];
		this._quads = [];
		this._indices = [];
		this._quadsArrayBuffer = null
	};
	var t = cc.ParticleSystem.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	t.constructor = cc.ParticleSystem.CanvasRenderCmd;
	t.getDrawMode = function() {};
	t.setDrawMode = function(t) {};
	t.getShapeType = function() {};
	t.setShapeType = function(t) {};
	t.setBatchNode = function(t) {
		var e = this._node;
		if (e._batchNode != t) {
			var i = e._batchNode;
			if (e._batchNode = t) for (var n = e._particles, r = 0; r < e._totalParticles; r++) n[r].atlasIndex = r;
			t ? i || (e._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, e.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(e._totalParticles), e.setTexture(i.getTexture()), this._setupVBO())
		}
	};
	t.initIndices = function(t) {
		for (var e = this._indices, i = 0; i < t; ++i) {
			var n = 6 * i,
				r = 4 * i;
			e[n + 0] = r + 0;
			e[n + 1] = r + 1;
			e[n + 2] = r + 2;
			e[n + 5] = r + 1;
			e[n + 4] = r + 2;
			e[n + 3] = r + 3
		}
	};
	t.isDifferentTexture = function(t, e) {
		if (t == e) return !0
	};
	t.updateParticlePosition = function(t, e) {
		this.updateQuadWithParticle(t, e)
	};
	t.updateQuadWithParticle = function(t, e) {
		var i = null,
			n = this._node;
		n._batchNode ? (i = n._batchNode.textureAtlas.quads[n.atlasIndex + t.atlasIndex], n._batchNode.textureAtlas.dirty = !0) : i = this._quads[n._particleIdx];
		var r, c, s;
		n._opacityModifyRGB ? (n = 0 | t.color.r * t.color.a / 255, r = 0 | t.color.g * t.color.a / 255, c = 0 | t.color.b * t.color.a / 255) : (n = 0 | t.color.r, r = 0 | t.color.g, c = 0 | t.color.b);
		s = 0 | t.color.a;
		var o = i.bl.colors,
			a = i.br.colors,
			h = i.tl.colors,
			l = i.tr.colors;
		o.r = a.r = h.r = l.r = n;
		o.g = a.g = h.g = l.g = r;
		o.b = a.b = h.b = l.b = c;
		o.a = a.a = h.a = l.a = s;
		n = t.size / 2;
		t.rotation ? (r = -n, c = -n, s = e.x, o = e.y, h = -cc.degreesToRadians(t.rotation), a = Math.cos(h), h = Math.sin(h), i.bl.vertices.x = r * a - c * h + s, i.bl.vertices.y = r * h + c * a + o, i.br.vertices.x = n * a - c * h + s, i.br.vertices.y = n * h + c * a + o, i.tl.vertices.x = r * a - n * h + s, i.tl.vertices.y = r * h + n * a + o, i.tr.vertices.x = n * a - n * h + s, i.tr.vertices.y = n * h + n * a + o) : (i.bl.vertices.x = e.x - n, i.bl.vertices.y = e.y - n, i.br.vertices.x = e.x + n, i.br.vertices.y = e.y - n, i.tl.vertices.x = e.x - n, i.tl.vertices.y = e.y + n, i.tr.vertices.x = e.x + n, i.tr.vertices.y = e.y + n)
	};
	t.rendering = function(t) {
		var e = this._node;
		e._texture && (t = t || cc._renderContext, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBindTexture2D(e._texture), cc.glBlendFuncForParticle(e._blendFunc.src, e._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), t.bindBuffer(t.ARRAY_BUFFER, this._buffersVBO[0]), t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, t.FLOAT, !1, 24, 0), t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 24, 12), t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, 24, 16), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), t.drawElements(t.TRIANGLES, 6 * e._particleIdx, t.UNSIGNED_SHORT, 0))
	};
	t.initTexCoordsWithRect = function(t) {
		var e = this._node,
			i = e.texture,
			n = cc.contentScaleFactor(),
			r = cc.rect(t.x * n, t.y * n, t.width * n, t.height * n),
			n = t.width,
			c = t.height;
		i && (n = i.pixelsWidth, c = i.pixelsHeight);
		cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (i = (2 * r.x + 1) / (2 * n), t = (2 * r.y + 1) / (2 * c), n = i + (2 * r.width - 2) / (2 * n), r = t + (2 * r.height - 2) / (2 * c)) : (i = r.x / n, t = r.y / c, n = i + r.width / n, r = t + r.height / c);
		c = r;
		r = t;
		t = c;
		var s = 0,
			o = 0;
		e._batchNode ? (c = e._batchNode.textureAtlas.quads, s = e.atlasIndex, o = e.atlasIndex + e._totalParticles) : (c = this._quads, s = 0, o = e._totalParticles);
		for (e = s; e < o; e++) c[e] || (c[e] = cc.V3F_C4B_T2F_QuadZero()), s = c[e], s.bl.texCoords.u = i, s.bl.texCoords.v = t, s.br.texCoords.u = n, s.br.texCoords.v = t, s.tl.texCoords.u = i, s.tl.texCoords.v = r, s.tr.texCoords.u = n, s.tr.texCoords.v = r
	};
	t.setTotalParticles = function(t) {
		var e = this._node;
		if (t > e._allocatedParticles) {
			var i = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
			this._indices = new Uint16Array(6 * t);
			var n = new ArrayBuffer(t * i),
				r = e._particles;
			r.length = 0;
			for (var c = this._quads, s = c.length = 0; s < t; s++) r[s] = new cc.Particle, c[s] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, n, s * i);
			e._allocatedParticles = t;
			e._totalParticles = t;
			if (e._batchNode) for (i = 0; i < t; i++) r[i].atlasIndex = i;
			this._quadsArrayBuffer = n;
			this.initIndices(t);
			this._setupVBO();
			e._texture && this.initTexCoordsWithRect(cc.rect(0, 0, e._texture.width, e._texture.height))
		} else e._totalParticles = t;
		e.resetSystem()
	};
	t.addParticle = function() {
		var t = this._node;
		return t._particles[t.particleCount]
	};
	t._setupVBO = function() {
		var t = cc._renderContext;
		this._buffersVBO[0] = t.createBuffer();
		t.bindBuffer(t.ARRAY_BUFFER, this._buffersVBO[0]);
		t.bufferData(t.ARRAY_BUFFER, this._quadsArrayBuffer, t.DYNAMIC_DRAW);
		this._buffersVBO[1] = t.createBuffer();
		t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
		t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW)
	};
	t._allocMemory = function() {
		var t = this._node;
		if (t._batchNode) return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
		var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
			t = t._totalParticles,
			i = this._quads;
		i.length = 0;
		this._indices = new Uint16Array(6 * t);
		for (var n = new ArrayBuffer(e * t), r = 0; r < t; r++) i[r] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, n, r * e);
		if (!i || !this._indices) return cc.log("cocos2d: Particle system: not enough memory"), !1;
		this._quadsArrayBuffer = n;
		return !0
	};
	t.postStep = function() {
		var t = cc._renderContext;
		t.bindBuffer(t.ARRAY_BUFFER, this._buffersVBO[0]);
		t.bufferData(t.ARRAY_BUFFER, this._quadsArrayBuffer, t.DYNAMIC_DRAW)
	};
	t._setBlendAdditive = function() {
		var t = this._node._blendFunc;
		this._texture && !this._texture.hasPremultipliedAlpha() ? (t.src = cc.SRC_ALPHA, t.dst = cc.ONE_MINUS_SRC_ALPHA) : (t.src = cc.BLEND_SRC, t.dst = cc.BLEND_DST)
	};
	t._initWithTotalParticles = function(t) {
		if (!this._allocMemory()) return !1;
		this.initIndices(t);
		this._setupVBO();
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	t._updateDeltaColor = function(t, e) {
		t.color.r += t.deltaColor.r * e;
		t.color.g += t.deltaColor.g * e;
		t.color.b += t.deltaColor.b * e;
		t.color.a += t.deltaColor.a * e;
		t.isChangeColor = !0
	}
})();
cc.ParticleFire = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 300 : 150)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10), t = cc.director.getWinSize(), this.setPosition(t.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
	}
});
cc.ParticleFire.create = function() {
	return new cc.ParticleFire
};
cc.ParticleFireworks = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1500 : 150)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50), t = cc.director.getWinSize(), this.setPosition(t.width / 2, t.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleFireworks.create = function() {
	return new cc.ParticleFireworks
};
cc.ParticleSun = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 350 : 150)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setBlendAdditive(!0), this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5), this.setAngle(90), this.setAngleVar(360), t = cc.director.getWinSize(), this.setPosition(t.width / 2, t.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0) : !1
	}
});
cc.ParticleSun.create = function() {
	return new cc.ParticleSun
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), t = cc.director.getWinSize(), this.setPosition(t.width / 2, t.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
	}
});
cc.ParticleGalaxy.create = function() {
	return new cc.ParticleGalaxy
};
cc.ParticleFlower = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 250 : 100)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), t = cc.director.getWinSize(), this.setPosition(t.width / 2, t.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
	}
});
cc.ParticleFlower.create = function() {
	return new cc.ParticleFlower
};
cc.ParticleMeteor = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 150 : 100)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), t = cc.director.getWinSize(), this.setPosition(t.width / 2, t.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
	}
});
cc.ParticleMeteor.create = function() {
	return new cc.ParticleMeteor
};
cc.ParticleSpiral = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 500 : 100)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0), t = cc.director.getWinSize(), this.setPosition(t.width / 2, t.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleSpiral.create = function() {
	return new cc.ParticleSpiral
};
cc.ParticleExplosion = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 300)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(.1), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), t = cc.director.getWinSize(), this.setPosition(t.width / 2, t.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleExplosion.create = function() {
	return new cc.ParticleExplosion
};
cc.ParticleSmoke = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90), this.setAngleVar(5), t = cc.director.getWinSize(), this.setPosition(t.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleSmoke.create = function() {
	return new cc.ParticleSmoke
};
cc.ParticleSnow = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 250)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), t = cc.director.getWinSize(), this.setPosition(t.width / 2, t.height + 10), this.setPosVar(cc.p(t.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleSnow.create = function() {
	return new cc.ParticleSnow
};
cc.ParticleRain = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1e3 : 300)
	},
	initWithTotalParticles: function(t) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), this.setSpeed(130), this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5), t = cc.director.getWinSize(), this.setPosition(t.width / 2, t.height), this.setPosVar(cc.p(t.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleRain.create = function() {
	return new cc.ParticleRain
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({
	textureAtlas: null,
	_blendFunc: null,
	_className: "ParticleBatchNode",
	ctor: function(t, e) {
		cc.Node.prototype.ctor.call(this);
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		cc.isString(t) ? this.init(t, e) : t instanceof cc.Texture2D && this.initWithTexture(t, e)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParticleBatchNode.CanvasRenderCmd(this) : new cc.ParticleBatchNode.WebGLRenderCmd(this)
	},
	initWithTexture: function(t, e) {
		this.textureAtlas = new cc.TextureAtlas;
		this.textureAtlas.initWithTexture(t, e);
		this._children.length = 0;
		this._renderCmd._initWithTexture();
		return !0
	},
	initWithFile: function(t, e) {
		var i = cc.textureCache.addImage(t);
		return this.initWithTexture(i, e)
	},
	init: function(t, e) {
		var i = cc.textureCache.addImage(t);
		return this.initWithTexture(i, e)
	},
	addChild: function(t, e, i) {
		if (!t) throw "cc.ParticleBatchNode.addChild() : child should be non-null";
		if (!(t instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children";
		e = null == e ? t.zIndex : e;
		i = null == i ? t.tag : i;
		if (t.getTexture() != this.textureAtlas.texture) throw "cc.ParticleSystem.addChild() : the child is not using the same texture id";
		var n = t.getBlendFunc();
		if (0 === this._children.length) this.setBlendFunc(n);
		else if (n.src != this._blendFunc.src || n.dst != this._blendFunc.dst) {
			cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
			return
		}
		e = this._addChildHelper(t, e, i);
		i = 0;
		0 != e ? (e = this._children[e - 1], i = e.getAtlasIndex() + e.getTotalParticles()) : i = 0;
		this.insertChild(t, i);
		t.setBatchNode(this)
	},
	insertChild: function(t, e) {
		var i = t.getTotalParticles(),
			n = this.textureAtlas,
			r = n.totalQuads;
		t.setAtlasIndex(e);
		r + i > n.getCapacity() && (this._increaseAtlasCapacityTo(r + i), n.fillWithEmptyQuadsFromIndex(n.getCapacity() - i, i));
		t.getAtlasIndex() + i != r && n.moveQuadsFromIndex(e, e + i);
		n.increaseTotalQuadsWith(i);
		this._updateAllAtlasIndexes()
	},
	removeChild: function(t, e) {
		if (null != t) {
			if (!(t instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children";
			if (-1 == this._children.indexOf(t)) cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
			else {
				cc.Node.prototype.removeChild.call(this, t, e);
				var i = this.textureAtlas;
				i.removeQuadsAtIndex(t.getAtlasIndex(), t.getTotalParticles());
				i.fillWithEmptyQuadsFromIndex(i.totalQuads, t.getTotalParticles());
				t.setBatchNode(null);
				this._updateAllAtlasIndexes()
			}
		}
	},
	reorderChild: function(t, e) {
		if (!t) throw "cc.ParticleBatchNode.reorderChild(): child should be non-null";
		if (!(t instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children";
		if (-1 === this._children.indexOf(t)) cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
		else if (e != t.zIndex) {
			if (1 < this._children.length) {
				var i = this._getCurrentIndex(t, e);
				if (i.oldIndex != i.newIndex) {
					this._children.splice(i.oldIndex, 1);
					this._children.splice(i.newIndex, 0, t);
					i = t.getAtlasIndex();
					this._updateAllAtlasIndexes();
					for (var n = 0, r = this._children, c = 0; c < r.length; c++) if (r[c] == t) {
						n = t.getAtlasIndex();
						break
					}
					this.textureAtlas.moveQuadsFromIndex(i, t.getTotalParticles(), n);
					t.updateWithNoTime()
				}
			}
			t._setLocalZOrder(e)
		}
	},
	removeChildAtIndex: function(t, e) {
		this.removeChild(this._children[i], e)
	},
	removeAllChildren: function(t) {
		for (var e = this._children, i = 0; i < e.length; i++) e[i].setBatchNode(null);
		cc.Node.prototype.removeAllChildren.call(this, t);
		this.textureAtlas.removeAllQuads()
	},
	disableParticle: function(t) {
		t = this.textureAtlas.quads[t];
		t.br.vertices.x = t.br.vertices.y = t.tr.vertices.x = t.tr.vertices.y = t.tl.vertices.x = t.tl.vertices.y = t.bl.vertices.x = t.bl.vertices.y = 0;
		this.textureAtlas._setDirty(!0)
	},
	getTexture: function() {
		return this.textureAtlas.texture
	},
	setTexture: function(t) {
		this.textureAtlas.texture = t;
		var e = this._blendFunc;
		t && (!t.hasPremultipliedAlpha() && e.src == cc.BLEND_SRC && e.dst == cc.BLEND_DST) && (e.src = cc.SRC_ALPHA, e.dst = cc.ONE_MINUS_SRC_ALPHA)
	},
	setBlendFunc: function(t, e) {
		void 0 === e ? (this._blendFunc.src = t.src, this._blendFunc.dst = t.dst) : (this._blendFunc.src = t, this._blendFunc.src = e)
	},
	getBlendFunc: function() {
		return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
	},
	_updateAllAtlasIndexes: function() {
		for (var t = 0, e = this._children, i = 0; i < e.length; i++) {
			var n = e[i];
			n.setAtlasIndex(t);
			t += n.getTotalParticles()
		}
	},
	_increaseAtlasCapacityTo: function(t) {
		cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + t + "].");
		this.textureAtlas.resizeCapacity(t) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
	},
	_searchNewPositionInChildrenForZ: function(t) {
		for (var e = this._children, i = e.length, n = 0; n < i; n++) if (e[n].zIndex > t) return n;
		return i
	},
	_getCurrentIndex: function(t, e) {
		for (var i = !1, n = !1, r = 0, c = 0, s = 0, o = this._children, a = o.length, h = 0; h < a; h++) {
			var l = o[h];
			if (l.zIndex > e && !n && (r = h, n = !0, i && n)) break;
			if (t == l && (c = h, i = !0, n || (s = -1), i && n)) break
		}
		n || (r = a);
		return {
			newIndex: r + s,
			oldIndex: c
		}
	},
	_addChildHelper: function(t, e, i) {
		if (!t) throw "cc.ParticleBatchNode._addChildHelper(): child should be non-null";
		if (t.parent) return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"), null;
		this._children || (this._children = []);
		var n = this._searchNewPositionInChildrenForZ(e);
		this._children.splice(n, 0, t);
		t.tag = i;
		t._setLocalZOrder(e);
		t.parent = this;
		this._running && (t.onEnter(), t.onEnterTransitionDidFinish());
		return n
	},
	_updateBlendFunc: function() {
		this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
	},
	getTextureAtlas: function() {
		return this.textureAtlas
	},
	setTextureAtlas: function(t) {
		this.textureAtlas = t
	}
});
_p = cc.ParticleBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleBatchNode.create = function(t, e) {
	return new cc.ParticleBatchNode(t, e)
};
(function() {
	cc.ParticleBatchNode.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._needDraw = !1
	};
	var t = cc.ParticleBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.ParticleBatchNode.CanvasRenderCmd;
	t._initWithTexture = function() {}
})();
(function() {
	cc.ParticleBatchNode.WebGLRenderCmd = function(t) {
		cc.Node.WebGLRenderCmd.call(this, t);
		this._needDraw = !0
	};
	var t = cc.ParticleBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	t.constructor = cc.ParticleBatchNode.WebGLRenderCmd;
	t.rendering = function(t) {
		t = this._node;
		0 != t.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFuncForParticle(t._blendFunc.src, t._blendFunc.dst), t.textureAtlas.drawQuads())
	};
	t._initWithTexture = function() {
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	t.visit = function() {
		if (this._node._visible) {
			var t = cc.current_stack;
			t.stack.push(t.top);
			this._syncStatus(ctx);
			t.top = this._stackMatrix;
			cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0;
			cc.kmGLPopMatrix()
		}
	}
})();
cc.IMEKeyboardNotificationInfo = function(t, e, i) {
	this.begin = t || cc.rect(0, 0, 0, 0);
	this.end = e || cc.rect(0, 0, 0, 0);
	this.duration = i || 0
};
cc.IMEDelegate = cc.Class.extend({
	ctor: function() {
		cc.imeDispatcher.addDelegate(this)
	},
	removeDelegate: function() {
		cc.imeDispatcher.removeDelegate(this)
	},
	attachWithIME: function() {
		return cc.imeDispatcher.attachDelegateWithIME(this)
	},
	detachWithIME: function() {
		return cc.imeDispatcher.detachDelegateWithIME(this)
	},
	canAttachWithIME: function() {
		return !1
	},
	didAttachWithIME: function() {},
	canDetachWithIME: function() {
		return !1
	},
	didDetachWithIME: function() {},
	insertText: function(t, e) {},
	deleteBackward: function() {},
	getContentText: function() {
		return ""
	},
	keyboardWillShow: function(t) {},
	keyboardDidShow: function(t) {},
	keyboardWillHide: function(t) {},
	keyboardDidHide: function(t) {}
});
cc.IMEDispatcher = cc.Class.extend({
	_domInputControl: null,
	impl: null,
	_currentInputString: "",
	_lastClickPosition: null,
	ctor: function() {
		this.impl = new cc.IMEDispatcher.Impl;
		this._lastClickPosition = cc.p(0, 0)
	},
	init: function() {
		if (!cc.sys.isMobile) {
			this._domInputControl = cc.$("#imeDispatcherInput");
			this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0, 0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
			var t = this;
			cc._addEventListener(this._domInputControl, "input", function() {
				t._processDomInputString(t._domInputControl.value)
			}, !1);
			cc._addEventListener(this._domInputControl, "keydown", function(e) {
				e.keyCode === cc.KEY.tab ? (e.stopPropagation(), e.preventDefault()) : e.keyCode == cc.KEY.enter && (t.dispatchInsertText("\n", 1), e.stopPropagation(), e.preventDefault())
			}, !1);
			/msie/i.test(navigator.userAgent) && cc._addEventListener(this._domInputControl, "keyup", function(e) {
				e.keyCode == cc.KEY.backspace && t._processDomInputString(t._domInputControl.value)
			}, !1);
			cc._addEventListener(window, "mousedown", function(e) {
				var i = e.pageY || 0;
				t._lastClickPosition.x = e.pageX || 0;
				t._lastClickPosition.y = i
			}, !1)
		}
	},
	_processDomInputString: function(t) {
		var e, i;
		e = this._currentInputString.length < t.length ? this._currentInputString.length : t.length;
		for (i = 0; i < e && t[i] === this._currentInputString[i]; i++);
		var n = this._currentInputString.length - i,
			r = t.length - i;
		for (e = 0; e < n; e++) this.dispatchDeleteBackward();
		for (e = 0; e < r; e++) this.dispatchInsertText(t[i + e], 1);
		this._currentInputString = t
	},
	dispatchInsertText: function(t, e) {
		this.impl && t && !(0 >= e) && this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(t, e)
	},
	dispatchDeleteBackward: function() {
		this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward()
	},
	getContentText: function() {
		if (this.impl && this.impl._delegateWithIme) {
			var t = this.impl._delegateWithIme.getContentText();
			return t ? t : ""
		}
		return ""
	},
	dispatchKeyboardWillShow: function(t) {
		if (this.impl) for (var e = 0; e < this.impl._delegateList.length; e++) {
			var i = this.impl._delegateList[e];
			i && i.keyboardWillShow(t)
		}
	},
	dispatchKeyboardDidShow: function(t) {
		if (this.impl) for (var e = 0; e < this.impl._delegateList.length; e++) {
			var i = this.impl._delegateList[e];
			i && i.keyboardDidShow(t)
		}
	},
	dispatchKeyboardWillHide: function(t) {
		if (this.impl) for (var e = 0; e < this.impl._delegateList.length; e++) {
			var i = this.impl._delegateList[e];
			i && i.keyboardWillHide(t)
		}
	},
	dispatchKeyboardDidHide: function(t) {
		if (this.impl) for (var e = 0; e < this.impl._delegateList.length; e++) {
			var i = this.impl._delegateList[e];
			i && i.keyboardDidHide(t)
		}
	},
	addDelegate: function(t) {
		t && this.impl && (-1 < this.impl._delegateList.indexOf(t) || this.impl._delegateList.splice(0, 0, t))
	},
	attachDelegateWithIME: function(t) {
		if (!this.impl || !t || -1 == this.impl._delegateList.indexOf(t)) return !1;
		if (this.impl._delegateWithIme) {
			if (!this.impl._delegateWithIme.canDetachWithIME() || !t.canAttachWithIME()) return !1;
			var e = this.impl._delegateWithIme;
			this.impl._delegateWithIme = null;
			e.didDetachWithIME();
			this._focusDomInput(t);
			return !0
		}
		if (!t.canAttachWithIME()) return !1;
		this._focusDomInput(t);
		return !0
	},
	_focusDomInput: function(t) {
		cc.sys.isMobile ? (this.impl._delegateWithIme = t, t.didAttachWithIME(), this._currentInputString = t.string || "", t = prompt("please enter your word:", this._currentInputString), null != t && this._processDomInputString(t), this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme = t, this._currentInputString = t.string || "", t.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate())
	},
	_domInputControlTranslate: function() {
		/msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
	},
	detachDelegateWithIME: function(t) {
		if (!this.impl || !t || this.impl._delegateWithIme != t || !t.canDetachWithIME()) return !1;
		this.impl._delegateWithIme = null;
		t.didDetachWithIME();
		cc._canvas.focus();
		return !0
	},
	removeDelegate: function(t) {
		this.impl && t && -1 != this.impl._delegateList.indexOf(t) && (this.impl._delegateWithIme && t == this.impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList, t))
	},
	processKeycode: function(t) {
		32 > t ? t == cc.KEY.backspace ? this.dispatchDeleteBackward() : t == cc.KEY.enter && this.dispatchInsertText("\n", 1) : 255 > t && this.dispatchInsertText(String.fromCharCode(t), 1)
	}
});
cc.IMEDispatcher.Impl = cc.Class.extend({
	_delegateWithIme: null,
	_delegateList: null,
	ctor: function() {
		this._delegateList = []
	},
	findDelegate: function(t) {
		for (var e = 0; e < this._delegateList.length; e++) if (this._delegateList[e] == t) return e;
		return null
	}
});
cc.imeDispatcher = new cc.IMEDispatcher;
document.body ? cc.imeDispatcher.init() : cc._addEventListener(window, "load", function() {
	cc.imeDispatcher.init()
}, !1);
cc.TextFieldDelegate = cc.Class.extend({
	onTextFieldAttachWithIME: function(t) {
		return !1
	},
	onTextFieldDetachWithIME: function(t) {
		return !1
	},
	onTextFieldInsertText: function(t, e, i) {
		return !1
	},
	onTextFieldDeleteBackward: function(t, e, i) {
		return !1
	},
	onDraw: function(t) {
		return !1
	}
});
cc.TextFieldTTF = cc.LabelTTF.extend({
	delegate: null,
	colorSpaceHolder: null,
	_colorText: null,
	_lens: null,
	_inputText: "",
	_placeHolder: "",
	_charCount: 0,
	_className: "TextFieldTTF",
	ctor: function(t, e, i, n, r) {
		this.colorSpaceHolder = cc.color(127, 127, 127);
		this._colorText = cc.color(255, 255, 255, 255);
		cc.imeDispatcher.addDelegate(this);
		cc.LabelTTF.prototype.ctor.call(this);
		void 0 !== r ? (this.initWithPlaceHolder("", e, i, n, r), t && this.setPlaceHolder(t)) : void 0 === n && void 0 !== i && (this.initWithString("", e, i), t && this.setPlaceHolder(t))
	},
	getDelegate: function() {
		return this.delegate
	},
	setDelegate: function(t) {
		this.delegate = t
	},
	getCharCount: function() {
		return this._charCount
	},
	getColorSpaceHolder: function() {
		return cc.color(this.colorSpaceHolder)
	},
	setColorSpaceHolder: function(t) {
		this.colorSpaceHolder.r = t.r;
		this.colorSpaceHolder.g = t.g;
		this.colorSpaceHolder.b = t.b;
		this.colorSpaceHolder.a = cc.isUndefined(t.a) ? 255 : t.a
	},
	setTextColor: function(t) {
		this._colorText.r = t.r;
		this._colorText.g = t.g;
		this._colorText.b = t.b;
		this._colorText.a = cc.isUndefined(t.a) ? 255 : t.a
	},
	initWithPlaceHolder: function(t, e, i, n, r) {
		switch (arguments.length) {
		case 5:
			return t && this.setPlaceHolder(t), this.initWithString(this._placeHolder, n, r, e, i);
		case 3:
			return t && this.setPlaceHolder(t), this.initWithString(this._placeHolder, arguments[1], arguments[2]);
		default:
			throw "Argument must be non-nil "
		}
	},
	setString: function(t) {
		this._inputText = (t = String(t)) || "";
		this._inputText.length ? (cc.LabelTTF.prototype.setString.call(this, this._inputText), this.setColor(this._colorText)) : (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder));
		cc._renderType === cc._RENDER_TYPE_CANVAS && this._renderCmd._updateTexture();
		this._charCount = this._inputText.length
	},
	getString: function() {
		return this._inputText
	},
	setPlaceHolder: function(t) {
		this._placeHolder = t || "";
		this._inputText.length || (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder))
	},
	getPlaceHolder: function() {
		return this._placeHolder
	},
	draw: function(t) {
		t = t || cc._renderContext;
		(!this.delegate || !this.delegate.onDraw(this)) && cc.LabelTTF.prototype.draw.call(this, t)
	},
	visit: function(t) {
		this._super(t)
	},
	attachWithIME: function() {
		return cc.imeDispatcher.attachDelegateWithIME(this)
	},
	detachWithIME: function() {
		return cc.imeDispatcher.detachDelegateWithIME(this)
	},
	canAttachWithIME: function() {
		return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : !0
	},
	didAttachWithIME: function() {},
	canDetachWithIME: function() {
		return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0
	},
	didDetachWithIME: function() {},
	deleteBackward: function() {
		var t = this._inputText.length;
		if (0 != t && (!this.delegate || !this.delegate.onTextFieldDeleteBackward(this, this._inputText[t - 1], 1))) 1 >= t ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder)) : this.string = this._inputText.substring(0, t - 1)
	},
	removeDelegate: function() {
		cc.imeDispatcher.removeDelegate(this)
	},
	insertText: function(t, e) {
		var i = t,
			n = i.indexOf("\n"); - 1 < n && (i = i.substring(0, n));
		if (0 < i.length) {
			if (this.delegate && this.delegate.onTextFieldInsertText(this, i, i.length)) return;
			i = this._inputText + i;
			this._charCount = i.length;
			this.string = i
		} - 1 != n && (!this.delegate || !this.delegate.onTextFieldInsertText(this, "\n", 1)) && this.detachWithIME()
	},
	getContentText: function() {
		return this._inputText
	},
	keyboardWillShow: function(t) {},
	keyboardDidShow: function(t) {},
	keyboardWillHide: function(t) {},
	keyboardDidHide: function(t) {}
});
_p = cc.TextFieldTTF.prototype;
cc.defineGetterSetter(_p, "charCount", _p.getCharCount);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.TextFieldTTF.create = function(t, e, i, n, r) {
	return new cc.TextFieldTTF(t, e, i, n, r)
};
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.MenuItem = cc.Node.extend({
	_enabled: !1,
	_target: null,
	_callback: null,
	_isSelected: !1,
	_className: "MenuItem",
	ctor: function(t, e) {
		var i = cc.Node.prototype;
		i.ctor.call(this);
		this._callback = this._target = null;
		this._enabled = this._isSelected = !1;
		i.setAnchorPoint.call(this, .5, .5);
		this._target = e || null;
		if (this._callback = t || null) this._enabled = !0
	},
	isSelected: function() {
		return this._isSelected
	},
	setOpacityModifyRGB: function(t) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	setTarget: function(t, e) {
		this._target = e;
		this._callback = t
	},
	isEnabled: function() {
		return this._enabled
	},
	setEnabled: function(t) {
		this._enabled = t
	},
	initWithCallback: function(t, e) {
		this.anchorY = this.anchorX = .5;
		this._target = e;
		this._callback = t;
		this._enabled = !0;
		this._isSelected = !1;
		return !0
	},
	rect: function() {
		var t = this._position,
			e = this._contentSize,
			i = this._anchorPoint;
		return cc.rect(t.x - e.width * i.x, t.y - e.height * i.y, e.width, e.height)
	},
	selected: function() {
		this._isSelected = !0
	},
	unselected: function() {
		this._isSelected = !1
	},
	setCallback: function(t, e) {
		this._target = e;
		this._callback = t
	},
	activate: function() {
		if (this._enabled) {
			var t = this._target,
				e = this._callback;
			if (e) if (t && cc.isString(e)) t[e](this);
			else t && cc.isFunction(e) ? e.call(t, this) : e(this)
		}
	}
});
_p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function(t, e) {
	return new cc.MenuItem(t, e)
};
cc.MenuItemLabel = cc.MenuItem.extend({
	_disabledColor: null,
	_label: null,
	_originalScale: 0,
	_colorBackup: null,
	ctor: function(t, e, i) {
		cc.MenuItem.prototype.ctor.call(this, e, i);
		this._colorBackup = this._label = this._disabledColor = null;
		t && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(t), this.cascadeOpacity = this.cascadeColor = !0)
	},
	getDisabledColor: function() {
		return this._disabledColor
	},
	setDisabledColor: function(t) {
		this._disabledColor = t
	},
	getLabel: function() {
		return this._label
	},
	setLabel: function(t) {
		t && (this.addChild(t), t.anchorX = 0, t.anchorY = 0, this.width = t.width, this.height = t.height);
		this._label && this.removeChild(this._label, !0);
		this._label = t
	},
	setEnabled: function(t) {
		if (this._enabled != t) {
			var e = this._label;
			t ? e.color = this._colorBackup : (this._colorBackup = e.color, e.color = this._disabledColor)
		}
		cc.MenuItem.prototype.setEnabled.call(this, t)
	},
	setOpacity: function(t) {
		this._label.opacity = t
	},
	getOpacity: function() {
		return this._label.opacity
	},
	setColor: function(t) {
		this._label.color = t
	},
	getColor: function() {
		return this._label.color
	},
	initWithLabel: function(t, e, i) {
		this.initWithCallback(e, i);
		this._originalScale = 1;
		this._colorBackup = cc.color.WHITE;
		this._disabledColor = cc.color(126, 126, 126);
		this.setLabel(t);
		return this.cascadeOpacity = this.cascadeColor = !0
	},
	setString: function(t) {
		this._label.string = t;
		this.width = this._label.width;
		this.height = this._label.height
	},
	getString: function() {
		return this._label.string
	},
	activate: function() {
		this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
	},
	selected: function() {
		if (this._enabled) {
			cc.MenuItem.prototype.selected.call(this);
			var t = this.getActionByTag(cc.ZOOM_ACTION_TAG);
			t ? this.stopAction(t) : this._originalScale = this.scale;
			t = cc.scaleTo(.1, 1.2 * this._originalScale);
			t.setTag(cc.ZOOM_ACTION_TAG);
			this.runAction(t)
		}
	},
	unselected: function() {
		if (this._enabled) {
			cc.MenuItem.prototype.unselected.call(this);
			this.stopActionByTag(cc.ZOOM_ACTION_TAG);
			var t = cc.scaleTo(.1, this._originalScale);
			t.setTag(cc.ZOOM_ACTION_TAG);
			this.runAction(t)
		}
	}
});
_p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function(t, e, i) {
	return new cc.MenuItemLabel(t, e, i)
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
	ctor: function(t, e, i, n, r, c, s) {
		var o;
		t && 0 < t.length && (o = new cc.LabelAtlas(t, e, i, n, r));
		cc.MenuItemLabel.prototype.ctor.call(this, o, c, s)
	},
	initWithString: function(t, e, i, n, r, c, s) {
		if (!t || 0 == t.length) throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
		var o = new cc.LabelAtlas;
		o.initWithString(t, e, i, n, r);
		this.initWithLabel(o, c, s);
		return !0
	}
});
cc.MenuItemAtlasFont.create = function(t, e, i, n, r, c, s) {
	return new cc.MenuItemAtlasFont(t, e, i, n, r, c, s)
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
	_fontSize: null,
	_fontName: null,
	ctor: function(t, e, i) {
		var n;
		t && 0 < t.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, n = new cc.LabelTTF(t, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
		cc.MenuItemLabel.prototype.ctor.call(this, n, e, i)
	},
	initWithString: function(t, e, i) {
		if (!t || 0 == t.length) throw "Value should be non-null and its length should be greater than 0";
		this._fontName = cc._globalFontName;
		this._fontSize = cc._globalFontSize;
		t = new cc.LabelTTF(t, this._fontName, this._fontSize);
		this.initWithLabel(t, e, i);
		return !0
	},
	setFontSize: function(t) {
		this._fontSize = t;
		this._recreateLabel()
	},
	getFontSize: function() {
		return this._fontSize
	},
	setFontName: function(t) {
		this._fontName = t;
		this._recreateLabel()
	},
	getFontName: function() {
		return this._fontName
	},
	_recreateLabel: function() {
		var t = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
		this.setLabel(t)
	}
});
cc.MenuItemFont.setFontSize = function(t) {
	cc._globalFontSize = t
};
cc.MenuItemFont.fontSize = function() {
	return cc._globalFontSize
};
cc.MenuItemFont.setFontName = function(t) {
	cc._globalFontNameRelease && (cc._globalFontName = "");
	cc._globalFontName = t;
	cc._globalFontNameRelease = !0
};
_p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function() {
	return cc._globalFontName
};
cc.MenuItemFont.create = function(t, e, i) {
	return new cc.MenuItemFont(t, e, i)
};
cc.MenuItemSprite = cc.MenuItem.extend({
	_normalImage: null,
	_selectedImage: null,
	_disabledImage: null,
	ctor: function(t, e, i, n, r) {
		cc.MenuItem.prototype.ctor.call(this);
		this._disabledImage = this._selectedImage = this._normalImage = null;
		if (void 0 !== e) {
			var c, s, o;
			void 0 !== r ? (c = i, o = n, s = r) : void 0 !== n && cc.isFunction(n) ? (c = i, o = n) : void 0 !== n && cc.isFunction(i) ? (s = n, o = i, c = new cc.Sprite(e.getTexture(), e.getTextureRect())) : void 0 === i && (c = new cc.Sprite(e.getTexture(), e.getTextureRect()));
			this.initWithNormalSprite(t, e, c, o, s)
		}
	},
	getNormalImage: function() {
		return this._normalImage
	},
	setNormalImage: function(t) {
		this._normalImage != t && (t && (this.addChild(t, 0, cc.NORMAL_TAG), t.anchorX = 0, t.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = t, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), t.textureLoaded && !t.textureLoaded() && t.addEventListener("load", function(t) {
			this.width = t.width;
			this.height = t.height
		}, this))
	},
	getSelectedImage: function() {
		return this._selectedImage
	},
	setSelectedImage: function(t) {
		this._selectedImage != t && (t && (this.addChild(t, 0, cc.SELECTED_TAG), t.anchorX = 0, t.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = t, this._updateImagesVisibility())
	},
	getDisabledImage: function() {
		return this._disabledImage
	},
	setDisabledImage: function(t) {
		this._disabledImage != t && (t && (this.addChild(t, 0, cc.DISABLE_TAG), t.anchorX = 0, t.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = t, this._updateImagesVisibility())
	},
	initWithNormalSprite: function(t, e, i, n, r) {
		this.initWithCallback(n, r);
		this.setNormalImage(t);
		this.setSelectedImage(e);
		this.setDisabledImage(i);
		if (t = this._normalImage) this.width = t.width, this.height = t.height, t.textureLoaded && !t.textureLoaded() && t.addEventListener("load", function(t) {
			this.width = t.width;
			this.height = t.height;
			this.cascadeOpacity = this.cascadeColor = !0
		}, this);
		return this.cascadeOpacity = this.cascadeColor = !0
	},
	setColor: function(t) {
		this._normalImage.color = t;
		this._selectedImage && (this._selectedImage.color = t);
		this._disabledImage && (this._disabledImage.color = t)
	},
	getColor: function() {
		return this._normalImage.color
	},
	setOpacity: function(t) {
		this._normalImage.opacity = t;
		this._selectedImage && (this._selectedImage.opacity = t);
		this._disabledImage && (this._disabledImage.opacity = t)
	},
	getOpacity: function() {
		return this._normalImage.opacity
	},
	selected: function() {
		cc.MenuItem.prototype.selected.call(this);
		this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
	},
	unselected: function() {
		cc.MenuItem.prototype.unselected.call(this);
		this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
	},
	setEnabled: function(t) {
		this._enabled != t && (cc.MenuItem.prototype.setEnabled.call(this, t), this._updateImagesVisibility())
	},
	_updateImagesVisibility: function() {
		var t = this._normalImage,
			e = this._selectedImage,
			i = this._disabledImage;
		this._enabled ? (t && (t.visible = !0), e && (e.visible = !1), i && (i.visible = !1)) : i ? (t && (t.visible = !1), e && (e.visible = !1), i && (i.visible = !0)) : (t && (t.visible = !0), e && (e.visible = !1))
	}
});
_p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function(t, e, i, n, r) {
	return new cc.MenuItemSprite(t, e, i, n, r || void 0)
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
	ctor: function(t, e, i, n, r) {
		var c = null,
			s = null,
			o = null,
			a = null,
			h = null;
		void 0 === t ? cc.MenuItemSprite.prototype.ctor.call(this) : (c = new cc.Sprite(t), e && (s = new cc.Sprite(e)), void 0 === n ? a = i : void 0 === r ? (a = i, h = n) : r && (o = new cc.Sprite(i), a = n, h = r), cc.MenuItemSprite.prototype.ctor.call(this, c, s, o, a, h))
	},
	setNormalSpriteFrame: function(t) {
		this.setNormalImage(new cc.Sprite(t))
	},
	setSelectedSpriteFrame: function(t) {
		this.setSelectedImage(new cc.Sprite(t))
	},
	setDisabledSpriteFrame: function(t) {
		this.setDisabledImage(new cc.Sprite(t))
	},
	initWithNormalImage: function(t, e, i, n, r) {
		var c = null,
			s = null,
			o = null;
		t && (c = new cc.Sprite(t));
		e && (s = new cc.Sprite(e));
		i && (o = new cc.Sprite(i));
		return this.initWithNormalSprite(c, s, o, n, r)
	}
});
cc.MenuItemImage.create = function(t, e, i, n, r) {
	return new cc.MenuItemImage(t, e, i, n, r)
};
cc.MenuItemToggle = cc.MenuItem.extend({
	subItems: null,
	_selectedIndex: 0,
	_opacity: null,
	_color: null,
	ctor: function() {
		cc.MenuItem.prototype.ctor.call(this);
		this._selectedIndex = 0;
		this.subItems = [];
		this._opacity = 0;
		this._color = cc.color.WHITE;
		0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
	},
	getOpacity: function() {
		return this._opacity
	},
	setOpacity: function(t) {
		this._opacity = t;
		if (this.subItems && 0 < this.subItems.length) for (var e = 0; e < this.subItems.length; e++) this.subItems[e].opacity = t;
		this._color.a = t
	},
	getColor: function() {
		var t = this._color;
		return cc.color(t.r, t.g, t.b, t.a)
	},
	setColor: function(t) {
		var e = this._color;
		e.r = t.r;
		e.g = t.g;
		e.b = t.b;
		if (this.subItems && 0 < this.subItems.length) for (e = 0; e < this.subItems.length; e++) this.subItems[e].setColor(t);
		void 0 !== t.a && !t.a_undefined && this.setOpacity(t.a)
	},
	getSelectedIndex: function() {
		return this._selectedIndex
	},
	setSelectedIndex: function(t) {
		if (t != this._selectedIndex) {
			this._selectedIndex = t;
			(t = this.getChildByTag(cc.CURRENT_ITEM)) && t.removeFromParent(!1);
			t = this.subItems[this._selectedIndex];
			this.addChild(t, 0, cc.CURRENT_ITEM);
			var e = t.width,
				i = t.height;
			this.width = e;
			this.height = i;
			t.setPosition(e / 2, i / 2)
		}
	},
	getSubItems: function() {
		return this.subItems
	},
	setSubItems: function(t) {
		this.subItems = t
	},
	initWithItems: function(t) {
		var e = t.length;
		cc.isFunction(t[t.length - 2]) ? (this.initWithCallback(t[t.length - 2], t[t.length - 1]), e -= 2) : cc.isFunction(t[t.length - 1]) ? (this.initWithCallback(t[t.length - 1], null), e -= 1) : this.initWithCallback(null, null);
		for (var i = this.subItems, n = i.length = 0; n < e; n++) t[n] && i.push(t[n]);
		this._selectedIndex = cc.UINT_MAX;
		this.setSelectedIndex(0);
		return this.cascadeOpacity = this.cascadeColor = !0
	},
	addSubItem: function(t) {
		this.subItems.push(t)
	},
	activate: function() {
		this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length);
		cc.MenuItem.prototype.activate.call(this)
	},
	selected: function() {
		cc.MenuItem.prototype.selected.call(this);
		this.subItems[this._selectedIndex].selected()
	},
	unselected: function() {
		cc.MenuItem.prototype.unselected.call(this);
		this.subItems[this._selectedIndex].unselected()
	},
	setEnabled: function(t) {
		if (this._enabled != t) {
			cc.MenuItem.prototype.setEnabled.call(this, t);
			var e = this.subItems;
			if (e && 0 < e.length) for (var i = 0; i < e.length; i++) e[i].enabled = t
		}
	},
	selectedItem: function() {
		return this.subItems[this._selectedIndex]
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this.setSelectedIndex(this._selectedIndex)
	}
});
_p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function() {
	0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
	var t = new cc.MenuItemToggle;
	t.initWithItems(Array.prototype.slice.apply(arguments));
	return t
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
	enabled: !1,
	_selectedItem: null,
	_state: -1,
	_touchListener: null,
	_className: "Menu",
	ctor: function(t) {
		cc.Layer.prototype.ctor.call(this);
		this._color = cc.color.WHITE;
		this.enabled = !1;
		this._opacity = 255;
		this._selectedItem = null;
		this._state = -1;
		this._touchListener = cc.EventListener.create({
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			swallowTouches: !0,
			onTouchBegan: this._onTouchBegan,
			onTouchMoved: this._onTouchMoved,
			onTouchEnded: this._onTouchEnded,
			onTouchCancelled: this._onTouchCancelled
		});
		0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
		var e = arguments.length,
			i;
		if (0 == e) i = [];
		else if (1 == e) i = t instanceof Array ? t : [t];
		else if (1 < e) {
			i = [];
			for (var n = 0; n < e; n++) arguments[n] && i.push(arguments[n])
		}
		this.initWithArray(i)
	},
	onEnter: function() {
		var t = this._touchListener;
		t._isRegistered() || cc.eventManager.addListener(t, this);
		cc.Node.prototype.onEnter.call(this)
	},
	isEnabled: function() {
		return this.enabled
	},
	setEnabled: function(t) {
		this.enabled = t
	},
	initWithItems: function(t) {
		var e = [];
		if (t) for (var i = 0; i < t.length; i++) t[i] && e.push(t[i]);
		return this.initWithArray(e)
	},
	initWithArray: function(t) {
		if (cc.Layer.prototype.init.call(this)) {
			this.enabled = !0;
			var e = cc.winSize;
			this.setPosition(e.width / 2, e.height / 2);
			this.setContentSize(e);
			this.setAnchorPoint(.5, .5);
			this.ignoreAnchorPointForPosition(!0);
			if (t) for (e = 0; e < t.length; e++) this.addChild(t[e], e);
			this._selectedItem = null;
			this._state = cc.MENU_STATE_WAITING;
			return this.cascadeOpacity = this.cascadeColor = !0
		}
		return !1
	},
	addChild: function(t, e, i) {
		if (!(t instanceof cc.MenuItem)) throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
		cc.Layer.prototype.addChild.call(this, t, e, i)
	},
	alignItemsVertically: function() {
		this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
	},
	alignItemsVerticallyWithPadding: function(t) {
		var e = -t,
			i = this._children,
			n, r, c, s;
		if (i && 0 < i.length) {
			r = 0;
			for (n = i.length; r < n; r++) e += i[r].height * i[r].scaleY + t;
			var o = e / 2;
			r = 0;
			for (n = i.length; r < n; r++) s = i[r], c = s.height, e = s.scaleY, s.setPosition(0, o - c * e / 2), o -= c * e + t
		}
	},
	alignItemsHorizontally: function() {
		this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
	},
	alignItemsHorizontallyWithPadding: function(t) {
		var e = -t,
			i = this._children,
			n, r, c, s;
		if (i && 0 < i.length) {
			n = 0;
			for (r = i.length; n < r; n++) e += i[n].width * i[n].scaleX + t;
			var o = -e / 2;
			n = 0;
			for (r = i.length; n < r; n++) s = i[n], e = s.scaleX, c = i[n].width, s.setPosition(o + c * e / 2, 0), o += c * e + t
		}
	},
	alignItemsInColumns: function() {
		0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
		for (var t = [], e = 0; e < arguments.length; e++) t.push(arguments[e]);
		var i = -5,
			n = 0,
			r = 0,
			c = 0,
			s, o, a, h = this._children;
		if (h && 0 < h.length) {
			e = 0;
			for (a = h.length; e < a; e++) if (!(n >= t.length) && (s = t[n])) o = h[e].height, r = r >= o || isNaN(o) ? r : o, ++c, c >= s && (i += r + 5, r = c = 0, ++n)
		}
		var l = cc.director.getWinSize(),
			u = s = r = n = 0,
			d = 0,
			i = i / 2;
		if (h && 0 < h.length) {
			e = 0;
			for (a = h.length; e < a; e++) {
				var _ = h[e];
				0 == s && (s = t[n], d = u = l.width / (1 + s));
				o = _._getHeight();
				r = r >= o || isNaN(o) ? r : o;
				_.setPosition(d - l.width / 2, i - o / 2);
				d += u;
				++c;
				c >= s && (i -= r + 5, r = s = c = 0, ++n)
			}
		}
	},
	alignItemsInRows: function() {
		0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
		var t = [],
			e;
		for (e = 0; e < arguments.length; e++) t.push(arguments[e]);
		var i = [],
			n = [],
			r = -10,
			c = -5,
			s = 0,
			o = 0,
			a = 0,
			h, l, u, d, _ = this._children;
		if (_ && 0 < _.length) {
			e = 0;
			for (u = _.length; e < u; e++) if (l = _[e], !(s >= t.length) && (h = t[s])) d = l.width, o = o >= d || isNaN(d) ? o : d, c += l.height + 5, ++a, a >= h && (i.push(o), n.push(c), r += o + 10, o = a = 0, c = -5, ++s)
		}
		c = cc.director.getWinSize();
		h = o = s = 0;
		var r = -r / 2,
			f = 0;
		if (_ && 0 < _.length) {
			e = 0;
			for (u = _.length; e < u; e++) l = _[e], 0 == h && (h = t[s], f = n[s]), d = l._getWidth(), o = o >= d || isNaN(d) ? o : d, l.setPosition(r + i[s] / 2, f - c.height / 2), f -= l.height + 10, ++a, a >= h && (r += o + 5, o = h = a = 0, ++s)
		}
	},
	removeChild: function(t, e) {
		null != t && (t instanceof cc.MenuItem ? (this._selectedItem == t && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, t, e)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
	},
	_onTouchBegan: function(t, e) {
		var i = e.getCurrentTarget();
		if (i._state != cc.MENU_STATE_WAITING || !i._visible || !i.enabled) return !1;
		for (var n = i.parent; null != n; n = n.parent) if (!n.isVisible()) return !1;
		i._selectedItem = i._itemForTouch(t);
		return i._selectedItem ? (i._state = cc.MENU_STATE_TRACKING_TOUCH, i._selectedItem.selected(), i._selectedItem.setNodeDirty(), !0) : !1
	},
	_onTouchEnded: function(t, e) {
		var i = e.getCurrentTarget();
		i._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (i._selectedItem && (i._selectedItem.unselected(), i._selectedItem.setNodeDirty(), i._selectedItem.activate()), i._state = cc.MENU_STATE_WAITING)
	},
	_onTouchCancelled: function(t, e) {
		var i = e.getCurrentTarget();
		i._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem && (i._selectedItem.unselected(), i._selectedItem.setNodeDirty()), i._state = cc.MENU_STATE_WAITING)
	},
	_onTouchMoved: function(t, e) {
		var i = e.getCurrentTarget();
		if (i._state !== cc.MENU_STATE_TRACKING_TOUCH) cc.log("cc.Menu.onTouchMoved(): invalid state");
		else {
			var n = i._itemForTouch(t);
			n != i._selectedItem && (i._selectedItem && (i._selectedItem.unselected(), i._selectedItem.setNodeDirty()), i._selectedItem = n, i._selectedItem && (i._selectedItem.selected(), i._selectedItem.setNodeDirty()))
		}
	},
	onExit: function() {
		this._state == cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING);
		cc.Node.prototype.onExit.call(this)
	},
	setOpacityModifyRGB: function(t) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	_itemForTouch: function(t) {
		t = t.getLocation();
		var e = this._children,
			i;
		if (e && 0 < e.length) for (var n = e.length - 1; 0 <= n; n--) if (i = e[n], i.isVisible() && i.isEnabled()) {
			var r = i.convertToNodeSpace(t),
				c = i.rect();
			c.x = 0;
			c.y = 0;
			if (cc.rectContainsPoint(c, r)) return i
		}
		return null
	}
});
_p = cc.Menu.prototype;
cc.Menu.create = function(t) {
	var e = arguments.length;
	0 < e && null == arguments[e - 1] && cc.log("parameters should not be ending with null in Javascript");
	return 0 == e ? new cc.Menu : 1 == e ? new cc.Menu(t) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
};
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function(t, e, i, n, r, c, s) {
	this.status = t || 0;
	this.type = e || 0;
	this.pixelDepth = i || 0;
	this.width = n || 0;
	this.height = r || 0;
	this.imageData = c || [];
	this.flipped = s || 0
};
cc.tgaLoadHeader = function(t, e, i) {
	var n = 2;
	if (n + 1 > e) return !1;
	t = new cc.BinaryStreamReader(t);
	t.setOffset(n);
	i.type = t.readByte();
	n += 10;
	if (n + 4 + 1 > e) return !1;
	t.setOffset(n);
	i.width = t.readUnsignedShort();
	i.height = t.readUnsignedInteger();
	i.pixelDepth = t.readByte();
	if (n + 5 + 1 > e) return !1;
	e = t.readByte();
	i.flipped = 0;
	e & 32 && (i.flipped = 1);
	return !0
};
cc.tgaLoadImageData = function(t, e, i) {
	var n, r;
	n = 0 | i.pixelDepth / 2;
	r = i.height * i.width * n;
	if (18 + r > e) return !1;
	i.imageData = cc.__getSubArray(t, 18, 18 + r);
	if (3 <= n) for (t = 0; t < r; t += n) e = i.imageData[t], i.imageData[t] = i.imageData[t + 2], i.imageData[t + 2] = e;
	return !0
};
cc.tgaRGBtogreyscale = function(t) {
	var e, i;
	if (8 !== t.pixelDepth) {
		var n = t.pixelDepth / 8,
			r = new Uint8Array(t.height * t.width);
		if (null !== r) {
			for (i = e = 0; i < t.width * t.height; e += n, i++) r[i] = .3 * t.imageData[e] + .59 * t.imageData[e + 1] + .11 * t.imageData[e + 2];
			t.pixelDepth = 8;
			t.type = 3;
			t.imageData = r
		}
	}
};
cc.tgaDestroy = function(t) {
	t && (t.imageData = null)
};
cc.tgaLoadRLEImageData = function(t, e, i) {
	var n, r, c, s = 0,
		o = 0,
		a = 0,
		h = [],
		l = 0,
		u = 18;
	n = i.pixelDepth / 8;
	r = i.height * i.width;
	for (c = 0; c < r; c++) {
		if (0 != l) l--, o = 0 != a;
		else {
			if (u + 1 > e) break;
			l = t[u];
			u += 1;
			(a = l & 128) && (l -= 128);
			o = 0
		}
		if (!o) {
			if (u + n > e) break;
			h = cc.__getSubArray(t, u, u + n);
			u += n;
			3 <= n && (o = h[0], h[0] = h[2], h[2] = o)
		}
		for (o = 0; o < n; o++) i.imageData[s + o] = h[o];
		s += n
	}
	return !0
};
cc.tgaFlipImage = function(t) {
	for (var e = t.width * (t.pixelDepth / 8), i = 0; i < t.height / 2; i++) {
		var n = cc.__getSubArray(t.imageData, i * e, i * e + e);
		cc.__setDataToArray(cc.__getSubArray(t.imageData, (t.height - (i + 1)) * e, e), t.imageData, i * e);
		cc.__setDataToArray(n, t.imageData, (t.height - (i + 1)) * e)
	}
	t.flipped = 0
};
cc.__getSubArray = function(t, e, i) {
	return t instanceof Array ? t.slice(e, i) : t.subarray(e, i)
};
cc.__setDataToArray = function(t, e, i) {
	for (var n = 0; n < t.length; n++) e[i + n] = t[n]
};
cc.BinaryStreamReader = cc.Class.extend({
	_binaryData: null,
	_offset: 0,
	ctor: function(t) {
		this._binaryData = t
	},
	setBinaryData: function(t) {
		this._binaryData = t;
		this._offset = 0
	},
	getBinaryData: function() {
		return this._binaryData
	},
	_checkSize: function(t) {
		if (!(this._offset + Math.ceil(t / 8) < this._data.length)) throw Error("Index out of bound")
	},
	_decodeFloat: function(t, e) {
		var i = t + e + 1,
			n = i >> 3;
		this._checkSize(i);
		var i = Math.pow(2, e - 1) - 1,
			r = this._readBits(t + e, 1, n),
			c = this._readBits(t, e, n),
			s = 0,
			o = 2,
			a = 0;
		do
		for (var h = this._readByte(++a, n), l = t % 8 || 8, u = 1 << l; u >>= 1;) h & u && (s += 1 / o), o *= 2;
		while (t -= l);
		this._offset += n;
		return c == (i << 1) + 1 ? s ? NaN : r ? -Infinity : Infinity : (1 + -2 * r) * (c || s ? !c ? Math.pow(2, -i + 1) * s : Math.pow(2, c - i) * (1 + s) : 0)
	},
	_readByte: function(t, e) {
		return this._data[this._offset + e - t - 1]
	},
	_decodeInt: function(t, e) {
		var i = this._readBits(0, t, t / 8),
			n = Math.pow(2, t);
		this._offset += t / 8;
		return e && i >= n / 2 ? i - n : i
	},
	_shl: function(t, e) {
		for (++e; --e; t = 1073741824 == ((t %= 2147483648) & 1073741824) ? 2 * t : 2 * (t - 1073741824) + 2147483648);
		return t
	},
	_readBits: function(t, e, i) {
		var n = (t + e) % 8,
			r = t % 8,
			c = i - (t >> 3) - 1;
		t = i + (-(t + e) >> 3);
		var s = c - t;
		e = this._readByte(c, i) >> r & (1 << (s ? 8 - r : e)) - 1;
		for (s && n && (e += (this._readByte(t++, i) & (1 << n) - 1) << (s-- << 3) - r); s;) e += this._shl(this._readByte(t++, i), (s-- << 3) - r);
		return e
	},
	readInteger: function() {
		return this._decodeInt(32, !0)
	},
	readUnsignedInteger: function() {
		return this._decodeInt(32, !1)
	},
	readSingle: function() {
		return this._decodeFloat(23, 8)
	},
	readShort: function() {
		return this._decodeInt(16, !0)
	},
	readUnsignedShort: function() {
		return this._decodeInt(16, !1)
	},
	readByte: function() {
		var t = this._data[this._offset];
		this._offset += 1;
		return t
	},
	readData: function(t, e) {
		return this._binaryData instanceof Array ? this._binaryData.slice(t, e) : this._binaryData.subarray(t, e)
	},
	setOffset: function(t) {
		this._offset = t
	},
	getOffset: function() {
		return this._offset
	}
});
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.Node.extend({
	properties: null,
	mapOrientation: null,
	objectGroups: null,
	_mapSize: null,
	_tileSize: null,
	_tileProperties: null,
	_className: "TMXTiledMap",
	ctor: function(t, e) {
		cc.Node.prototype.ctor.call(this);
		this._mapSize = cc.size(0, 0);
		this._tileSize = cc.size(0, 0);
		void 0 !== e ? this.initWithXML(t, e) : void 0 !== t && this.initWithTMXFile(t)
	},
	getMapSize: function() {
		return cc.size(this._mapSize.width, this._mapSize.height)
	},
	setMapSize: function(t) {
		this._mapSize.width = t.width;
		this._mapSize.height = t.height
	},
	_getMapWidth: function() {
		return this._mapSize.width
	},
	_setMapWidth: function(t) {
		this._mapSize.width = t
	},
	_getMapHeight: function() {
		return this._mapSize.height
	},
	_setMapHeight: function(t) {
		this._mapSize.height = t
	},
	getTileSize: function() {
		return cc.size(this._tileSize.width, this._tileSize.height)
	},
	setTileSize: function(t) {
		this._tileSize.width = t.width;
		this._tileSize.height = t.height
	},
	_getTileWidth: function() {
		return this._tileSize.width
	},
	_setTileWidth: function(t) {
		this._tileSize.width = t
	},
	_getTileHeight: function() {
		return this._tileSize.height
	},
	_setTileHeight: function(t) {
		this._tileSize.height = t
	},
	getMapOrientation: function() {
		return this.mapOrientation
	},
	setMapOrientation: function(t) {
		this.mapOrientation = t
	},
	getObjectGroups: function() {
		return this.objectGroups
	},
	setObjectGroups: function(t) {
		this.objectGroups = t
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(t) {
		this.properties = t
	},
	initWithTMXFile: function(t) {
		if (!t || 0 == t.length) throw "cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.";
		this.height = this.width = 0;
		t = new cc.TMXMapInfo(t);
		if (!t) return !1;
		var e = t.getTilesets();
		(!e || 0 === e.length) && cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
		this._buildWithMapInfo(t);
		return !0
	},
	initWithXML: function(t, e) {
		this.height = this.width = 0;
		var i = new cc.TMXMapInfo(t, e),
			n = i.getTilesets();
		(!n || 0 === n.length) && cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
		this._buildWithMapInfo(i);
		return !0
	},
	_buildWithMapInfo: function(t) {
		this._mapSize = t.getMapSize();
		this._tileSize = t.getTileSize();
		this.mapOrientation = t.orientation;
		this.objectGroups = t.getObjectGroups();
		this.properties = t.properties;
		this._tileProperties = t.getTileProperties();
		var e = 0,
			i = t.getLayers();
		if (i) for (var n = null, r = 0, c = i.length; r < c; r++) if ((n = i[r]) && n.visible) n = this._parseLayer(n, t), this.addChild(n, e, e), this.width = Math.max(this.width, n.width), this.height = Math.max(this.height, n.height), e++
	},
	allLayers: function() {
		for (var t = [], e = this._children, i = 0, n = e.length; i < n; i++) {
			var r = e[i];
			r && r instanceof cc.TMXLayer && t.push(r)
		}
		return t
	},
	getLayer: function(t) {
		if (!t || 0 === t.length) throw "cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.";
		for (var e = this._children, i = 0; i < e.length; i++) {
			var n = e[i];
			if (n && n.layerName == t) return n
		}
		return null
	},
	getObjectGroup: function(t) {
		if (!t || 0 === t.length) throw "cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.";
		if (this.objectGroups) for (var e = 0; e < this.objectGroups.length; e++) {
			var i = this.objectGroups[e];
			if (i && i.groupName == t) return i
		}
		return null
	},
	getProperty: function(t) {
		return this.properties[t.toString()]
	},
	propertiesForGID: function(t) {
		cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead.");
		return this.getPropertiesForGID[t]
	},
	getPropertiesForGID: function(t) {
		return this._tileProperties[t]
	},
	_parseLayer: function(t, e) {
		var i = this._tilesetForLayer(t, e),
			i = new cc.TMXLayer(i, t, e);
		t.ownTiles = !1;
		i.setupTiles();
		return i
	},
	_tilesetForLayer: function(t, e) {
		var i = t._layerSize,
			n = e.getTilesets();
		if (n) for (var r = n.length - 1; 0 <= r; r--) {
			var c = n[r];
			if (c) for (var s = 0; s < i.height; s++) for (var o = 0; o < i.width; o++) {
				var a = t._tiles[o + i.width * s];
				if (0 != a && (a & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= c.firstGid) return c
			}
		}
		cc.log("cocos2d: Warning: TMX Layer " + t.name + " has no tiles");
		return null
	}
});
_p = cc.TMXTiledMap.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXTiledMap.create = function(t, e) {
	return new cc.TMXTiledMap(t, e)
};
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({
	properties: null,
	name: "",
	_layerSize: null,
	_tiles: null,
	visible: null,
	_opacity: null,
	ownTiles: !0,
	_minGID: 1e5,
	_maxGID: 0,
	offset: null,
	ctor: function() {
		this.properties = [];
		this.name = "";
		this._layerSize = null;
		this._tiles = [];
		this.visible = !0;
		this._opacity = 0;
		this.ownTiles = !0;
		this._minGID = 1e5;
		this._maxGID = 0;
		this.offset = cc.p(0, 0)
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(t) {
		this.properties = t
	}
});
cc.TMXTilesetInfo = cc.Class.extend({
	name: "",
	firstGid: 0,
	_tileSize: null,
	spacing: 0,
	margin: 0,
	sourceImage: "",
	imageSize: null,
	ctor: function() {
		this._tileSize = cc.size(0, 0);
		this.imageSize = cc.size(0, 0)
	},
	rectForGID: function(t) {
		var e = cc.rect(0, 0, 0, 0);
		e.width = this._tileSize.width;
		e.height = this._tileSize.height;
		t &= cc.TMX_TILE_FLIPPED_MASK;
		t -= parseInt(this.firstGid, 10);
		var i = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
		e.x = parseInt(t % i * (this._tileSize.width + this.spacing) + this.margin, 10);
		e.y = parseInt(parseInt(t / i, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
		return e
	}
});
cc.TMXMapInfo = cc.SAXParser.extend({
	properties: null,
	orientation: null,
	parentElement: null,
	parentGID: null,
	layerAttrs: 0,
	storingCharacters: !1,
	tmxFileName: null,
	currentString: null,
	_objectGroups: null,
	_mapSize: null,
	_tileSize: null,
	_layers: null,
	_tilesets: null,
	_tileProperties: null,
	_resources: "",
	_currentFirstGID: 0,
	ctor: function(t, e) {
		cc.SAXParser.prototype.ctor.apply(this);
		this._mapSize = cc.size(0, 0);
		this._tileSize = cc.size(0, 0);
		this._layers = [];
		this._tilesets = [];
		this._objectGroups = [];
		this.properties = [];
		this._tileProperties = {};
		this._currentFirstGID = 0;
		void 0 !== e ? this.initWithXML(t, e) : void 0 !== t && this.initWithTMXFile(t)
	},
	getOrientation: function() {
		return this.orientation
	},
	setOrientation: function(t) {
		this.orientation = t
	},
	getMapSize: function() {
		return cc.size(this._mapSize.width, this._mapSize.height)
	},
	setMapSize: function(t) {
		this._mapSize.width = t.width;
		this._mapSize.height = t.height
	},
	_getMapWidth: function() {
		return this._mapSize.width
	},
	_setMapWidth: function(t) {
		this._mapSize.width = t
	},
	_getMapHeight: function() {
		return this._mapSize.height
	},
	_setMapHeight: function(t) {
		this._mapSize.height = t
	},
	getTileSize: function() {
		return cc.size(this._tileSize.width, this._tileSize.height)
	},
	setTileSize: function(t) {
		this._tileSize.width = t.width;
		this._tileSize.height = t.height
	},
	_getTileWidth: function() {
		return this._tileSize.width
	},
	_setTileWidth: function(t) {
		this._tileSize.width = t
	},
	_getTileHeight: function() {
		return this._tileSize.height
	},
	_setTileHeight: function(t) {
		this._tileSize.height = t
	},
	getLayers: function() {
		return this._layers
	},
	setLayers: function(t) {
		this._layers.push(t)
	},
	getTilesets: function() {
		return this._tilesets
	},
	setTilesets: function(t) {
		this._tilesets.push(t)
	},
	getObjectGroups: function() {
		return this._objectGroups
	},
	setObjectGroups: function(t) {
		this._objectGroups.push(t)
	},
	getParentElement: function() {
		return this.parentElement
	},
	setParentElement: function(t) {
		this.parentElement = t
	},
	getParentGID: function() {
		return this.parentGID
	},
	setParentGID: function(t) {
		this.parentGID = t
	},
	getLayerAttribs: function() {
		return this.layerAttrs
	},
	setLayerAttribs: function(t) {
		this.layerAttrs = t
	},
	getStoringCharacters: function() {
		return this.storingCharacters
	},
	setStoringCharacters: function(t) {
		this.storingCharacters = t
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(t) {
		this.properties = t
	},
	initWithTMXFile: function(t) {
		this._internalInit(t, null);
		return this.parseXMLFile(t)
	},
	initWithXML: function(t, e) {
		this._internalInit(null, e);
		return this.parseXMLString(t)
	},
	parseXMLFile: function(t, e) {
		var i = (e = e || !1) ? t : cc.loader.getRes(t);
		if (!i) throw "Please load the resource first : " + t;
		var n, r, i = this._parseXML(i).documentElement;
		n = i.getAttribute("version");
		r = i.getAttribute("orientation");
		if ("map" == i.nodeName && ("1.0" != n && null !== n && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + n), "orthogonal" == r ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" == r ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" == r ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== r && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + r), n = cc.size(0, 0), n.width = parseFloat(i.getAttribute("width")), n.height = parseFloat(i.getAttribute("height")), this.setMapSize(n), n = cc.size(0, 0), n.width = parseFloat(i.getAttribute("tilewidth")), n.height = parseFloat(i.getAttribute("tileheight")), this.setTileSize(n), r = i.querySelectorAll("map > properties >  property"))) {
			var c = {};
			for (n = 0; n < r.length; n++) c[r[n].getAttribute("name")] = r[n].getAttribute("value");
			this.properties = c
		}
		c = i.getElementsByTagName("tileset");
		"map" !== i.nodeName && (c = [], c.push(i));
		for (n = 0; n < c.length; n++) {
			r = c[n];
			var s = r.getAttribute("source");
			if (s) r = e ? cc.path.join(this._resources, s) : cc.path.changeBasename(t, s), this.parseXMLFile(r);
			else {
				s = new cc.TMXTilesetInfo;
				s.name = r.getAttribute("name") || "";
				s.firstGid = parseInt(r.getAttribute("firstgid")) || 0;
				s.spacing = parseInt(r.getAttribute("spacing")) || 0;
				s.margin = parseInt(r.getAttribute("margin")) || 0;
				var o = cc.size(0, 0);
				o.width = parseFloat(r.getAttribute("tilewidth"));
				o.height = parseFloat(r.getAttribute("tileheight"));
				s._tileSize = o;
				var o = r.getElementsByTagName("image")[0].getAttribute("source"),
					a = -1;
				this.tmxFileName && (a = this.tmxFileName.lastIndexOf("/")); - 1 !== a ? (a = this.tmxFileName.substr(0, a + 1), s.sourceImage = a + o) : s.sourceImage = this._resources + (this._resources ? "/" : "") + o;
				this.setTilesets(s);
				if (o = r.getElementsByTagName("tile")) for (a = 0; a < o.length; a++) {
					r = o[a];
					this.parentGID = parseInt(s.firstGid) + parseInt(r.getAttribute("id") || 0);
					var h = r.querySelectorAll("properties > property");
					if (h) {
						var l = {};
						for (r = 0; r < h.length; r++) {
							var u = h[r].getAttribute("name");
							l[u] = h[r].getAttribute("value")
						}
						this._tileProperties[this.parentGID] = l
					}
				}
			}
		}
		if (c = i.getElementsByTagName("layer")) for (n = 0; n < c.length; n++) {
			o = c[n];
			a = o.getElementsByTagName("data")[0];
			s = new cc.TMXLayerInfo;
			s.name = o.getAttribute("name");
			r = cc.size(0, 0);
			r.width = parseFloat(o.getAttribute("width"));
			r.height = parseFloat(o.getAttribute("height"));
			s._layerSize = r;
			r = o.getAttribute("visible");
			s.visible = "0" != r;
			r = o.getAttribute("opacity") || 1;
			s._opacity = r ? parseInt(255 * parseFloat(r)) : 255;
			s.offset = cc.p(parseFloat(o.getAttribute("x")) || 0, parseFloat(o.getAttribute("y")) || 0);
			h = "";
			for (r = 0; r < a.childNodes.length; r++) h += a.childNodes[r].nodeValue;
			h = h.trim();
			r = a.getAttribute("compression");
			l = a.getAttribute("encoding");
			if (r && "gzip" !== r && "zlib" !== r) return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
			switch (r) {
			case "gzip":
				s._tiles = cc.unzipBase64AsArray(h, 4);
				break;
			case "zlib":
				r = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(h, 1));
				s._tiles = cc.uint8ArrayToUint32Array(r.decompress());
				break;
			case null:
			case "":
				if ("base64" == l) s._tiles = cc.Codec.Base64.decodeAsArray(h, 4);
				else if ("csv" === l) {
					s._tiles = [];
					r = h.split(",");
					for (a = 0; a < r.length; a++) s._tiles.push(parseInt(r[a]))
				} else {
					r = a.getElementsByTagName("tile");
					s._tiles = [];
					for (a = 0; a < r.length; a++) s._tiles.push(parseInt(r[a].getAttribute("gid")))
				}
				break;
			default:
				this.layerAttrs == cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
			}
			if (o = o.querySelectorAll("properties > property")) {
				a = {};
				for (r = 0; r < o.length; r++) a[o[r].getAttribute("name")] = o[r].getAttribute("value");
				s.properties = a
			}
			this.setLayers(s)
		}
		if (c = i.getElementsByTagName("objectgroup")) for (n = 0; n < c.length; n++) {
			o = c[n];
			s = new cc.TMXObjectGroup;
			s.groupName = o.getAttribute("name");
			s.setPositionOffset(cc.p(parseFloat(o.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(o.getAttribute("y")) * this.getTileSize().height || 0));
			if (a = o.querySelectorAll("objectgroup > properties > property")) for (r = 0; r < a.length; r++) h = {}, h[a[r].getAttribute("name")] = a[r].getAttribute("value"), s.properties = h;
			if (o = o.querySelectorAll("object")) for (r = 0; r < o.length; r++) {
				h = o[r];
				a = {};
				a.name = h.getAttribute("name") || "";
				a.type = h.getAttribute("type") || "";
				a.x = parseInt(h.getAttribute("x") || 0) + s.getPositionOffset().x;
				l = parseInt(h.getAttribute("y") || 0) + s.getPositionOffset().y;
				a.width = parseInt(h.getAttribute("width")) || 0;
				a.height = parseInt(h.getAttribute("height")) || 0;
				a.y = parseInt(this.getMapSize().height * this.getTileSize().height) - l - a.height;
				a.rotation = parseInt(h.getAttribute("rotation")) || 0;
				if (l = h.querySelectorAll("properties > property")) for (u = 0; u < l.length; u++) a[l[u].getAttribute("name")] = l[u].getAttribute("value");
				if ((l = h.querySelectorAll("polygon")) && 0 < l.length)(l = l[0].getAttribute("points")) && (a.polygonPoints = this._parsePointsString(l));
				if ((h = h.querySelectorAll("polyline")) && 0 < h.length)(h = h[0].getAttribute("points")) && (a.polylinePoints = this._parsePointsString(h));
				s.setObjects(a)
			}
			this.setObjectGroups(s)
		}
		return i
	},
	_parsePointsString: function(t) {
		if (!t) return null;
		var e = [];
		t = t.split(" ");
		for (var i = 0; i < t.length; i++) {
			var n = t[i].split(",");
			e.push({
				x: n[0],
				y: n[1]
			})
		}
		return e
	},
	parseXMLString: function(t) {
		return this.parseXMLFile(t, !0)
	},
	getTileProperties: function() {
		return this._tileProperties
	},
	setTileProperties: function(t) {
		this._tileProperties.push(t)
	},
	getCurrentString: function() {
		return this.currentString
	},
	setCurrentString: function(t) {
		this.currentString = t
	},
	getTMXFileName: function() {
		return this.tmxFileName
	},
	setTMXFileName: function(t) {
		this.tmxFileName = t
	},
	_internalInit: function(t, e) {
		this._tilesets.length = 0;
		this._layers.length = 0;
		this.tmxFileName = t;
		e && (this._resources = e);
		this._objectGroups.length = 0;
		this.properties.length = 0;
		this._tileProperties.length = 0;
		this.currentString = "";
		this.storingCharacters = !1;
		this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
		this.parentElement = cc.TMX_PROPERTY_NONE;
		this._currentFirstGID = 0
	}
});
_p = cc.TMXMapInfo.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXMapInfo.create = function(t, e) {
	return new cc.TMXMapInfo(t, e)
};
cc.loader.register(["tmx", "tsx"], cc._txtLoader);
cc.TMXLayerInfo.ATTRIB_NONE = 1;
cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
cc.TMXLayerInfo.ATTRIB_GZIP = 4;
cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
cc.TMXObjectGroup = cc.Class.extend({
	properties: null,
	groupName: "",
	_positionOffset: null,
	_objects: null,
	ctor: function() {
		this.groupName = "";
		this._positionOffset = cc.p(0, 0);
		this.properties = [];
		this._objects = []
	},
	getPositionOffset: function() {
		return cc.p(this._positionOffset)
	},
	setPositionOffset: function(t) {
		this._positionOffset.x = t.x;
		this._positionOffset.y = t.y
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(t) {
		this.properties.push(t)
	},
	getGroupName: function() {
		return this.groupName.toString()
	},
	setGroupName: function(t) {
		this.groupName = t
	},
	propertyNamed: function(t) {
		return this.properties[t]
	},
	objectNamed: function(t) {
		if (this._objects && 0 < this._objects.length) for (var e = this._objects, i = 0, n = e.length; i < n; i++) {
			var r = e[i].name;
			if (r && r == t) return e[i]
		}
		return null
	},
	getObjects: function() {
		return this._objects
	},
	setObjects: function(t) {
		this._objects.push(t)
	}
});
cc.TMXLayer = cc.SpriteBatchNode.extend({
	tiles: null,
	tileset: null,
	layerOrientation: null,
	properties: null,
	layerName: "",
	_layerSize: null,
	_mapTileSize: null,
	_opacity: 255,
	_minGID: null,
	_maxGID: null,
	_vertexZvalue: null,
	_useAutomaticVertexZ: null,
	_reusedTile: null,
	_atlasIndexArray: null,
	_contentScaleFactor: null,
	_className: "TMXLayer",
	ctor: function(t, e, i) {
		cc.SpriteBatchNode.prototype.ctor.call(this);
		this._descendants = [];
		this._layerSize = cc.size(0, 0);
		this._mapTileSize = cc.size(0, 0);
		void 0 !== i && this.initWithTilesetInfo(t, e, i)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.TMXLayer.CanvasRenderCmd(this) : new cc.TMXLayer.WebGLRenderCmd(this)
	},
	setContentSize: function(t, e) {
		cc.Node.prototype.setContentSize.call(this, t, e);
		this._renderCmd._updateCacheContext(t, e)
	},
	getTexture: function() {
		return this._renderCmd.getTexture()
	},
	getLayerSize: function() {
		return cc.size(this._layerSize.width, this._layerSize.height)
	},
	setLayerSize: function(t) {
		this._layerSize.width = t.width;
		this._layerSize.height = t.height
	},
	_getLayerWidth: function() {
		return this._layerSize.width
	},
	_setLayerWidth: function(t) {
		this._layerSize.width = t
	},
	_getLayerHeight: function() {
		return this._layerSize.height
	},
	_setLayerHeight: function(t) {
		this._layerSize.height = t
	},
	getMapTileSize: function() {
		return cc.size(this._mapTileSize.width, this._mapTileSize.height)
	},
	setMapTileSize: function(t) {
		this._mapTileSize.width = t.width;
		this._mapTileSize.height = t.height
	},
	_getTileWidth: function() {
		return this._mapTileSize.width
	},
	_setTileWidth: function(t) {
		this._mapTileSize.width = t
	},
	_getTileHeight: function() {
		return this._mapTileSize.height
	},
	_setTileHeight: function(t) {
		this._mapTileSize.height = t
	},
	getTiles: function() {
		return this.tiles
	},
	setTiles: function(t) {
		this.tiles = t
	},
	getTileset: function() {
		return this.tileset
	},
	setTileset: function(t) {
		this.tileset = t
	},
	getLayerOrientation: function() {
		return this.layerOrientation
	},
	setLayerOrientation: function(t) {
		this.layerOrientation = t
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(t) {
		this.properties = t
	},
	initWithTilesetInfo: function(t, e, i) {
		var n = e._layerSize,
			r = .35 * parseInt(n.width * n.height) + 1,
			c;
		t && (c = cc.textureCache.addImage(t.sourceImage));
		return this.initWithTexture(c, r) ? (this.layerName = e.name, this._layerSize = n, this.tiles = e._tiles, this._minGID = e._minGID, this._maxGID = e._maxGID, this._opacity = e._opacity, this.properties = e.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = t, this._mapTileSize = i.getTileSize(), this.layerOrientation = i.orientation, t = this._calculateLayerOffset(e.offset), this.setPosition(cc.pointPixelsToPoints(t)), this._atlasIndexArray = [], this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0) : !1
	},
	releaseMap: function() {
		this.tiles && (this.tiles = null);
		this._atlasIndexArray && (this._atlasIndexArray = null)
	},
	getTileAt: function(t, e) {
		if (!t) throw "cc.TMXLayer.getTileAt(): pos should be non-null";
		void 0 !== e && (t = cc.p(t, e));
		if (t.x >= this._layerSize.width || t.y >= this._layerSize.height || 0 > t.x || 0 > t.y) throw "cc.TMXLayer.getTileAt(): invalid position";
		if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
		var i = null,
			n = this.getTileGIDAt(t);
		if (0 === n) return i;
		var r = 0 | t.x + t.y * this._layerSize.width,
			i = this.getChildByTag(r);
		i || (n = this.tileset.rectForGID(n), n = cc.rectPixelsToPoints(n), i = new cc.Sprite, i.initWithTexture(this.texture, n), i.batchNode = this, i.setPosition(this.getPositionAt(t)), i.vertexZ = this._vertexZForPos(t), i.anchorX = 0, i.anchorY = 0, i.opacity = this._opacity, n = this._atlasIndexForExistantZ(r), this.addSpriteWithoutQuad(i, n, r));
		return i
	},
	getTileGIDAt: function(t, e) {
		if (!t) throw "cc.TMXLayer.getTileGIDAt(): pos should be non-null";
		void 0 !== e && (t = cc.p(t, e));
		if (t.x >= this._layerSize.width || t.y >= this._layerSize.height || 0 > t.x || 0 > t.y) throw "cc.TMXLayer.getTileGIDAt(): invalid position";
		return !this.tiles || !this._atlasIndexArray ? (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null) : (this.tiles[0 | t.x + t.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK) >>> 0
	},
	getTileFlagsAt: function(t, e) {
		if (!t) throw "cc.TMXLayer.getTileFlagsAt(): pos should be non-null";
		void 0 !== e && (t = cc.p(t, e));
		if (t.x >= this._layerSize.width || t.y >= this._layerSize.height || 0 > t.x || 0 > t.y) throw "cc.TMXLayer.getTileFlagsAt(): invalid position";
		return !this.tiles || !this._atlasIndexArray ? (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"), null) : (this.tiles[0 | t.x + t.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL) >>> 0
	},
	setTileGID: function(t, e, i, n) {
		if (!e) throw "cc.TMXLayer.setTileGID(): pos should be non-null";
		void 0 !== n ? e = cc.p(e, i) : n = i;
		if (e.x >= this._layerSize.width || e.y >= this._layerSize.height || 0 > e.x || 0 > e.y) throw "cc.TMXLayer.setTileGID(): invalid position";
		if (!this.tiles || !this._atlasIndexArray) cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released");
		else if (0 !== t && t < this.tileset.firstGid) cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + t);
		else {
			n = n || 0;
			this._setNodeDirtyForCache();
			i = this.getTileFlagsAt(e);
			var r = this.getTileGIDAt(e);
			if (r != t || i != n) if (i = (t | n) >>> 0, 0 === t) this.removeTileAt(e);
			else if (0 === r) this._insertTileForGID(i, e);
			else {
				var r = e.x + e.y * this._layerSize.width,
					c = this.getChildByTag(r);
				c ? (t = this.tileset.rectForGID(t), t = cc.rectPixelsToPoints(t), c.setTextureRect(t, !1), null != n && this._setupTileSprite(c, e, i), this.tiles[r] = i) : this._updateTileForGID(i, e)
			}
		}
	},
	removeTileAt: function(t, e) {
		if (!t) throw "cc.TMXLayer.removeTileAt(): pos should be non-null";
		void 0 !== e && (t = cc.p(t, e));
		if (t.x >= this._layerSize.width || t.y >= this._layerSize.height || 0 > t.x || 0 > t.y) throw "cc.TMXLayer.removeTileAt(): invalid position";
		if (!this.tiles || !this._atlasIndexArray) cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released");
		else if (0 !== this.getTileGIDAt(t)) {
			cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
			var i = 0 | t.x + t.y * this._layerSize.width,
				n = this._atlasIndexForExistantZ(i);
			this.tiles[i] = 0;
			this._atlasIndexArray.splice(n, 1);
			if (i = this.getChildByTag(i)) cc.SpriteBatchNode.prototype.removeChild.call(this, i, !0);
			else if (cc._renderType === cc._RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(n), this._children) for (var i = this._children, r = 0, c = i.length; r < c; r++) {
				var s = i[r];
				if (s) {
					var o = s.atlasIndex;
					o >= n && (s.atlasIndex = o - 1)
				}
			}
		}
	},
	getPositionAt: function(t, e) {
		void 0 !== e && (t = cc.p(t, e));
		var i = cc.p(0, 0);
		switch (this.layerOrientation) {
		case cc.TMX_ORIENTATION_ORTHO:
			i = this._positionForOrthoAt(t);
			break;
		case cc.TMX_ORIENTATION_ISO:
			i = this._positionForIsoAt(t);
			break;
		case cc.TMX_ORIENTATION_HEX:
			i = this._positionForHexAt(t)
		}
		return cc.pointPixelsToPoints(i)
	},
	getProperty: function(t) {
		return this.properties[t]
	},
	setupTiles: function() {
		this._renderCmd.initImageSize();
		this._parseInternalProperties();
		cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
		for (var t = this._layerSize.height, e = this._layerSize.width, i = 0; i < t; i++) for (var n = 0; n < e; n++) {
			var r = this.tiles[n + e * i];
			0 !== r && (this._appendTileForGID(r, cc.p(n, i)), this._minGID = Math.min(r, this._minGID), this._maxGID = Math.max(r, this._maxGID))
		}
		this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
	},
	addChild: function(t, e, i) {
		cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
	},
	removeChild: function(t, e) {
		if (t) if (-1 === this._children.indexOf(t)) cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
		else {
			cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
			var i = t.atlasIndex;
			this.tiles[this._atlasIndexArray[i]] = 0;
			this._atlasIndexArray.splice(i, 1);
			cc.SpriteBatchNode.prototype.removeChild.call(this, t, e);
			cc.renderer.childrenOrderDirty = !0
		}
	},
	getLayerName: function() {
		return this.layerName
	},
	setLayerName: function(t) {
		this.layerName = t
	},
	_positionForIsoAt: function(t) {
		return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + t.x - t.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - t.x - t.y - 2))
	},
	_positionForOrthoAt: function(t) {
		return cc.p(t.x * this._mapTileSize.width, (this._layerSize.height - t.y - 1) * this._mapTileSize.height)
	},
	_positionForHexAt: function(t) {
		return cc.p(3 * t.x * this._mapTileSize.width / 4, (this._layerSize.height - t.y - 1) * this._mapTileSize.height + (1 == t.x % 2 ? -this._mapTileSize.height / 2 : 0))
	},
	_calculateLayerOffset: function(t) {
		var e = cc.p(0, 0);
		switch (this.layerOrientation) {
		case cc.TMX_ORIENTATION_ORTHO:
			e = cc.p(t.x * this._mapTileSize.width, -t.y * this._mapTileSize.height);
			break;
		case cc.TMX_ORIENTATION_ISO:
			e = cc.p(this._mapTileSize.width / 2 * (t.x - t.y), this._mapTileSize.height / 2 * (-t.x - t.y));
			break;
		case cc.TMX_ORIENTATION_HEX:
			(0 !== t.x || 0 !== t.y) && cc.log("offset for hexagonal map not implemented yet")
		}
		return e
	},
	_appendTileForGID: function(t, e) {
		var i = this.tileset.rectForGID(t),
			i = cc.rectPixelsToPoints(i),
			n = 0 | e.x + e.y * this._layerSize.width,
			i = this._renderCmd._reusedTileWithRect(i);
		this._setupTileSprite(i, e, t);
		var r = this._atlasIndexArray.length;
		this.insertQuadFromSprite(i, r);
		this._atlasIndexArray.splice(r, 0, n);
		return i
	},
	_insertTileForGID: function(t, e) {
		var i = this.tileset.rectForGID(t),
			i = cc.rectPixelsToPoints(i),
			n = 0 | e.x + e.y * this._layerSize.width,
			i = this._renderCmd._reusedTileWithRect(i);
		this._setupTileSprite(i, e, t);
		var r = this._atlasIndexForNewZ(n);
		this.insertQuadFromSprite(i, r);
		this._atlasIndexArray.splice(r, 0, n);
		if (this._children) for (var c = this._children, s = 0, o = c.length; s < o; s++) {
			var a = c[s];
			if (a) {
				var h = a.atlasIndex;
				h >= r && (a.atlasIndex = h + 1)
			}
		}
		this.tiles[n] = t;
		return i
	},
	_updateTileForGID: function(t, e) {
		var i = this.tileset.rectForGID(t),
			n = this._contentScaleFactor,
			i = cc.rect(i.x / n, i.y / n, i.width / n, i.height / n),
			n = e.x + e.y * this._layerSize.width,
			i = this._renderCmd._reusedTileWithRect(i);
		this._setupTileSprite(i, e, t);
		i.atlasIndex = this._atlasIndexForExistantZ(n);
		i.dirty = !0;
		i.updateTransform();
		this.tiles[n] = t;
		return i
	},
	_parseInternalProperties: function() {
		var t = this.getProperty("cc_vertexz");
		if (t) if ("automatic" == t) {
			this._useAutomaticVertexZ = !0;
			var e = this.getProperty("cc_alpha_func"),
				t = 0;
			e && (t = parseFloat(e));
			cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), e = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(e, t))
		} else this._vertexZvalue = parseInt(t, 10)
	},
	_setupTileSprite: function(t, e, i) {
		var n = e.x + e.y * this._layerSize.width;
		t.setPosition(this.getPositionAt(e));
		cc._renderType === cc._RENDER_TYPE_WEBGL ? t.vertexZ = this._vertexZForPos(e) : t.tag = n;
		t.anchorX = 0;
		t.anchorY = 0;
		t.opacity = this._opacity;
		cc._renderType === cc._RENDER_TYPE_WEBGL && (t.rotation = 0);
		t.setFlippedX(!1);
		t.setFlippedY(!1);
		(i & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0 ? (t.anchorX = .5, t.anchorY = .5, t.x = this.getPositionAt(e).x + t.width / 2, t.y = this.getPositionAt(e).y + t.height / 2, e = (i & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0, e == cc.TMX_TILE_HORIZONTAL_FLAG ? t.rotation = 90 : e == cc.TMX_TILE_VERTICAL_FLAG ? t.rotation = 270 : (t.rotation = e == (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? 90 : 270, t.setFlippedX(!0))) : ((i & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && t.setFlippedX(!0), (i & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && t.setFlippedY(!0))
	},
	_vertexZForPos: function(t) {
		var e = 0,
			i = 0;
		if (this._useAutomaticVertexZ) switch (this.layerOrientation) {
		case cc.TMX_ORIENTATION_ISO:
			i = this._layerSize.width + this._layerSize.height;
			e = -(i - (t.x + t.y));
			break;
		case cc.TMX_ORIENTATION_ORTHO:
			e = -(this._layerSize.height - t.y);
			break;
		case cc.TMX_ORIENTATION_HEX:
			cc.log("TMX Hexa zOrder not supported");
			break;
		default:
			cc.log("TMX invalid value")
		} else e = this._vertexZvalue;
		return e
	},
	_atlasIndexForExistantZ: function(t) {
		var e;
		if (this._atlasIndexArray) for (var i = this._atlasIndexArray, n = 0, r = i.length; n < r && !(e = i[n], e == t); n++);
		cc.isNumber(e) || cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
		return n
	},
	_atlasIndexForNewZ: function(t) {
		for (var e = this._atlasIndexArray, i = 0, n = e.length; i < n && !(t < e[i]); i++);
		return i
	}
});
_p = cc.TMXLayer.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXLayer.create = function(t, e, i) {
	return new cc.TMXLayer(t, e, i)
};
(function() {
	cc.TMXLayer.CanvasRenderCmd = function(t) {
		cc.SpriteBatchNode.CanvasRenderCmd.call(this, t);
		this._needDraw = !0;
		this._childrenRenderCmds = [];
		var e = cc._canvas;
		t = cc.newElement("canvas");
		t.width = e.width;
		t.height = e.height;
		this._cacheCanvas = t;
		this._cacheContext = this._cacheCanvas.getContext("2d");
		e = new cc.Texture2D;
		e.initWithElement(t);
		e.handleLoadedTexture();
		this._cacheTexture = e;
		this._cacheDirty = !1
	};
	var t = cc.TMXLayer.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
	t.constructor = cc.TMXLayer.CanvasRenderCmd;
	t._copyRendererCmds = function(t) {
		if (t) for (var e = this._childrenRenderCmds, i = e.length = 0, n = t.length; i < n; i++) e[i] = t[i]
	};
	t._setNodeDirtyForCache = function() {
		this._cacheDirty = !0
	};
	t._renderingChildToCache = function(t, e) {
		if (this._cacheDirty) {
			var i = this._childrenRenderCmds,
				n = this._cacheContext,
				r = this._cacheCanvas;
			n.save();
			n.clearRect(0, 0, r.width, -r.height);
			r = cc.affineTransformInvert(this._worldTransform);
			n.transform(r.a, r.c, r.b, r.d, r.tx * t, -r.ty * e);
			for (var r = 0, c = i.length; r < c; r++) i[r].rendering(n, t, e), i[r]._cacheDirty = !1;
			n.restore();
			this._cacheDirty = !1
		}
	};
	t.rendering = function(t, e, i) {
		var n = this._node,
			r = this._displayedOpacity / 255;
		if (!(0 >= r)) {
			this._renderingChildToCache(e, i);
			t = t || cc._renderContext;
			t.globalAlpha = r;
			var r = 0 | -this._anchorPointInPoints.x,
				c = 0 | -this._anchorPointInPoints.y,
				s = this._cacheCanvas,
				o = this._worldTransform;
			s && (0 !== s.width && 0 !== s.height) && (t.save(), t.transform(o.a, o.c, o.b, o.d, o.tx * e, -o.ty * i), o = s.height * i, n.layerOrientation === cc.TMX_ORIENTATION_HEX ? t.drawImage(s, 0, 0, s.width, s.height, r, -(c + o) + .5 * n._mapTileSize.height * i, s.width * e, o) : t.drawImage(s, 0, 0, s.width, s.height, r, -(c + o), s.width * e, o), t.restore());
			cc.g_NumberOfDraws++
		}
	};
	t._updateCacheContext = function(t, e) {
		var i = this._node,
			n = i._contentSize,
			r = this._cacheCanvas,
			c = cc.contentScaleFactor();
		r.width = 0 | 1.5 * n.width * c;
		r.height = 0 | 1.5 * n.height * c;
		i.layerOrientation === cc.TMX_ORIENTATION_HEX ? this._cacheContext.translate(0, r.height - .5 * i._mapTileSize.height) : this._cacheContext.translate(0, r.height);
		i = this._cacheTexture._contentSize;
		i.width = r.width;
		i.height = r.height
	};
	t.getTexture = function() {
		return this._cacheTexture
	};
	t.visit = function(t) {
		var e = this._node,
			i, n = e._children;
		if (e._visible && n && 0 !== n.length) {
			if (t = t || this.getParentRenderCmd()) this._curLevel = t._curLevel + 1;
			this._syncStatus(t);
			if (this._cacheDirty) {
				t = this._cacheContext;
				var r = this._cacheCanvas,
					c = cc.view,
					s = e.__instanceId,
					o = cc.renderer;
				o._turnToCacheMode(s);
				e.sortAllChildren();
				e = 0;
				for (i = n.length; e < i; e++) if (n[e]) {
					var a = n[e]._renderCmd;
					a && (a.visit(this), a._cacheDirty = !1)
				}
				this._copyRendererCmds(o._cacheToCanvasCmds[s]);
				t.save();
				t.clearRect(0, 0, r.width, -r.height);
				n = cc.affineTransformInvert(this._worldTransform);
				t.transform(n.a, n.c, n.b, n.d, n.tx * c.getScaleX(), -n.ty * c.getScaleY());
				o._renderingToCacheCanvas(t, s);
				t.restore();
				this._cacheDirty = !1
			}
			cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0
		}
	};
	t.initImageSize = function() {
		this._node.tileset.imageSize = this._originalTexture.getContentSizeInPixels()
	};
	t._reusedTileWithRect = function(t) {
		var e = this._node;
		e._reusedTile = new cc.Sprite;
		e._reusedTile.initWithTexture(e._renderCmd._texture, t, !1);
		e._reusedTile.batchNode = e;
		e._reusedTile.parent = e;
		e._reusedTile._renderCmd._cachedParent = e._renderCmd;
		return e._reusedTile
	}
})();
(function() {
	cc.TMXLayer.WebGLRenderCmd = function(t) {
		cc.SpriteBatchNode.WebGLRenderCmd.call(this, t);
		this._needDraw = !0
	};
	var t = cc.TMXLayer.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
	t.constructor = cc.TMXLayer.WebGLRenderCmd;
	t._updateCacheContext = function() {};
	t.initImageSize = function() {
		this._node.tileset.imageSize = this._textureAtlas.texture.getContentSizeInPixels();
		this._textureAtlas.texture.setAliasTexParameters()
	};
	t._reusedTileWithRect = function(t) {
		var e = this._node;
		e._reusedTile ? (e._reusedTile.batchNode = null, e._reusedTile.setTextureRect(t, !1)) : (e._reusedTile = new cc.Sprite, e._reusedTile.initWithTexture(e.texture, t, !1));
		e._reusedTile.batchNode = e;
		return e._reusedTile
	}
})();
cc.PointObject = cc.Class.extend({
	_ratio: null,
	_offset: null,
	_child: null,
	ctor: function(t, e) {
		this.initWithCCPoint(t, e)
	},
	getRatio: function() {
		return this._ratio
	},
	setRatio: function(t) {
		this._ratio = t
	},
	getOffset: function() {
		return this._offset
	},
	setOffset: function(t) {
		this._offset = t
	},
	getChild: function() {
		return this._child
	},
	setChild: function(t) {
		this._child = t
	},
	initWithCCPoint: function(t, e) {
		this._ratio = t;
		this._offset = e;
		this._child = null;
		return !0
	}
});
cc.PointObject.create = function(t, e) {
	return new cc.PointObject(t, e)
};
cc.ParallaxNode = cc.Node.extend({
	parallaxArray: null,
	_lastPosition: null,
	_className: "ParallaxNode",
	getParallaxArray: function() {
		return this.parallaxArray
	},
	setParallaxArray: function(t) {
		this.parallaxArray = t
	},
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		this.parallaxArray = [];
		this._lastPosition = cc.p(-100, -100)
	},
	addChild: function(t, e, i, n) {
		if (3 === arguments.length) cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
		else {
			if (!t) throw "cc.ParallaxNode.addChild(): child should be non-null";
			var r = new cc.PointObject(i, n);
			r.setChild(t);
			this.parallaxArray.push(r);
			t.setPosition(this._position.x * i.x + n.x, this._position.y * i.y + n.y);
			cc.Node.prototype.addChild.call(this, t, e, t.tag)
		}
	},
	removeChild: function(t, e) {
		for (var i = this.parallaxArray, n = 0; n < i.length; n++) if (i[n].getChild() == t) {
			i.splice(n, 1);
			break
		}
		cc.Node.prototype.removeChild.call(this, t, e)
	},
	removeAllChildren: function(t) {
		this.parallaxArray.length = 0;
		cc.Node.prototype.removeAllChildren.call(this, t)
	},
	_updateParallaxPosition: function() {
		var t = this._absolutePosition();
		if (!cc.pointEqualToPoint(t, this._lastPosition)) {
			for (var e = this.parallaxArray, i = 0, n = e.length; i < n; i++) {
				var r = e[i];
				r.getChild().setPosition(-t.x + t.x * r.getRatio().x + r.getOffset().x, -t.y + t.y * r.getRatio().y + r.getOffset().y)
			}
			this._lastPosition = t
		}
	},
	_absolutePosition: function() {
		for (var t = this._position, e = this; null != e.parent;) e = e.parent, t = cc.pAdd(t, e.getPosition());
		return t
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParallaxNode.CanvasRenderCmd(this) : new cc.ParallaxNode.WebGLRenderCmd(this)
	}
});
cc.ParallaxNode.create = function() {
	return new cc.ParallaxNode
};
(function() {
	cc.ParallaxNode.CanvasRenderCmd = function(t) {
		cc.Node.CanvasRenderCmd.call(this, t);
		this._needDraw = !1
	};
	var t = cc.ParallaxNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	t.constructor = cc.ParallaxNode.CanvasRenderCmd;
	t.updateStatus = function() {
		this._node._updateParallaxPosition();
		cc.Node.CanvasRenderCmd.prototype.updateStatus.call(this)
	};
	t._syncStatus = function(t) {
		this._node._updateParallaxPosition();
		cc.Node.CanvasRenderCmd.prototype._syncStatus.call(this, t)
	}
})();
(function() {
	if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
		cc.ParallaxNode.WebGLRenderCmd = function(t) {
			cc.Node.WebGLRenderCmd.call(this, t);
			this._needDraw = !1
		};
		var t = cc.ParallaxNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
		t.constructor = cc.ParallaxNode.WebGLRenderCmd;
		t.updateStatus = function() {
			this._node._updateParallaxPosition();
			cc.Node.WebGLRenderCmd.prototype.updateStatus.call(this)
		};
		t._syncStatus = function(t) {
			this._node._updateParallaxPosition();
			cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this, t)
		}
	}
})();
(function() {
	var t = cc.sys,
		e = {
			common: {
				multichannel: !0,
				webAudio: cc.sys._supportWebAudio,
				auto: !0
			}
		};
	e[t.BROWSER_TYPE_ANDROID] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1
	};
	e[t.BROWSER_TYPE_CHROME] = {
		multichannel: !0,
		webAudio: !0,
		auto: !1
	};
	e[t.BROWSER_TYPE_FIREFOX] = {
		multichannel: !0,
		webAudio: !0,
		auto: !0
	};
	e[t.BROWSER_TYPE_BAIDU] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	e[t.BROWSER_TYPE_UC] = {
		multichannel: !0,
		webAudio: !1,
		auto: !0
	};
	e[t.BROWSER_TYPE_QQ] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	e[t.BROWSER_TYPE_OUPENG] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1
	};
	e[t.BROWSER_TYPE_WECHAT] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1
	};
	e[t.BROWSER_TYPE_360] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	e[t.BROWSER_TYPE_MIUI] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	e[t.BROWSER_TYPE_SAFARI] = {
		multichannel: !0,
		webAudio: !0,
		auto: !1
	};
	var i, n;
	try {
		var r = navigator.userAgent.toLowerCase();
		switch (t.browserType) {
		case t.BROWSER_TYPE_IE:
			n = r.match(/(msie |rv:)([\d.]+)/);
			break;
		case t.BROWSER_TYPE_FIREFOX:
			n = r.match(/(firefox\/|rv:)([\d.]+)/);
			break;
		case t.BROWSER_TYPE_CHROME:
			n = r.match(/chrome\/([\d.]+)/);
			break;
		case t.BROWSER_TYPE_BAIDU:
			n = r.match(/baidubrowser\/([\d.]+)/);
			break;
		case t.BROWSER_TYPE_UC:
			n = r.match(/ucbrowser\/([\d.]+)/);
			break;
		case t.BROWSER_TYPE_QQ:
			n = r.match(/qqbrowser\/([\d.]+)/);
			break;
		case t.BROWSER_TYPE_OUPENG:
			n = r.match(/oupeng\/([\d.]+)/);
			break;
		case t.BROWSER_TYPE_WECHAT:
			n = r.match(/micromessenger\/([\d.]+)/);
			break;
		case t.BROWSER_TYPE_SAFARI:
			n = r.match(/safari\/([\d.]+)/)
		}
		i = n ? n[1] : ""
	} catch (c) {
		console.log(c)
	}
	if (i) switch (t.browserType) {
	case t.BROWSER_TYPE_CHROME:
		30 > parseInt(i) && (e[t.BROWSER_TYPE_CHROME] = {
			multichannel: !1,
			webAudio: !0,
			auto: !1
		})
	}
	cc.__audioSupport = cc.sys.isMobile ? e[cc.sys.browserType] || e.common : e.common
})();
cc.Audio = cc.Class.extend({
	volume: 1,
	loop: !1,
	src: null,
	_touch: !1,
	_playing: !1,
	_AUDIO_TYPE: "AUDIO",
	_pause: !1,
	_buffer: null,
	_currentSource: null,
	_startTime: null,
	_currentTime: null,
	_context: null,
	_volume: null,
	_element: null,
	ctor: function(t, e, i) {
		t && (this._context = t);
		e && (this._volume = e);
		t && e && (this._AUDIO_TYPE = "WEBAUDIO");
		this.src = i
	},
	_setBufferCallback: null,
	setBuffer: function(t) {
		this._AUDIO_TYPE = "WEBAUDIO";
		this._buffer = t;
		this._playing && this.play();
		this._volume.gain.value = this.volume;
		this._setBufferCallback && this._setBufferCallback(t)
	},
	_setElementCallback: null,
	setElement: function(t) {
		this._AUDIO_TYPE = "AUDIO";
		this._element = t;
		this._playing && this.play();
		t.volume = this.volume;
		t.loop = this.loop;
		this._setElementCallback && this._setElementCallback(t)
	},
	play: function(t, e) {
		this._playing = !0;
		this.loop = void 0 === e ? this.loop : e || !1;
		"AUDIO" === this._AUDIO_TYPE ? this._playOfAudio(t) : this._playOfWebAudio(t)
	},
	getPlaying: function() {
		if (!this._playing) return this._playing;
		if ("AUDIO" === this._AUDIO_TYPE) {
			var t = this._element;
			return !t || this._pause || t.ended ? this._playing = !1 : !0
		}
		t = this._currentSource;
		return !this._playing && !t ? !0 : null == t.playbackState ? this._playing : 3 == t.playbackState
	},
	_playOfWebAudio: function(t) {
		var e = this._currentSource;
		if (this._buffer) {
			if (!this._pause && e) {
				if (this._currentTime + this._context.currentTime - this._startTime < this._currentSource.buffer.duration) return;
				this._stopOfWebAudio()
			}
			e = this._context.createBufferSource();
			e.buffer = this._buffer;
			e.connect(this._volume);
			e.loop = this.loop;
			this._startTime = this._context.currentTime;
			this._currentTime = 0;
			if (e.start) e.start(0, t || 0);
			else if (e.noteGrainOn) {
				var i = e.buffer.duration;
				this.loop ? e.noteGrainOn(0, t, i) : e.noteGrainOn(0, t, i - t)
			} else e.noteOn(0);
			this._currentSource = e;
			var n = this;
			e.onended = function() {
				n._playing = !1
			}
		}
	},
	_playOfAudio: function() {
		var t = this._element;
		t && (t.loop = this.loop, t.play())
	},
	stop: function() {
		this._playing = !1;
		"AUDIO" === this._AUDIO_TYPE ? this._stopOfAudio() : this._stopOfWebAudio()
	},
	_stopOfWebAudio: function() {
		var t = this._currentSource;
		t && (t.stop(0), this._currentSource = null)
	},
	_stopOfAudio: function() {
		var t = this._element;
		t && (t.pause(), t.duration && Infinity != t.duration && (t.currentTime = t.duration))
	},
	pause: function() {
		this._playing = !1;
		this._pause = !0;
		"AUDIO" === this._AUDIO_TYPE ? this._pauseOfAudio() : this._pauseOfWebAudio()
	},
	_pauseOfWebAudio: function() {
		this._currentTime += this._context.currentTime - this._startTime;
		var t = this._currentSource;
		t && t.stop(0)
	},
	_pauseOfAudio: function() {
		var t = this._element;
		t && t.pause()
	},
	resume: function() {
		this._pause && ("AUDIO" === this._AUDIO_TYPE ? this._resumeOfAudio() : this._resumeOfWebAudio(), this._pause = !1, this._playing = !0)
	},
	_resumeOfWebAudio: function() {
		var t = this._currentSource;
		t && (this._startTime = this._context.currentTime, this._playOfWebAudio(this._currentTime % t.buffer.duration))
	},
	_resumeOfAudio: function() {
		var t = this._element;
		t && t.play()
	},
	setVolume: function(t) {
		1 < t && (t = 1);
		0 > t && (t = 0);
		this.volume = t;
		"AUDIO" === this._AUDIO_TYPE ? this._element && (this._element.volume = t) : this._volume && (this._volume.gain.value = t)
	},
	getVolume: function() {
		return this.volume
	},
	cloneNode: function() {
		var t, e;
		if ("AUDIO" === this._AUDIO_TYPE) {
			t = new cc.Audio;
			var i = document.createElement("audio");
			i.src = this.src;
			t.setElement(i)
		} else i = this._context.createGain(), i.gain.value = 1, i.connect(this._context.destination), t = new cc.Audio(this._context, i, this.src), this._buffer ? t.setBuffer(this._buffer) : (e = this, this._setBufferCallback = function(i) {
			t.setBuffer(i);
			e._setBufferCallback = null
		});
		t._AUDIO_TYPE = this._AUDIO_TYPE;
		return t
	}
});
(function(t) {
	var e = t.webAudio,
		i = t.multichannel;
	t = t.auto;
	var n = [];
	(function() {
		var t = document.createElement("audio");
		if (t.canPlayType) {
			var e = t.canPlayType('audio/ogg; codecs="vorbis"');
			e && "" !== e && n.push(".ogg");
			(e = t.canPlayType("audio/mpeg")) && "" !== e && n.push(".mp3");
			(e = t.canPlayType('audio/wav; codecs="1"')) && "" !== e && n.push(".wav");
			(e = t.canPlayType("audio/mp4")) && "" !== e && n.push(".mp4");
			(t = t.canPlayType("audio/x-m4a")) && "" !== t && n.push(".m4a")
		}
	})();
	if (e) var r = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
	var c = {
		cache: {},
		load: function(t, i, s, o) {
			if (0 === n.length) return o("can not support audio!");
			var a = cc.path.extname(t);
			i = [a];
			for (s = 0; s < n.length; s++) a !== n[s] && i.push(n[s]);
			e ? (s = r.createGain(), s.gain.value = 1, s.connect(r.destination), s = new cc.Audio(r, s, t)) : s = new cc.Audio(null, null, t);
			this.loadAudioFromExtList(t, i, s, o);
			c.cache[t] = s
		},
		loadAudioFromExtList: function(t, i, n, s) {
			0 === i.length && s("can not found the resource of audio! Last match url is : " + t);
			t = cc.path.changeExtname(t, i.splice(0, 1));
			if (e) {
				var o = new XMLHttpRequest;
				o.open("GET", t, !0);
				o.responseType = "arraybuffer";
				o.onload = function() {
					r.decodeAudioData(o.response, function(t) {
						n.setBuffer(t);
						s(null, n)
					}, function() {
						c.loadAudioFromExtList(t, i, n, s)
					})
				};
				o.send()
			} else {
				var a = document.createElement("audio");
				a.src = t;
				var h = function() {
						n.setElement(a);
						s(null, n);
						a.removeEventListener("onload", h, !1);
						a.removeEventListener("error", l, !1);
						a.removeEventListener("emptied", l, !1)
					},
					l = function() {
						c.loadAudioFromExtList(t, i, n, s);
						a.removeEventListener("onload", h, !1);
						a.removeEventListener("error", l, !1);
						a.removeEventListener("emptied", l, !1)
					};
				cc._addEventListener(a, "canplaythrough", h, !1);
				cc._addEventListener(a, "error", l, !1);
				cc._addEventListener(a, "emptied", l, !1)
			}
		}
	};
	cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], c);
	cc.audioEngine = {
		_currMusic: null,
		_musicVolume: 1,
		willPlayMusic: function() {
			return !1
		},
		playMusic: function(t, e) {
			var i = this._currMusic;
			i && i.src !== t && i.stop();
			i = c.cache[t];
			i || (cc.loader.load(t), i = c.cache[t]);
			i.play(0, e);
			i.setVolume(this._musicVolume);
			this._currMusic = i
		},
		stopMusic: function(t) {
			var e = this._currMusic;
			e && (e.stop(), t && cc.loader.release(e.src))
		},
		pauseMusic: function() {
			var t = this._currMusic;
			t && t.pause()
		},
		resumeMusic: function() {
			var t = this._currMusic;
			t && t.resume()
		},
		rewindMusic: function() {
			var t = this._currMusic;
			t && (t.stop(), t.play())
		},
		getMusicVolume: function() {
			return this._musicVolume
		},
		setMusicVolume: function(t) {
			this._musicVolume = t;
			var e = this._currMusic;
			e && e.setVolume(t)
		},
		isMusicPlaying: function() {
			var t = this._currMusic;
			return t ? t.getPlaying() : !1
		},
		_audioPool: {},
		_maxAudioInstance: 5,
		_effectVolume: 1,
		playEffect: function(t, n) {
			if (!i) return null;
			var r = this._audioPool[t];
			r || (r = this._audioPool[t] = []);
			var s;
			for (s = 0; s < r.length && r[s].getPlaying(); s++);
			if (r[s]) o = r[s], o.setVolume(this._effectVolume), o.play(0, n);
			else if (!e && s > this._maxAudioInstance) cc.log("Error: %s greater than %d", t, this._maxAudioInstance);
			else {
				var o = c.cache[t];
				o || (cc.loader.load(t), o = c.cache[t]);
				o = o.cloneNode();
				o.setVolume(this._effectVolume);
				o.loop = n || !1;
				o.play();
				r.push(o)
			}
			return o
		},
		setEffectsVolume: function(t) {
			this._effectVolume = t
		},
		getEffectsVolume: function() {
			return this._effectVolume
		},
		pauseEffect: function(t) {
			t && t.pause()
		},
		pauseAllEffects: function() {
			var t = this._audioPool,
				e;
			for (e in t) for (var i = t[e], n = 0; n < t[e].length; n++) i[n].getPlaying() && i[n].pause()
		},
		resumeEffect: function(t) {
			t && t.resume()
		},
		resumeAllEffects: function() {
			var t = this._audioPool,
				e;
			for (e in t) for (var i = t[e], n = 0; n < t[e].length; n++) i[n].resume()
		},
		stopEffect: function(t) {
			t && t.stop()
		},
		stopAllEffects: function() {
			var t = this._audioPool,
				e;
			for (e in t) for (var i = t[e], n = 0; n < t[e].length; n++) i[n].stop()
		},
		unloadEffect: function(t) {
			if (t) {
				cc.loader.release(t);
				var e = this._audioPool[t];
				e && (e.length = 0);
				delete this._audioPool[t];
				delete c.cache[t]
			}
		},
		end: function() {
			this.stopMusic();
			this.stopAllEffects()
		},
		_pauseCache: [],
		_pausePlaying: function() {
			var t = this._currMusic;
			t && t.getPlaying() && (t.pause(), this._pauseCache.push(t));
			var t = this._audioPool,
				e;
			for (e in t) for (var i = t[e], n = 0; n < t[e].length; n++) i[n].getPlaying() && (i[n].pause(), this._pauseCache.push(i[n]))
		},
		_resumePlaying: function() {
			for (var t = this._pauseCache, e = 0; e < t.length; e++) t[e].resume();
			t.length = 0
		}
	};
	if (!t) {
		var s = function() {
				var t = cc.audioEngine._currMusic;
				t && (!1 === t._touch && t._playing) && (t._touch = !0, t.play(0, t.loop))
			};
		setTimeout(function() {
			cc._canvas && cc._canvas.addEventListener("touchstart", s, !1)
		}, 0)
	}
	cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
		cc.audioEngine._pausePlaying()
	});
	cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
		cc.audioEngine._resumePlaying()
	})
})(cc.__audioSupport);
var res = {
	qipafeiji_plist: "js/qipafeiji.plist",
	qipafeiji_plist0: "js/qipafeiji0.plist",
	qipafeiji_png: "images/qipafeiji.png",
	qipafeiji_png0: "images/qipafeiji0.png",
	number2: "images/number2.png",
	number0: "images/number0.png"
},
	g_resources = [],
	i;
for (i in res) g_resources.push(res[i]);
var _imgData = "";
LoaderScene = cc.Scene.extend({
	_label: null,
	_lightNode: null,
	_flag: !1,
	_logoLoaded: !1,
	init: function(t) {
		var e = cc.visibleRect;
		t = new cc.LayerColor(t || cc.color(0, 0, 0, 255));
		t.setPosition(e.bottomLeft);
		this.addChild(t);
		this._label = new cc.LabelTTF("", "Arial", 28);
		this._label.setPosition(e.center.x, e.center.y - 30);
		this.addChild(this._label, 2);
		this._lightNode = null;
		this._logoLoaded = !1;
		cc.loader.loadImg(_imgData, {
			isCrossOrigin: !1
		}, function(t, e) {
			if (t) return this._logoLoaded = !0;
			this._initLogo(e)
		}.bind(this));
		return !0
	},
	_initLogo: function(t) {
		this._logoLoaded = !0;
		var e = cc.visibleRect,
			i = t.width,
			n = t.height,
			r = (n + 4) / 2,
			c = cc.size(2 * (i + r), 2 * r);
		this._lightNode = new cc.Node;
		this._lightNode.setContentSize(c);
		this._lightNode.setPosition(cc.p(e.center.x + i / 2 - c.width, e.center.y - (r - n / 2)));
		this.addChild(this._lightNode, 1);
		i = new(cc.DrawNode.extend({
			fillTransformCircle: function(t, e) {
				if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
					for (var i = Math.min(400, 2 * e), n = 2 * Math.PI / i, c = [], s, o, a = 0; a <= i; a++) s = a * n, o = e * Math.cos(s) + t.x, s = e * Math.sin(s) + t.y, c.push(cc.p(o, s));
					this.drawPoly(c, cc.color(0, 0, 0, 0), 1, cc.color(0, 0, 0, 0))
				} else this.drawDot(t, r, cc.color(0, 0, 0, 0))
			}
		}));
		i.fillTransformCircle(cc.p(c.width / 2, r), r);
		i = new cc.ClippingNode(i);
		i.setContentSize(c);
		i.setInverted(!0);
		n = new cc.LayerColor(cc.color(0, 0, 0, 226));
		n.setContentSize(c);
		i.addChild(n);
		this._lightNode.addChild(i);
		c = new cc.Texture2D;
		c.initWithElement(t);
		c.handleLoadedTexture();
		t = new cc.Sprite(c);
		t.setAnchorPoint(.5, 0);
		t.setPosition(e.center);
		this.addChild(t)
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this.schedule(this._startLoading);
		this._label.setString("Loading... 0%");
		setTimeout(function() {
			this._logoLoaded = !0
		}.bind(this), 2e3)
	},
	_showLogo: function() {
		this._flag = !0;
		if (this._lightNode) {
			this._flag = !1;
			var t = this._lightNode.getPosition();
			this._lightNode.runAction(cc.sequence(cc.moveBy(1.3, cc.p(this._lightNode.width / 2 + this._lightNode.height / 2 - 1, 0)), cc.delayTime(.2), cc.callFunc(function() {
				this._lightNode && (this._lightNode.setPosition(t), this._lightNode.setVisible(!1))
			}, this), cc.delayTime(1), cc.callFunc(function() {
				this._flag ? (this.cb && this.cb(), this._lightNode.setVisible(!0)) : this._flag = !0
			}, this)))
		}
	},
	initWithResources: function(t, e) {
		cc.isString(t) && (t = [t]);
		this.resources = t || [];
		this.cb = e
	},
	_startLoading: function() {
		this._logoLoaded && (this.unschedule(this._startLoading), this._showLogo(), cc.loader.load(this.resources, function(t, e, i) {
			t = Math.min(100 * (i / e) | 0, 100);
			this._label.setString("Loading... " + t + "%")
		}.bind(this), function() {
			this._flag ? (this.cb && this.cb(), this._lightNode && this._lightNode.setVisible(!0)) : this._flag = !0
		}.bind(this)))
	}
}), loaderScene = null;
LoaderScene.preload = function(t, e, i) {
	loaderScene || (loaderScene = new LoaderScene, loaderScene.init(i));
	loaderScene.initWithResources(t, e);
	cc.director.runScene(loaderScene);
	return loaderScene
};
var gameLayer = cc.Layer.extend({
	_gameTime: 0,
	_beganPos: cc.p(0, 0),
	_plane: null,
	_planeSpeed: 0,
	_bossItem: null,
	_myBulletList: [],
	_myBulletSpeed: 0,
	_myBulletTime: 0,
	_sideBullet: !1,
	_otherBulletList: [],
	_bulletPosX: 0,
	_needCreateBulletList: [],
	_monsterList: [],
	_level: 0,
	_levelData: {},
	_life: 0,
	_lifePlane: [],
	_bossTime: !1,
	_bossBulletTime: !1,
	_score: 0,
	ctor: function() {
		this._super();
		this._init();
		return !0
	},
	_init: function() {
		this._gameTime = 10;
		this._beganPos = cc.p(0, 0);
		this._myBulletList = [];
		this._myBulletSpeed = cc.visibleRect.top.y - cc.visibleRect.bottom.y;
		this._otherBulletList = [];
		this._bulletPosX = 0;
		this._planeSpeed = 1.2;
		this._monsterList = [];
		this._needCreateBulletList = [];
		this._life = 3;
		this._lifePlane = [];
		this._bossBulletTime = this._bossTime = !1;
		this._bossItem = this._plane = null;
		this._level = 1;
		this._levelData = config["level" + this._level].monster;
		this._sideBullet = !1;
		this._myBulletTime = .2;
		var t = new cc.LayerColor(cc.color(216, 216, 216, 255));
		this.addChild(t);
		t = new CloudNode;
		this.addChild(t);
		var e = new cc.DrawNode;
		e.drawRect(cc.p(cc.visibleRect.left.x + 50, cc.visibleRect.top.y - 200), cc.p(cc.visibleRect.left.x + 52, cc.visibleRect.top.y - 750), cc.color(0, 0, 0, 255), 1, cc.color(0, 0, 0, 255));
		for (t = 0; 8 > t; t++) e.drawDot(cc.p(cc.visibleRect.left.x + 51, cc.visibleRect.top.y - 200 - 80 * t), 10, cc.color(0, 0, 0, 255));
		this.addChild(e, 0);
		this.posPlane = new cc.Sprite("#road_1.png");
		this.posPlane.setPosition(cc.visibleRect.left.x + 50, cc.visibleRect.top.y - 105 - 640 - this.posPlane.height);
		this.addChild(this.posPlane, 0);
		this.posPlane.runAction(cc.moveBy(10, cc.p(0, 83)));
		e = new cc.Sprite("#score.png");
		this.addChild(e);
		e.setAnchorPoint(.5, 1);
		e.setPosition(cc.visibleRect.left.x + 2 * e.width / 3, cc.visibleRect.top.y - e.height);
		for (t = 0; t < this._life; t++) {
			var i = new cc.Sprite("#life.png");
			this.addChild(i);
			i.setAnchorPoint(0, 1);
			i.setPosition(cc.visibleRect.left.x + i.width * t + 10, e.y - 100);
			this._lifePlane.push(i)
		}
		this._score = 0;
		this.scoreNum = new cc.LabelAtlas("0", res.number2, 25, 37, "0");
		this.scoreNum.setString(this._score);
		this.addChild(this.scoreNum);
		this.scoreNum.setAnchorPoint(0, 1);
		this.scoreNum.setPosition(e.x + e.width / 2 + 10, e.y);
		t = new cc.LabelTTF("", "Arial", 40);
		t.setPosition(cc.visibleRect.center.x, cc.visibleRect.top.y - 300);
		this.addChild(t);
		t.runAction(cc.sequence(cc.fadeIn(2), cc.fadeOut(2)));
		t.setColor(cc.color(125, 0, 0, 255));
		t = new cc.MenuItemImage("#pause.png", "", function() {
			var t = cc.director.getRunningScene();
			t && t.onPause && t.onPause();
			cc.director.pause()
		}, this);
		t.setPosition(cc.visibleRect.right.x - t.width, cc.visibleRect.top.y - t.height);
		t = new cc.Menu(t);
		this.addChild(t, 10);
		t.setPosition(0, 10);
		this._plane = new Plane(this._level);
		this.addChild(this._plane);
		this._plane.setPosition(cc.visibleRect.center.x, cc.visibleRect.bottom.y + this._plane._sHeight / 2)
	},
	onEnter: function() {
		this._super();
		cc.eventManager.addListener({
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			swallowTouches: !0,
			onTouchBegan: this._onTouchBegan.bind(this),
			onTouchMoved: this._onTouchMoved.bind(this),
			onTouchEnded: this._onTouchEnded.bind(this)
		}, this);
		0 < this._levelData.down && this.schedule(this._createMonster0, this._levelData.down);
		0 < this._levelData.leftOrRight && this.schedule(this._createMonster1, this._levelData.leftOrRight);
		this.schedule(this._createMyBullet, this._myBulletTime);
		this.scheduleUpdate()
	},
	_onTouchBegan: function(t, e) {
		this._beganPos = e.getCurrentTarget().convertToNodeSpace(t.getLocation());
		return this._plane ? !0 : !1
	},
	_onTouchMoved: function(t, e) {
		var i = e.getCurrentTarget().convertToNodeSpace(t.getLocation()),
			n = i.x - this._beganPos.x,
			r = i.y - this._beganPos.y,
			c = this._plane.getPosition(),
			n = c.x + this._planeSpeed * n,
			r = c.y + this._planeSpeed * r;
		n >= cc.visibleRect.left.x + this._plane._Width / 2 && n <= cc.visibleRect.right.x - this._plane._Width / 2 ? this._plane.setPositionX(n) : n < cc.visibleRect.left.x + this._plane._Width / 2 ? this._plane.setPositionX(cc.visibleRect.left.x + this._plane._Width / 2) : this._plane.setPositionX(cc.visibleRect.right.x - this._plane._Width / 2);
		r >= cc.visibleRect.bottom.y + this._plane._Height / 2 && r <= cc.visibleRect.top.y - this._plane._Height / 2 ? this._plane.setPositionY(r) : r < cc.visibleRect.bottom.y + this._plane._Height / 2 ? this._plane.setPositionY(cc.visibleRect.bottom.y + this._plane._Height / 2) : this._plane.setPositionY(cc.visibleRect.top.y - this._plane._Height / 2);
		this._beganPos = i
	},
	_onTouchEnded: function(t, e) {
		this._beganPos = cc.p(0, 0)
	},
	update: function(t) {
		this._bossTime || (0 >= this._gameTime ? (this._gameTime = 10, this.unschedule(this._createMonster0), this.unschedule(this._createMonster1), this._bossTime = !0, this._bossItem = null, this._bossItem = new Boss(this._level), this.addChild(this._bossItem), this.schedule(this._createBossBulletList, this._bossItem._bulletTime)) : this._gameTime -= t);
		for (var e = 0; e < this._monsterList.length; e++) {
			if (this._monsterList[e]._doBullet && 0 != this._monsterList[e]._bulletType && this._monsterList[e]._effect) {
				var i = this._monsterList[e];
				1 == i._bulletType ? this._createBullet(i._bulletSprite, cc.p(i.getPositionX(), i.getPositionY() - i._sHeight / 2), .5 * cc.visibleRect.height, !1) : this._createBullet(i._bulletSprite, cc.p(i.getPositionX(), i.getPositionY() - i._sHeight / 2), .5 * cc.visibleRect.height, !0);
				this._monsterList[e]._doBullet = !1
			}
			this._monsterList[e]._isDestroy && (this._monsterList.splice(e, 1), e--)
		}
		if (this._bossItem && this._bossTime) for (e = 0; e < this._needCreateBulletList.length; e++) if (i = this._needCreateBulletList[e], 0 < i._createNum) if (0 <= i._dtTime) i._dtTime -= t;
		else {
			i._dtTime = i._time;
			for (var n = 0; n < i._bulletPos.length; n++) i._canGuide ? this._createBullet(this._bossItem._bulletSprite, cc.p(this._bossItem.getPositionX() + i._bulletPos[n].x, this._bossItem.getPositionY() + i._bulletPos[n].y), this._bossItem._bulletSpeed, !0) : this._createBullet(this._bossItem._bulletSprite, cc.p(this._bossItem.getPositionX() + i._bulletPos[n].x, this._bossItem.getPositionY() + i._bulletPos[n].y), this._bossItem._bulletSpeed, !1);
			i._createNum--
		} else this._needCreateBulletList.splice(e, 1), e--;
		this._checkHit()
	},
	_checkHit: function() {
		this._plane._isProtect || this._checkMyself();
		0 < this._monsterList.length && 0 < this._myBulletList.length && this._checkMonster();
		this._bossTime && this._bossItem && this._checkBoss()
	},
	_checkMyself: function() {
		for (var t = this._plane._getRect(), e = 0; e < this._otherBulletList.length; e++) {
			var i = this._otherBulletList[e]._getRect();
			if (cc.rectIntersectsRect(t, i)) {
				this._life--;
				this._updatePlaneLife();
				this._plane._blinkAction();
				0 >= this._life && this._gameOver(!1);
				this._otherBulletList[e]._destroySelf();
				this._otherBulletList.splice(e, 1);
				break
			}
		}
		for (e = 0; e < this._monsterList.length; e++) if (i = this._monsterList[e]._getRect(), cc.rectIntersectsRect(t, i) && this._monsterList[e]._effect) {
			this._life--;
			this._updatePlaneLife();
			this._plane._blinkAction();
			0 >= this._life && this._gameOver(!1);
			this._monsterList[e]._destroySelf();
			this._monsterList.splice(e, 1);
			break
		}
		this._bossTime && this._bossItem && (e = this._bossItem._getRect(), cc.rectIntersectsRect(t, e) && (this._life--, this._updatePlaneLife(), this._plane._blinkAction(), 0 >= this._life && this._gameOver(!1)))
	},
	_checkMonster: function() {
		for (var t = 0; t < this._monsterList.length; t++) if (this._monsterList[t]._effect) for (var e = this._monsterList[t]._getRect(), i = 0; i < this._myBulletList.length; i++) if (this._myBulletList[i]._isDestroy) this._myBulletList[i]._destroySelf(), this._myBulletList.splice(i, 1), i--;
		else {
			var n = this._myBulletList[i]._getRect();
			if (cc.rectIntersectsRect(e, n) && (this._myBulletList[i]._destroySelf(), this._myBulletList.splice(i, 1), this._monsterList[t]._life--, 0 >= this._monsterList[t]._life)) {
				this._monsterList[t]._destroySelf();
				this._monsterList.splice(t, 1);
				t--;
				this._score += 20;
				this.scoreNum.setString(this._score);
				break
			}
		}
	},
	_checkBoss: function() {
		for (var t = this._bossItem._getRect(), e = 0; e < this._myBulletList.length; e++) if (this._myBulletList[e]._isDestroy) this._myBulletList[e]._destroySelf(), this._myBulletList.splice(e, 1), e--;
		else {
			var i = this._myBulletList[e]._getRect();
			if (cc.rectIntersectsRect(t, i) && (i = this._bossItem.getPosition(), this._myBulletList[e]._destroySelf(), this._myBulletList.splice(e, 1), e--, this._bossItem._life--, 0 >= this._bossItem._life)) {
				this.unschedule(this._createBossBulletList);
				this._bossItem._destroySelf();
				this._bossItem.removeFromParent();
				this._bossItem = null;
				for (e = this._needCreateBulletList.length = 0; this._monsterList.length > e; e++) this._monsterList[e]._destroySelf(), this._monsterList.splice(e, 1), e--;
				for (e = 0; this._otherBulletList.length > e; e++) this._otherBulletList[e]._destroySelf(), this._otherBulletList.splice(e, 1), e--;
				this._score += 100 * this._level;
				this.scoreNum.setString(this._score);
				6 >= this._level ? (t = new cc.Sprite("#item" + this._level + ".png"), this.addChild(t, 5, 3), t.setPosition(i), e = cc.moveTo(.5, this.posPlane.getPosition()), t.runAction(cc.sequence(cc.delayTime(.5), e, cc.callFunc(function() {
					this.getChildByTag(3).removeFromParent();
					this._levelUp()
				}, this)))) : this._levelUp();
				break
			}
		}
	},
	_updatePlaneLife: function() {
		0 < this._lifePlane.length && (this._lifePlane[this._lifePlane.length - 1].removeFromParent(), this._lifePlane.splice(this._lifePlane.length - 1, 1))
	},
	_levelUp: function() {
		switch (this._level) {
		case 1:
			this._myBulletSpeed *= 2;
			this._life++;
			var t = new cc.Sprite("#life.png");
			this.addChild(t);
			t.setAnchorPoint(0, 1);
			t.setPosition(cc.visibleRect.left.x + t.width * this._lifePlane.length + 10, this._lifePlane[0].y);
			this._lifePlane.push(t);
			break;
		case 3:
			this.unschedule(this._createMyBullet);
			this._myBulletTime /= 2;
			this.schedule(this._createMyBullet, this._myBulletTime);
			break;
		case 4:
			this.unschedule(this._createMyBullet), this._myBulletTime /= 1.5, this._myBulletSpeed *= 1.5, this.schedule(this._createMyBullet, this._myBulletTime)
		}
		7 == this._level ? this._gameOver(!0) : (this._level++, t = this._plane.getPosition(), this._plane.removeFromParent(), this._plane = null, this._plane = new Plane(this._level), this._plane.setPosition(t), this.addChild(this._plane), t = cc.blink(1, 10), this._plane.runAction(cc.sequence(t, cc.callFunc(function() {
			this._plane.setVisible(!0)
		}, this))), this._bossTime = !1, this._levelData = config["level" + this._level].monster, 0 < this._levelData.down && this.schedule(this._createMonster0, this._levelData.down), 0 < this._levelData.leftOrRight && this.schedule(this._createMonster1, this._levelData.leftOrRight), this.posPlane.runAction(cc.moveBy(10, cc.p(0, 83))))
	},
	_getTargetPos: function(t, e) {
		var i = t.getPosition(),
			n = cc.p(0, 0);
		if (i.x == e.x) n = i.y >= e.y ? cc.p(i.x, cc.visibleRect.bottom.y - t._sHeight / 2) : cc.p(i.x, cc.visibleRect.top.y + t._sHeight / 2);
		else {
			var r = (i.y - e.y) / (i.x - e.x),
				c = 0;
			i.y > e.y ? (c = (i.y - cc.visibleRect.bottom.y) / r, 0 < r ? i.x - c < cc.visibleRect.left.x - t._sWidth / 2 ? (n.x = cc.visibleRect.left.x - t._sWidth / 2, n.y = i.y - (i.x - n.x) * r) : (n.y = cc.visibleRect.bottom.y - t._sHeight / 2, n.x = i.x - (i.y - n.y) / r) : i.x - c < cc.visibleRect.right.x + t._sWidth / 2 ? (n.x = cc.visibleRect.right.x + t._sWidth / 2, n.y = i.y - (i.x - n.x) * r) : (n.y = cc.visibleRect.bottom.y - t._sHeight / 2, n.x = i.x - (i.y - n.y) / r)) : (c = (cc.visibleRect.top.y - i.y) / r, 0 < r ? i.x + c < cc.visibleRect.right.x + t._sWidth / 2 ? (n.y = cc.visibleRect.top.y + t._sHeight / 2, n.x = i.x + (n.y - i.y) / r) : (n.x = cc.visibleRect.right.x + t._sWidth / 2, n.y = i.y + (n.x - i.x) * r) : i.x - c < cc.visibleRect.left.x - t._sWidth / 2 ? (n.y = cc.visibleRect.top.y + t._sHeight / 2, n.x = i.x + (n.y - i.y) / r) : (n.x = cc.visibleRect.left.x - t._sWidth / 2, n.y = i.y - (i.x - n.x) * r));
			t._changeRotation(e)
		}
		return n
	},
	_createMyBullet: function() {
		if (this._plane) {
			var t = this._plane.getPosition();
			switch (this._level) {
			case 1:
			case 2:
				var e = cc.p(t.x, t.y + this._plane._sHeight / 2),
					e = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed);
				this.addChild(e);
				e._setMoving(cc.p(e.x, cc.visibleRect.top.y + e._sHeight / 2));
				this._myBulletList.push(e);
				break;
			case 3:
				var e = cc.p(t.x - this._plane._sWidth / 4, t.y + this._plane._sHeight / 3),
					i = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed);
				this.addChild(i);
				i._setMoving(cc.p(i.x, cc.visibleRect.top.y + i._sHeight / 2));
				this._myBulletList.push(i);
				e = cc.p(t.x, t.y + this._plane._sHeight / 2);
				i = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed);
				this.addChild(i);
				i._setMoving(cc.p(i.x, cc.visibleRect.top.y + i._sHeight / 2));
				this._myBulletList.push(i);
				e = cc.p(t.x + this._plane._sWidth / 4, t.y + this._plane._sHeight / 3);
				e = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed);
				this.addChild(e);
				e._setMoving(cc.p(e.x, cc.visibleRect.top.y + e._sHeight / 2));
				this._myBulletList.push(e);
				break;
			case 4:
			case 5:
				cc.p(0, 0);
				e = cc.p(t.x, t.y + this._plane._sHeight / 2);
				e = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed);
				this.addChild(e);
				e._setMoving(cc.p(e.x, cc.visibleRect.top.y + e._sHeight / 2));
				this._myBulletList.push(e);
				this._sideBullet && (e = cc.p(t.x - this._plane._sWidth / 4, t.y + this._plane._sHeight / 5), i = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed), this.addChild(i), i._setMoving(cc.p(i.x, cc.visibleRect.top.y + i._sHeight / 2)), this._myBulletList.push(i), e = cc.p(t.x + this._plane._sWidth / 4, t.y + this._plane._sHeight / 5), e = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed), this.addChild(e), e._setMoving(cc.p(e.x, cc.visibleRect.top.y + e._sHeight / 2)), this._myBulletList.push(e));
				this._sideBullet = !this._sideBullet;
				break;
			case 6:
				cc.p(0, 0);
				e = cc.p(t.x, t.y + this._plane._sHeight / 2);
				e = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed);
				this.addChild(e);
				e._setMoving(cc.p(e.x, cc.visibleRect.top.y + e._sHeight / 2));
				this._myBulletList.push(e);
				this._sideBullet && (e = cc.p(t.x - this._plane._sWidth / 4, t.y + this._plane._sHeight / 3), i = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed), this.addChild(i), i._setMoving(cc.p(i.x, cc.visibleRect.top.y + i._sHeight / 2)), this._myBulletList.push(i), e = cc.p(t.x + this._plane._sWidth / 4, t.y + this._plane._sHeight / 3), e = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed), this.addChild(e), e._setMoving(cc.p(e.x, cc.visibleRect.top.y + e._sHeight / 2)), this._myBulletList.push(e), e = cc.p(t.x - this._plane._sWidth / 6, t.y), i = new Bullet(!0, "#bullet.png", e, 2 * this._myBulletSpeed), this.addChild(i), e = this._findMonster(i), i._setMoving(e), this._myBulletList.push(i), e = cc.p(t.x + this._plane._sWidth / 6, t.y), i = new Bullet(!0, "#bullet.png", e, 2 * this._myBulletSpeed), this.addChild(i), e = this._findMonster(i), i._setMoving(e), this._myBulletList.push(i));
				this._sideBullet = !this._sideBullet;
				break;
			case 7:
				cc.p(0, 0), e = cc.p(t.x - 10, t.y + this._plane._sHeight / 2 - 20), e = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed), this.addChild(e), e._setMoving(cc.p(e.x, cc.visibleRect.top.y + e._sHeight / 2)), this._myBulletList.push(e), e = cc.p(t.x + 10, t.y + this._plane._sHeight / 2 - 20), i = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed), this.addChild(i), i._setMoving(cc.p(i.x, cc.visibleRect.top.y + i._sHeight / 2)), this._myBulletList.push(i), this._sideBullet && (e = cc.p(t.x - this._plane._sWidth / 4, t.y + this._plane._sHeight / 3), i = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed), this.addChild(i), i._setMoving(cc.p(i.x, cc.visibleRect.top.y + i._sHeight / 2)), this._myBulletList.push(i), e = cc.p(t.x + this._plane._sWidth / 4, t.y + this._plane._sHeight / 3), e = new Bullet(!0, "#bullet.png", e, this._myBulletSpeed), this.addChild(e), e._setMoving(cc.p(e.x, cc.visibleRect.top.y + e._sHeight / 2)), this._myBulletList.push(e), e = cc.p(t.x - this._plane._sWidth / 6, t.y), i = new Bullet(!0, "#bullet.png", e, 2 * this._myBulletSpeed), this.addChild(i), e = this._findMonster(i), i._setMoving(e), this._myBulletList.push(i), e = cc.p(t.x + this._plane._sWidth / 6, t.y), i = new Bullet(!0, "#bullet.png", e, 2 * this._myBulletSpeed), this.addChild(i), e = this._findMonster(i), i._setMoving(e), this._myBulletList.push(i)), this._sideBullet = !this._sideBullet
			}
		}
	},
	_findMonster: function(t) {
		var e = cc.p(t.getPositionX(), cc.visibleRect.top.y + this._plane._sHeight / 2),
			i = cc.visibleRect.height,
			n = null;
		if (0 < this._monsterList.length) for (var r = 0; r < this._monsterList.length; r++) if (this._monsterList[r]._effect) {
			var c = cc.pDistance(t.getPosition(), this._monsterList[r].getPosition());
			c < i && (e = this._monsterList[r].getPosition(), i = c, n = this._monsterList[r])
		}
		this._bossTime && this._bossItem && (c = cc.pDistance(t.getPosition(), this._bossItem.getPosition()), c < i && (e = this._bossItem.getPosition(), n = this._bossItem));
		null != n && (e = this._getTargetPos(t, e));
		return e
	},
	_createBossBulletList: function() {
		for (var t = Math.random() * this._bossItem._bulletTimes, e = 0; e < this._bossItem._bulletTimes; e++) {
			var i = {
				_canGuide: !1,
				_createNum: 0,
				_time: 0,
				_speed: 0,
				_dtTime: 0,
				_bulletPos: []
			};
			i._speed = this._bossItem._bulletSpeed;
			i._createNum = this._bossItem._bulletNum;
			i._bulletPos = this._bossItem._bulletPos;
			i._dtTime = i._time = this._bossItem._everyBulletTime;
			i._canGuide = e < t && t <= e + 1 ? !0 : !1;
			i._createNum = this._bossItem._bulletNum;
			this._needCreateBulletList.push(i)
		}
	},
	_createBullet: function(t, e, i, n) {
		t = new Bullet(!1, t, e, i);
		this.addChild(t);
		n ? (e = this._getTargetPos(t, this._plane.getPosition()), t._setMoving(e)) : t._setMoving(cc.p(t.x, cc.visibleRect.bottom.y));
		this._bossTime && 4 == this._level && t.runAction(cc.rotateBy(1, 360).repeatForever());
		this._otherBulletList.push(t)
	},
	_createMonster0: function() {
		for (var t = 1, e = 3, t = .5 > Math.random() ? 1 : 2, e = Math.random(), e = e < 1 / 3 ? 2 : e < 2 / 3 ? 3 : 4, i = 0, n = 0, r = null, c = !1, s = 0; s < t; s++) {
			i = 0;
			r = null;
			c = !1;
			Math.random() < this._levelData.goBullet ? (r = this._levelData.bulletSprite, i = cc.visibleRect.height / 2, n = Math.random() < this._levelData.bulletGuide ? 2 : 1) : n = 0;
			Math.random() <= this._levelData.guide && (c = !0);
			var o = cc.visibleRect.left.x + Math.random() * (cc.visibleRect.right.x - cc.visibleRect.left.x);
			65 > Math.abs(o - this._bulletPosX) ? o = o > this._bulletPosX ? o + 65 >= cc.visibleRect.right.x ? this._bulletPosX - 65 : o + 65 : o - 65 <= cc.visibleRect.left.x ? this._bulletPosX + 65 : o - 65 : o > cc.visibleRect.right.x - 32.5 ? o = cc.visibleRect.right.x - 32.5 : o < cc.visibleRect.left.x + 32.5 && (o = cc.visibleRect.left.x + 32.5);
			this._bulletPosX = o;
			for (var a = 0; a < e; a++) {
				var h = new Monster(r, i, n);
				this.addChild(h);
				h.setPosition(o, cc.visibleRect.top.y + h._sHeight / 2);
				if (c) {
					var l = this._getTargetPos(h, this._plane.getPosition());
					h._setMoving(.25 * a, l)
				} else h._setMoving(.25 * a, cc.p(h.x, cc.visibleRect.bottom.y - h._sHeight / 2));
				this._monsterList.push(h)
			}
		}
	},
	_createMonster1: function() {
		for (var t = 1, e = 3, t = .5 > Math.random() ? 1 : 2, e = Math.random(), e = e < 1 / 3 ? 2 : e < 2 / 3 ? 3 : 4, i = 0, n = 0, r = null, c = !1, s = 0; s < t; s++) {
			i = 0;
			r = null;
			c = !1;
			Math.random() < this._levelData.goBullet ? (r = this._levelData.bulletSprite, Math.random() < this._levelData.bulletGuide ? (i = cc.visibleRect.height / 2, n = 2) : n = 1) : n = 0;
			Math.random() <= this._levelData.guide && (c = !0);
			for (var o = 0; o < e; o++) {
				var a = new Monster(r, i, n);
				this.addChild(a);.5 > Math.random() ? a.setPositionX(cc.visibleRect.left.x - a._sWidth / 2) : a.setPositionX(cc.visibleRect.right.x + a._sWidth / 2);
				a.setPositionY(cc.visibleRect.center.y + Math.random() * (cc.visibleRect.top.y - cc.visibleRect.center.y));
				if (c) {
					var h = this._getTargetPos(a, this._plane.getPosition());
					a._setMoving(.11 * o, h)
				} else h = cc.visibleRect.left.x + Math.random() * (cc.visibleRect.right.x - cc.visibleRect.left.x), a._setMoving(.11 * o, cc.p(h, cc.visibleRect.bottom.y - a._sHeight / 2));
				this._monsterList.push(a)
			}
		}
	},
	_gameOver: function(t) {
		this._plane.removeFromParent();
		this.unschedule(this._createMyBullet, this);
		this.runAction(cc.sequence(cc.delayTime(1), cc.callFunc(function() {
			var e = "",
				e = 1 == this._level ? "#result1.png" : 3 >= this._level ? "#result2.png" : 5 >= this._level ? "#result3.png" : "#result4.png",
				i = cc.director.getRunningScene();
			i && i.onGameEnd && i.onGameEnd(this._score, e, t)
		}, this)))
	}
});
var Plane = cc.Sprite.extend({
	_sWidth: 0,
	_sHeight: 0,
	_Width: 0,
	_Height: 0,
	_beganPos: cc.p(0, 0),
	_rect: cc.rect(0, 0, 0, 0),
	_isProtect: !1,
	ctor: function(t) {
		this._super();
		this._init(t);
		return !0
	},
	_init: function(t) {
		t = new cc.Sprite("#level" + t + ".png");
		this.addChild(t);
		this._sHeight = t.height;
		this._sWidth = t.width;
		this.setPosition(cc.visibleRect.center.x, cc.visibleRect.bottom.y + t.height / 2);
		this._beganPos = cc.p(0, 0);
		this._rect = cc.rect(0, 0, 0, 0);
		this._isProtect = !1;
		(new cc.DrawNode).drawRect(cc.p(-20, 0), cc.p(20, this._sHeight / 2 - 5), null, 2, cc.color(255, 0, 0, 255));
		this._Width = 40;
		this._Height = this._sHeight / 2 - 5
	},
	_blinkAction: function() {
		this._isProtect = !0;
		this.runAction(cc.sequence(cc.blink(1, 4), cc.callFunc(function() {
			this.setVisible(!0);
			this._isProtect = !1
		}, this)))
	},
	_getRect: function() {
		return cc.rect(this.x - 20, this.y, 40, this._sHeight / 2 - 5)
	}
}),
	Monster = cc.Sprite.extend({
		_sWidth: 0,
		_sHeight: 0,
		_life: 0,
		_speed: 0,
		_doBullet: !1,
		_bulletSprite: null,
		_bulletSpeed: 0,
		_bulletType: 0,
		_effect: !1,
		_isDestroy: !1,
		ctor: function(t, e, i) {
			this._super();
			this._init(t, e, i);
			return !0
		},
		_init: function(t, e, i) {
			var n = new cc.Sprite("#diji.png");
			this.addChild(n);
			this._sWidth = n.width;
			this._sHeight = n.height;
			this._doBullet = !1;
			this._bulletType = i;
			0 != i && (this._doBullet = !0, this._bulletSpeed = e, this.schedule(this._createBullet, 3.5), this._bulletSprite = t);
			this._isDestroy = !1;
			this._life = 2;
			this._speed = .3 * cc.visibleRect.height;
			(new cc.DrawNode).drawRect(cc.p(-this._sWidth / 2, -this._sHeight / 2), cc.p(this._sWidth / 2, this._sHeight / 2), null, 2, cc.color(255, 0, 0, 255))
		},
		onEnter: function() {
			this._super();
			this.scheduleUpdate()
		},
		update: function(t) {
			this.y - this._sHeight / 2 >= cc.visibleRect.top.y ? this._effect = !1 : (this._effect = !0, this.unscheduleUpdate())
		},
		_createBullet: function() {
			this._doBullet = !0
		},
		_setMoving: function(t, e) {
			var i = cc.pDistance(this.getPosition(), e) / this._speed,
				i = cc.moveTo(i, e);
			this.runAction(cc.sequence(cc.delayTime(t), cc.callFunc(function() {}, this), i, cc.callFunc(function() {
				this._destroySelf()
			}, this)))
		},
		_getRect: function() {
			return cc.rect(this.x - this._sWidth / 2, this.y - this._sHeight / 2, this._sWidth, this._sHeight)
		},
		_destroySelf: function() {
			this._isDestroy = !0;
			this.removeFromParent();
			this.stopAllActions();
			this._canBullet && this.unschedule(this._createBullet);
			this._canBullet = !1
		},
		_changeRotation: function(t) {
			t = Math.PI / 2 - Math.atan2(this.y - t.y, this.x - t.x);
			this.setRotation(180 * t / Math.PI)
		}
	}),
	Boss = cc.Sprite.extend({
		_isChange: !1,
		_goPos: cc.p(0, 0),
		_sHeight: 0,
		_sWidth: 0,
		_life: 0,
		_speed: 0,
		_isCreateBullet: !0,
		_bulletSprite: null,
		_bulletTime: 0,
		_bulletNum: 0,
		_bulletTimes: 0,
		_bulletSpeed: 0,
		_everyBulletTime: 0,
		_bulletPos: [],
		_isDestroy: !1,
		ctor: function(t) {
			this._super();
			this._init(t)
		},
		_init: function(t) {
			this._isDestroy = !1;
			t = config["level" + t].boss;
			var e = new cc.Sprite(t.sprite);
			this.addChild(e);
			this._sHeight = e.height;
			this._sWidth = e.width;
			this._life = t.life;
			this._speed = t.speed * cc.visibleRect.height;
			this._bulletSprite = t.bulletSprite;
			this._bulletTime = t.bulletTime;
			this._bulletNum = t.bulletNum;
			this._bulletTimes = t.bulletTimes;
			this._bulletSpeed = t.bulletSpeed * cc.visibleRect.height;
			this._everyBulletTime = t.everyBulletTime;
			this._isCreateBullet = !0;
			this._bulletPos = t.BulletPos;
			this._isChange = !1;
			this._goPos = cc.visibleRect.center;
			this.setPosition(cc.visibleRect.center.x, cc.visibleRect.top.y + this._sHeight / 2);
			this.runAction(cc.sequence(cc.moveTo((cc.visibleRect.top.y + this._sHeight / 2 - cc.visibleRect.center.y + this._sHeight / 2) / this._speed, this._goPos), cc.callFunc(function() {
				this._isChange = !0
			}, this)))
		},
		onEnter: function() {
			this._super();
			this.scheduleUpdate()
		},
		update: function() {
			if (this._isChange) {
				this._isChange = !1;
				this._setNextPos();
				var t = cc.pDistance(this._goPos, this.getPosition()) / this._speed,
					t = cc.moveTo(t, this._goPos);
				this.runAction(cc.sequence(t, cc.callFunc(function() {
					this._isChange = !0
				}, this)))
			}
		},
		_getRect: function() {
			return cc.rect(this.x - this._sWidth / 2, this.y - this._sHeight / 2, this._sWidth, this._sHeight)
		},
		_setNextPos: function() {
			var t = Math.random(),
				e = !1,
				i = cc.visibleRect.left.x + this._sWidth / 2,
				n = cc.visibleRect.right.x - this._sWidth / 2,
				r = cc.visibleRect.top.y - this._sHeight / 2,
				c = cc.visibleRect.center.y + this._sHeight / 2,
				s = Math.random() * (cc.visibleRect.right.x - cc.visibleRect.left.x) + cc.visibleRect.left.x + this._sWidth / 2,
				o = Math.random() * (cc.visibleRect.top.y - cc.visibleRect.center.y) + cc.visibleRect.center.y - this._sHeight / 2;
			s >= cc.visibleRect.right.x - this._sWidth / 2 && (s = cc.visibleRect.right.x - this._sWidth / 2);
			s <= cc.visibleRect.left.x + this._sWidth / 2 && (s = cc.visibleRect.right.x + this._sWidth / 2);
			o >= cc.visibleRect.top.y - this._sWidth / 2 && (o = cc.visibleRect.top.y - this._sWidth / 2);
			o <= cc.visibleRect.center.y + this._sWidth / 2 && (o = cc.visibleRect.center.y + this._sWidth / 2);.25 > t && this.getPositionX() != i && (e = !0, this._goPos = cc.p(i, o));
			!e && (.25 <= t && .5 > t) && this.getPositionX() != n && (e = !0, this._goPos = cc.p(n, o));
			!e && (.5 <= t && .75 > t) && this.getPositionY() != r && (e = !0, this._goPos = cc.p(s, r));
			!e && .75 <= t && this.getPositionY() != c && (this._goPos = cc.p(s, c))
		},
		_destroySelf: function() {
			this.removeFromParent();
			this.unscheduleUpdate();
			this.stopAllActions();
			this._isDestroy = !0
		}
	}),
	Bullet = cc.Sprite.extend({
		_selfBullet: !1,
		_isDestroy: !1,
		_speed: 0,
		_sWidth: 0,
		_sHeight: 0,
		ctor: function(t, e, i, n) {
			this._super();
			this._init(t, e, i, n)
		},
		_init: function(t, e, i, n) {
			e = new cc.Sprite(e);
			this.addChild(e);
			this._sWidth = e.width;
			this._sHeight = e.height;
			this._selfBullet = t;
			this._speed = n;
			this.setPosition(i);
			(new cc.DrawNode).drawRect(cc.p(-this._sWidth / 2, -this._sHeight / 2), cc.p(this._sWidth / 2, this._sHeight / 2), null, 2, cc.color(255, 0, 0, 255))
		},
		_setMoving: function(t) {
			var e = cc.pDistance(this.getPosition(), t) / this._speed;
			t = cc.moveTo(e, t);
			this.runAction(cc.sequence(t, cc.callFunc(function() {
				this._destroySelf()
			}, this)))
		},
		_getRect: function() {
			return rect = cc.rect(this.x - this._sWidth / 2, this.y - this._sHeight / 2, this._sWidth, this._sHeight)
		},
		_destroySelf: function() {
			this.removeFromParent();
			this.stopAllActions();
			this._isDestroy = !0
		},
		_changeRotation: function(t) {
			t = Math.PI / 2 - Math.atan2(this.y - t.y, this.x - t.x);
			this.setRotation(180 * t / Math.PI)
		}
	}),
	config = {
		level1: {
			monster: {
				sprite: "#diji.png",
				life: 2,
				speed: .3,
				guide: 0,
				down: 1.5,
				leftOrRight: 0,
				goBullet: .25,
				bulletSprite: "#zidan.png",
				bulletGuide: 0
			},
			boss: {
				sprite: "#boss_1.png",
				life: 15,
				speed: .2,
				bulletSprite: "#bullet_1.png",
				bulletTime: 2.3,
				bulletNum: 5,
				bulletTimes: 1,
				everyBulletTime: .13,
				BulletPos: [cc.p(0, -112)],
				bulletSpeed: .5
			}
		},
		level2: {
			monster: {
				sprite: "#diji.png",
				life: 2,
				speed: .3,
				guide: .1,
				down: 1.4,
				leftOrRight: 0,
				goBullet: .3,
				bulletSprite: "#zidan.png",
				bulletGuide: 0
			},
			boss: {
				sprite: "#boss_2.png",
				life: 40,
				speed: .2,
				bulletSprite: "#bullet_2.png",
				bulletTime: 2.2,
				bulletNum: 5,
				bulletTimes: 2,
				everyBulletTime: .13,
				BulletPos: [cc.p(0, -108)],
				bulletSpeed: .5
			}
		},
		level3: {
			monster: {
				sprite: "#diji.png",
				life: 2,
				speed: .3,
				guide: .2,
				down: 1.3,
				leftOrRight: 3,
				goBullet: .3,
				bulletSprite: "#zidan.png",
				bulletGuide: 0
			},
			boss: {
				sprite: "#boss_3.png",
				life: 80,
				speed: .3,
				bulletSprite: "#bullet_7.png",
				bulletTime: 2.1,
				bulletNum: 5,
				bulletTimes: 3,
				everyBulletTime: .13,
				BulletPos: [cc.p(-139, 0)],
				bulletSpeed: .5
			}
		},
		level4: {
			monster: {
				sprite: "#diji.png",
				life: 2,
				speed: .3,
				guide: .2,
				down: 1.5,
				leftOrRight: 3,
				goBullet: .3,
				bulletSprite: "#zidan.png",
				bulletGuide: .1
			},
			boss: {
				sprite: "#boss_4.png",
				life: 80,
				speed: .3,
				bulletSprite: "#bullet_4.png",
				bulletTime: 2.1,
				bulletNum: 1,
				bulletTimes: 4,
				everyBulletTime: .12,
				BulletPos: [cc.p(-175, 0), cc.p(175, 0)],
				bulletSpeed: .5
			}
		},
		level5: {
			monster: {
				sprite: "#diji.png",
				life: 2,
				speed: .3,
				guide: .3,
				down: 1.5,
				leftOrRight: 3,
				goBullet: .3,
				bulletSprite: "#zidan.png",
				bulletGuide: .2
			},
			boss: {
				sprite: "#boss_5.png",
				life: 120,
				speed: .4,
				bulletSprite: "#bullet_5.png",
				bulletTime: 2.1,
				bulletNum: 5,
				bulletTimes: 4,
				everyBulletTime: .12,
				BulletPos: [cc.p(-50, -30)],
				bulletSpeed: .5
			}
		},
		level6: {
			monster: {
				sprite: "#diji.png",
				life: 2,
				speed: .3,
				guide: .3,
				down: 1.5,
				leftOrRight: 1.7,
				goBullet: .4,
				bulletSprite: "#zidan.png",
				bulletGuide: .3
			},
			boss: {
				sprite: "#boss_6.png",
				life: 160,
				speed: .4,
				bulletSprite: "#bullet_6.png",
				bulletTime: 2.1,
				bulletNum: 5,
				bulletTimes: 4,
				everyBulletTime: .1,
				BulletPos: [cc.p(-25, -80), cc.p(25, -80)],
				bulletSpeed: .5
			}
		},
		level7: {
			monster: {
				sprite: "#diji.png",
				life: 2,
				speed: .3,
				guide: .4,
				down: 1.5,
				leftOrRight: 1.6,
				goBullet: .4,
				bulletSprite: "#zidan.png",
				bulletGuide: .4
			},
			boss: {
				sprite: "#boss_7.png",
				life: 200,
				speed: .5,
				bulletSprite: "#bullet_7.png",
				bulletTime: 2.1,
				bulletNum: 2,
				bulletTimes: 4,
				everyBulletTime: .1,
				BulletPos: [cc.p(-15, -40), cc.p(15, -40), cc.p(-100, -60), cc.p(100, -60)],
				bulletSpeed: .5
			}
		}
	},
	CloudNode = cc.Node.extend({
		_pool: null,
		_deltX: 0,
		_lastX: 0,
		_childCnt: 0,
		ctor: function() {
			this._super();
			this._childCnt = 3;
			this._pool = {};
			var t = cc.visibleRect;
			this._lastX = t.left.x;
			for (var e, i = (t.height + 87) / this._childCnt, n = 0; n < this._childCnt; n++) e = this._getCloud(), e.setPosition(this._getX(), t.bottom.y + i * (n + 1)), this.addChild(e)
		},
		onEnter: function() {
			this._super();
			this.schedule(this._move)
		},
		_getCloud: function() {
			var t, e = Math.floor(3 * Math.random()),
				i = "cl" + e;
			if (this._pool) {
				var n = this._pool[i];
				n && 0 < n.length && (t = n.shift())
			}
			t || (t = new cc.Sprite("#cloud" + e + ".png"), t.__key = i);
			return t
		},
		_getX: function() {
			var t = cc.visibleRect,
				e = 87 + Math.floor(Math.random() * (t.width / 2 - 174));
			return this._lastX = this._lastX > t.center.x ? this._lastX - e : this._lastX + e
		},
		_move: function(t) {
			var e = this.getChildren(),
				i = cc.visibleRect,
				n, r;
			for (n = e.length - 1; 0 <= n; n--) if (r = e[n], r.y -= i.height * t / 5, 0 == n && r.y < i.bottom.y - r.height / 2) {
				r.removeFromParent();
				this._pool || (this._pool = {});
				this._pool[r.__key] ? this._pool[r.__key].push(r) : this._pool[r.__key] = [r];
				this._addCloud();
				break
			}
		},
		_addCloud: function() {
			var t = this._getCloud();
			t.setPosition(this._getX(), cc.visibleRect.top.y + t.height / 2);
			this.addChild(t)
		}
	});
var PauseLayer = cc.LayerColor.extend({
	ctor: function() {
		this._super(cc.color(0, 0, 0, 180));
		var t = cc.visibleRect,
			e = new cc.MenuItemImage("#begin.png", null, function() {
				this.removeFromParent();
				cc.director.resume()
			}, this);
		e.setPosition(t.center);
		var i = new cc.MenuItem(function() {}, this);
		i.setContentSize(cc.size(t.width, t.height));
		i.setPosition(t.center);
		t = new cc.Menu(i, e);
		t.setPosition(0, 0);
		this.addChild(t)
	}
});
var gameStarLayer = cc.Layer.extend({
	ctor: function() {
		this._super();
		this._init();
		return !0
	},
	_init: function() {
		var t = new cc.LayerColor(cc.color(216, 216, 216, 255));
		this.addChild(t);
		t = new CloudNode;
		this.addChild(t);
		var e = new cc.Sprite("#logo.png");
		this.addChild(e);
		e.setAnchorPoint(.5, 1);
		e.setPosition(cc.visibleRect.center.x, cc.visibleRect.top.y - e.height);
		t = new cc.Sprite("#title.png");
		t.setAnchorPoint(.5, 1);
		t.setPosition(cc.visibleRect.center.x, e.y - e.height - 20);
		this.addChild(t);
		e = new cc.MenuItemImage("#begin.png", "", function() {
			var t = cc.director.getRunningScene();
			t && t.onGame && t.onGame()
		}, this);
		e.setPosition(cc.visibleRect.center.x, t.y - t.height - e.height);
		t = new cc.Menu(e);
		this.addChild(t);
		t.setPosition(0, 0)
	}
}),
	gameEndLayer = cc.Layer.extend({
		ctor: function(t, e, i) {
			this._super();
			this._init(t, e, i);
			return !0
		},
		_init: function(t, e, i) {
			getScore = t;
			var n = new cc.LayerColor(cc.color(216, 216, 216, 255));
			this.addChild(n);
			n = new CloudNode;
			this.addChild(n);
			n = new cc.MenuItemImage("#banner.png", "", function() {}, this);
			n.setAnchorPoint(.5, 0);
			n.setPosition(cc.visibleRect.center.x, cc.visibleRect.bottom.y);
			var r = new cc.Sprite("#end.png");
			this.addChild(r);
			r.setPosition(cc.visibleRect.center.x, cc.visibleRect.top.y - r.height);
			r.setAnchorPoint(.5, 1);
			i = i ? new cc.Sprite("#word3_1.png") : new cc.Sprite("#word3_0.png");
			r.addChild(i);
			i.setPosition(r.width / 2, r.height - i.height);
			var c = new cc.LabelAtlas("0", res.number0, 44, 65, "0");
			c.setString(t);
			r.addChild(c);
			c.setAnchorPoint(.5, 0);
			c.setPosition(r.width / 2, i.y - i.height - c.height);
			t = new cc.Sprite(e);
			r.addChild(t);
			t.setAnchorPoint(.5, 1);
			t.setPosition(r.width - 4 * t.width / 5, t.height / 2);
			t = new cc.MenuItemImage("#replay.png", "", function() {
				var t = cc.director.getRunningScene();
				t && t.onGame && t.onGame()
			}, this);
			e = new cc.MenuItemImage("#share.png", "", function() {
				var t = cc.director.getRunningScene();
				t && t.onShare && t.onShare()
			}, this);
			t.setPosition(cc.visibleRect.center.x - e.width, r.y - 2 * r.height);
			e.setPosition(cc.visibleRect.center.x + e.width, r.y - 2 * r.height);
			n = new cc.Menu(t, e, n);
			this.addChild(n);
			n.setPosition(0, 0)
		}
	}),
	GameScene = cc.Scene.extend({
		onEnter: function() {
			this._super();
			cc.spriteFrameCache.addSpriteFrames(res.qipafeiji_plist);
			cc.spriteFrameCache.addSpriteFrames(res.qipafeiji_plist0);
			var t = new gameStarLayer;
			this.addChild(t)
		},
		onGameStar: function() {
			this.removeAllChildren();
			var t = new gameStarLayer;
			this.addChild(t)
		},
		onGame: function() {
			this.removeAllChildren();
			var t = new gameLayer;
			this.addChild(t)
		},
		onGameEnd: function(t, e, i) {
			this.removeAllChildren();
			Toscore(t);
			t = new gameEndLayer(t, e, i);
			this.addChild(t);
		},
		onShare: function() {
		},
		onPause: function() {
			var t = new PauseLayer;
			this.addChild(t);
		}
	});
var ShareLayer = cc.Layer.extend({
	ctor: function() {
		var t = getScore;
		try {
			parent.__4399finishgame(t)
		} catch (e) {}
		this._super();
		var i = cc.visibleRect,
			n = new cc.LayerColor(cc.color(0, 0, 0, 210));
		n.setPosition(i.bottomLeft);
		n = new cc.Sprite("#sharepage.png");
		n.setAnchorPoint(1, 1);
		n.setPosition(i.right.x - 50, i.top.y - 50);
		n = new cc.MenuItem(function() {
			this.removeFromParent()
		}, this);
		n.setContentSize(cc.size(i.width, i.height));
		n.setPosition(0, 0);
		this.addChild(new cc.Menu(n))
	}
});
cc.game.onStart = function() {
	cc.view.adjustViewPort(!0);
	cc.view.enableAutoFullScreen(!1);
	var t = cc.view.getFrameSize(),
		t = t.width / t.height;.55 < t && .78 > t ? cc.view.setDesignResolutionSize(640, 1007, cc.ResolutionPolicy.NO_BORDER) : cc.view.setDesignResolutionSize(640, 1007, cc.ResolutionPolicy.SHOW_ALL);
	cc.view.resizeWithBrowserSize(!0);
	LoaderScene.preload(g_resources, function() {
		cc.director.runScene(new GameScene)
	}, this)
};
cc.game.run();